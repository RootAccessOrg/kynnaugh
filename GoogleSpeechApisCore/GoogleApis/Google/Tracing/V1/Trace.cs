// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/tracing/trace.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Tracing.V1 {

  /// <summary>Holder for reflection information generated from google/tracing/trace.proto</summary>
  public static partial class TraceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/tracing/trace.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TraceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chpnb29nbGUvdHJhY2luZy90cmFjZS5wcm90bxIRZ29vZ2xlLnRyYWNpbmcu",
            "djEaHGdvb2dsZS9hcGkvYW5ub3RhdGlvbnMucHJvdG8aH2dvb2dsZS9wcm90",
            "b2J1Zi90aW1lc3RhbXAucHJvdG8aF2dvb2dsZS9ycGMvc3RhdHVzLnByb3Rv",
            "Ih4KB1RyYWNlSWQSEwoLaGV4X2VuY29kZWQYASABKAkiKgoGTW9kdWxlEg4K",
            "Bm1vZHVsZRgBIAEoCRIQCghidWlsZF9pZBgCIAEoCSKxAgoKU3RhY2tUcmFj",
            "ZRI9CgtzdGFja19mcmFtZRgBIAMoCzIoLmdvb2dsZS50cmFjaW5nLnYxLlN0",
            "YWNrVHJhY2UuU3RhY2tGcmFtZRIbChNzdGFja190cmFjZV9oYXNoX2lkGAIg",
            "ASgEGsYBCgpTdGFja0ZyYW1lEhUKDWZ1bmN0aW9uX25hbWUYASABKAkSGgoS",
            "b3JpZ19mdW5jdGlvbl9uYW1lGAIgASgJEhEKCWZpbGVfbmFtZRgDIAEoCRIT",
            "CgtsaW5lX251bWJlchgEIAEoAxIVCg1jb2x1bW5fbnVtYmVyGAUgASgDEi4K",
            "C2xvYWRfbW9kdWxlGAYgASgLMhkuZ29vZ2xlLnRyYWNpbmcudjEuTW9kdWxl",
            "EhYKDnNvdXJjZV92ZXJzaW9uGAcgASgJIlgKCkxhYmVsVmFsdWUSFgoMc3Ry",
            "aW5nX3ZhbHVlGAEgASgJSAASEwoJaW50X3ZhbHVlGAIgASgDSAASFAoKYm9v",
            "bF92YWx1ZRgDIAEoCEgAQgcKBXZhbHVlIo0KCgRTcGFuEgoKAmlkGAEgASgG",
            "EgwKBG5hbWUYAiABKAkSEQoJcGFyZW50X2lkGAMgASgGEjQKEGxvY2FsX3N0",
            "YXJ0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjIK",
            "DmxvY2FsX2VuZF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVz",
            "dGFtcBIzCgZsYWJlbHMYBiADKAsyIy5nb29nbGUudHJhY2luZy52MS5TcGFu",
            "LkxhYmVsc0VudHJ5EjIKC3N0YWNrX3RyYWNlGAcgASgLMh0uZ29vZ2xlLnRy",
            "YWNpbmcudjEuU3RhY2tUcmFjZRI2Cgt0aW1lX2V2ZW50cxgIIAMoCzIhLmdv",
            "b2dsZS50cmFjaW5nLnYxLlNwYW4uVGltZUV2ZW50EisKBWxpbmtzGAkgAygL",
            "MhwuZ29vZ2xlLnRyYWNpbmcudjEuU3Bhbi5MaW5rEiIKBnN0YXR1cxgKIAEo",
            "CzISLmdvb2dsZS5ycGMuU3RhdHVzEhkKEWhhc19yZW1vdGVfcGFyZW50GAsg",
            "ASgIGukECglUaW1lRXZlbnQSLgoKbG9jYWxfdGltZRgBIAEoCzIaLmdvb2ds",
            "ZS5wcm90b2J1Zi5UaW1lc3RhbXASQgoKYW5ub3RhdGlvbhgCIAEoCzIsLmdv",
            "b2dsZS50cmFjaW5nLnYxLlNwYW4uVGltZUV2ZW50LkFubm90YXRpb25IABJH",
            "Cg1uZXR3b3JrX2V2ZW50GAMgASgLMi4uZ29vZ2xlLnRyYWNpbmcudjEuU3Bh",
            "bi5UaW1lRXZlbnQuTmV0d29ya0V2ZW50SAAauQEKCkFubm90YXRpb24SEwoL",
            "ZGVzY3JpcHRpb24YASABKAkSSAoGbGFiZWxzGAIgAygLMjguZ29vZ2xlLnRy",
            "YWNpbmcudjEuU3Bhbi5UaW1lRXZlbnQuQW5ub3RhdGlvbi5MYWJlbHNFbnRy",
            "eRpMCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSLAoFdmFsdWUYAiABKAsy",
            "HS5nb29nbGUudHJhY2luZy52MS5MYWJlbFZhbHVlOgI4ARrZAQoMTmV0d29y",
            "a0V2ZW50Ei8KC2tlcm5lbF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVm",
            "LlRpbWVzdGFtcBJBCgR0eXBlGAIgASgOMjMuZ29vZ2xlLnRyYWNpbmcudjEu",
            "U3Bhbi5UaW1lRXZlbnQuTmV0d29ya0V2ZW50LlR5cGUSEgoKbWVzc2FnZV9p",
            "ZBgDIAEoBBIUCgxtZXNzYWdlX3NpemUYBCABKAQiKwoEVHlwZRIPCgtVTlNQ",
            "RUNJRklFRBAAEggKBFNFTlQQARIICgRSRUNWEAJCBwoFdmFsdWUapgEKBExp",
            "bmsSLAoIdHJhY2VfaWQYASABKAsyGi5nb29nbGUudHJhY2luZy52MS5UcmFj",
            "ZUlkEg8KB3NwYW5faWQYAiABKAYSLwoEdHlwZRgDIAEoDjIhLmdvb2dsZS50",
            "cmFjaW5nLnYxLlNwYW4uTGluay5UeXBlIi4KBFR5cGUSDwoLVU5TUEVDSUZJ",
            "RUQQABIJCgVDSElMRBABEgoKBlBBUkVOVBACGkwKC0xhYmVsc0VudHJ5EgsK",
            "A2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLmdvb2dsZS50cmFjaW5nLnYx",
            "LkxhYmVsVmFsdWU6AjgBIl0KBVRyYWNlEiwKCHRyYWNlX2lkGAEgASgLMhou",
            "Z29vZ2xlLnRyYWNpbmcudjEuVHJhY2VJZBImCgVzcGFucxgCIAMoCzIXLmdv",
            "b2dsZS50cmFjaW5nLnYxLlNwYW5CXwoVY29tLmdvb2dsZS50cmFjaW5nLnYx",
            "QgpUcmFjZVByb3RvUAFaOGdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dv",
            "b2dsZWFwaXMvdHJhY2luZy92MTt0cmFjaW5nYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Rpc.StatusReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.TraceId), global::Google.Tracing.V1.TraceId.Parser, new[]{ "HexEncoded" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Module), global::Google.Tracing.V1.Module.Parser, new[]{ "Module_", "BuildId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.StackTrace), global::Google.Tracing.V1.StackTrace.Parser, new[]{ "StackFrame", "StackTraceHashId" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.StackTrace.Types.StackFrame), global::Google.Tracing.V1.StackTrace.Types.StackFrame.Parser, new[]{ "FunctionName", "OrigFunctionName", "FileName", "LineNumber", "ColumnNumber", "LoadModule", "SourceVersion" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.LabelValue), global::Google.Tracing.V1.LabelValue.Parser, new[]{ "StringValue", "IntValue", "BoolValue" }, new[]{ "Value" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Span), global::Google.Tracing.V1.Span.Parser, new[]{ "Id", "Name", "ParentId", "LocalStartTime", "LocalEndTime", "Labels", "StackTrace", "TimeEvents", "Links", "Status", "HasRemoteParent" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Span.Types.TimeEvent), global::Google.Tracing.V1.Span.Types.TimeEvent.Parser, new[]{ "LocalTime", "Annotation", "NetworkEvent" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation), global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation.Parser, new[]{ "Description", "Labels" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent), global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent.Parser, new[]{ "KernelTime", "Type", "MessageId", "MessageSize" }, null, new[]{ typeof(global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent.Types.Type) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Span.Types.Link), global::Google.Tracing.V1.Span.Types.Link.Parser, new[]{ "TraceId", "SpanId", "Type" }, null, new[]{ typeof(global::Google.Tracing.V1.Span.Types.Link.Types.Type) }, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Tracing.V1.Trace), global::Google.Tracing.V1.Trace.Parser, new[]{ "TraceId", "Spans" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  A TraceId uniquely identifies a Trace. It is conceptually a 128-bit value,
  ///  represented as a string, containing the hex-encoded value.
  /// </summary>
  public sealed partial class TraceId : pb::IMessage<TraceId> {
    private static readonly pb::MessageParser<TraceId> _parser = new pb::MessageParser<TraceId>(() => new TraceId());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TraceId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceId(TraceId other) : this() {
      hexEncoded_ = other.hexEncoded_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceId Clone() {
      return new TraceId(this);
    }

    /// <summary>Field number for the "hex_encoded" field.</summary>
    public const int HexEncodedFieldNumber = 1;
    private string hexEncoded_ = "";
    /// <summary>
    ///  Trace ID specified as a hex-encoded string. *Must* be 32 bytes long.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HexEncoded {
      get { return hexEncoded_; }
      set {
        hexEncoded_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TraceId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TraceId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HexEncoded != other.HexEncoded) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HexEncoded.Length != 0) hash ^= HexEncoded.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HexEncoded.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(HexEncoded);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HexEncoded.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HexEncoded);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TraceId other) {
      if (other == null) {
        return;
      }
      if (other.HexEncoded.Length != 0) {
        HexEncoded = other.HexEncoded;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            HexEncoded = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Module : pb::IMessage<Module> {
    private static readonly pb::MessageParser<Module> _parser = new pb::MessageParser<Module>(() => new Module());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Module> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Module() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Module(Module other) : this() {
      module_ = other.module_;
      buildId_ = other.buildId_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Module Clone() {
      return new Module(this);
    }

    /// <summary>Field number for the "module" field.</summary>
    public const int Module_FieldNumber = 1;
    private string module_ = "";
    /// <summary>
    ///  Binary module.
    ///  E.g. main binary, kernel modules, and dynamic libraries
    ///  such as libc.so, sharedlib.so
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Module_ {
      get { return module_; }
      set {
        module_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "build_id" field.</summary>
    public const int BuildIdFieldNumber = 2;
    private string buildId_ = "";
    /// <summary>
    ///  Build_id is a unique identifier for the module,
    ///  probably a hash of its contents
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BuildId {
      get { return buildId_; }
      set {
        buildId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Module);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Module other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Module_ != other.Module_) return false;
      if (BuildId != other.BuildId) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Module_.Length != 0) hash ^= Module_.GetHashCode();
      if (BuildId.Length != 0) hash ^= BuildId.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Module_.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Module_);
      }
      if (BuildId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(BuildId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Module_.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Module_);
      }
      if (BuildId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BuildId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Module other) {
      if (other == null) {
        return;
      }
      if (other.Module_.Length != 0) {
        Module_ = other.Module_;
      }
      if (other.BuildId.Length != 0) {
        BuildId = other.BuildId;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Module_ = input.ReadString();
            break;
          }
          case 18: {
            BuildId = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class StackTrace : pb::IMessage<StackTrace> {
    private static readonly pb::MessageParser<StackTrace> _parser = new pb::MessageParser<StackTrace>(() => new StackTrace());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StackTrace> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StackTrace() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StackTrace(StackTrace other) : this() {
      stackFrame_ = other.stackFrame_.Clone();
      stackTraceHashId_ = other.stackTraceHashId_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StackTrace Clone() {
      return new StackTrace(this);
    }

    /// <summary>Field number for the "stack_frame" field.</summary>
    public const int StackFrameFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Tracing.V1.StackTrace.Types.StackFrame> _repeated_stackFrame_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Tracing.V1.StackTrace.Types.StackFrame.Parser);
    private readonly pbc::RepeatedField<global::Google.Tracing.V1.StackTrace.Types.StackFrame> stackFrame_ = new pbc::RepeatedField<global::Google.Tracing.V1.StackTrace.Types.StackFrame>();
    /// <summary>
    ///  Stack frames of this stack trace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Tracing.V1.StackTrace.Types.StackFrame> StackFrame {
      get { return stackFrame_; }
    }

    /// <summary>Field number for the "stack_trace_hash_id" field.</summary>
    public const int StackTraceHashIdFieldNumber = 2;
    private ulong stackTraceHashId_;
    /// <summary>
    ///  User can choose to use his own hash function to hash large labels to save
    ///  network bandwidth and storage.
    ///  Typical usage is to pass both initially to inform the storage of the
    ///  mapping. And in subsequent calls, pass in stack_trace_hash_id only.
    ///  User shall verify the hash value is successfully stored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong StackTraceHashId {
      get { return stackTraceHashId_; }
      set {
        stackTraceHashId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StackTrace);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StackTrace other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!stackFrame_.Equals(other.stackFrame_)) return false;
      if (StackTraceHashId != other.StackTraceHashId) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= stackFrame_.GetHashCode();
      if (StackTraceHashId != 0UL) hash ^= StackTraceHashId.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      stackFrame_.WriteTo(output, _repeated_stackFrame_codec);
      if (StackTraceHashId != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(StackTraceHashId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += stackFrame_.CalculateSize(_repeated_stackFrame_codec);
      if (StackTraceHashId != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(StackTraceHashId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StackTrace other) {
      if (other == null) {
        return;
      }
      stackFrame_.Add(other.stackFrame_);
      if (other.StackTraceHashId != 0UL) {
        StackTraceHashId = other.StackTraceHashId;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            stackFrame_.AddEntriesFrom(input, _repeated_stackFrame_codec);
            break;
          }
          case 16: {
            StackTraceHashId = input.ReadUInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the StackTrace message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  Presents a single stack frame in a stack trace.
      /// </summary>
      public sealed partial class StackFrame : pb::IMessage<StackFrame> {
        private static readonly pb::MessageParser<StackFrame> _parser = new pb::MessageParser<StackFrame>(() => new StackFrame());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<StackFrame> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Tracing.V1.StackTrace.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StackFrame() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StackFrame(StackFrame other) : this() {
          functionName_ = other.functionName_;
          origFunctionName_ = other.origFunctionName_;
          fileName_ = other.fileName_;
          lineNumber_ = other.lineNumber_;
          columnNumber_ = other.columnNumber_;
          LoadModule = other.loadModule_ != null ? other.LoadModule.Clone() : null;
          sourceVersion_ = other.sourceVersion_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public StackFrame Clone() {
          return new StackFrame(this);
        }

        /// <summary>Field number for the "function_name" field.</summary>
        public const int FunctionNameFieldNumber = 1;
        private string functionName_ = "";
        /// <summary>
        ///  Fully qualified names which uniquely identify function/method/etc.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FunctionName {
          get { return functionName_; }
          set {
            functionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "orig_function_name" field.</summary>
        public const int OrigFunctionNameFieldNumber = 2;
        private string origFunctionName_ = "";
        /// <summary>
        ///  Used when function name is ‘mangled’. Not guaranteed to be fully
        ///  qualified but usually it is.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string OrigFunctionName {
          get { return origFunctionName_; }
          set {
            origFunctionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "file_name" field.</summary>
        public const int FileNameFieldNumber = 3;
        private string fileName_ = "";
        /// <summary>
        ///  File name of the frame.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FileName {
          get { return fileName_; }
          set {
            fileName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "line_number" field.</summary>
        public const int LineNumberFieldNumber = 4;
        private long lineNumber_;
        /// <summary>
        ///  Line number of the frame.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long LineNumber {
          get { return lineNumber_; }
          set {
            lineNumber_ = value;
          }
        }

        /// <summary>Field number for the "column_number" field.</summary>
        public const int ColumnNumberFieldNumber = 5;
        private long columnNumber_;
        /// <summary>
        ///  Column number is important in JavaScript(anonymous functions),
        ///  Might not be available in some languages.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long ColumnNumber {
          get { return columnNumber_; }
          set {
            columnNumber_ = value;
          }
        }

        /// <summary>Field number for the "load_module" field.</summary>
        public const int LoadModuleFieldNumber = 6;
        private global::Google.Tracing.V1.Module loadModule_;
        /// <summary>
        ///  Binary module the code is loaded from.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Tracing.V1.Module LoadModule {
          get { return loadModule_; }
          set {
            loadModule_ = value;
          }
        }

        /// <summary>Field number for the "source_version" field.</summary>
        public const int SourceVersionFieldNumber = 7;
        private string sourceVersion_ = "";
        /// <summary>
        ///  source_version is deployment specific. It might be
        ///  better to be stored in deployment metadata.
        ///  However, in distributed tracing, it’s hard to keep track of
        ///  source/binary versions at one place for all spans.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string SourceVersion {
          get { return sourceVersion_; }
          set {
            sourceVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as StackFrame);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(StackFrame other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FunctionName != other.FunctionName) return false;
          if (OrigFunctionName != other.OrigFunctionName) return false;
          if (FileName != other.FileName) return false;
          if (LineNumber != other.LineNumber) return false;
          if (ColumnNumber != other.ColumnNumber) return false;
          if (!object.Equals(LoadModule, other.LoadModule)) return false;
          if (SourceVersion != other.SourceVersion) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FunctionName.Length != 0) hash ^= FunctionName.GetHashCode();
          if (OrigFunctionName.Length != 0) hash ^= OrigFunctionName.GetHashCode();
          if (FileName.Length != 0) hash ^= FileName.GetHashCode();
          if (LineNumber != 0L) hash ^= LineNumber.GetHashCode();
          if (ColumnNumber != 0L) hash ^= ColumnNumber.GetHashCode();
          if (loadModule_ != null) hash ^= LoadModule.GetHashCode();
          if (SourceVersion.Length != 0) hash ^= SourceVersion.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FunctionName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FunctionName);
          }
          if (OrigFunctionName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(OrigFunctionName);
          }
          if (FileName.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(FileName);
          }
          if (LineNumber != 0L) {
            output.WriteRawTag(32);
            output.WriteInt64(LineNumber);
          }
          if (ColumnNumber != 0L) {
            output.WriteRawTag(40);
            output.WriteInt64(ColumnNumber);
          }
          if (loadModule_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(LoadModule);
          }
          if (SourceVersion.Length != 0) {
            output.WriteRawTag(58);
            output.WriteString(SourceVersion);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FunctionName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FunctionName);
          }
          if (OrigFunctionName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(OrigFunctionName);
          }
          if (FileName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FileName);
          }
          if (LineNumber != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(LineNumber);
          }
          if (ColumnNumber != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(ColumnNumber);
          }
          if (loadModule_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LoadModule);
          }
          if (SourceVersion.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(SourceVersion);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(StackFrame other) {
          if (other == null) {
            return;
          }
          if (other.FunctionName.Length != 0) {
            FunctionName = other.FunctionName;
          }
          if (other.OrigFunctionName.Length != 0) {
            OrigFunctionName = other.OrigFunctionName;
          }
          if (other.FileName.Length != 0) {
            FileName = other.FileName;
          }
          if (other.LineNumber != 0L) {
            LineNumber = other.LineNumber;
          }
          if (other.ColumnNumber != 0L) {
            ColumnNumber = other.ColumnNumber;
          }
          if (other.loadModule_ != null) {
            if (loadModule_ == null) {
              loadModule_ = new global::Google.Tracing.V1.Module();
            }
            LoadModule.MergeFrom(other.LoadModule);
          }
          if (other.SourceVersion.Length != 0) {
            SourceVersion = other.SourceVersion;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                FunctionName = input.ReadString();
                break;
              }
              case 18: {
                OrigFunctionName = input.ReadString();
                break;
              }
              case 26: {
                FileName = input.ReadString();
                break;
              }
              case 32: {
                LineNumber = input.ReadInt64();
                break;
              }
              case 40: {
                ColumnNumber = input.ReadInt64();
                break;
              }
              case 50: {
                if (loadModule_ == null) {
                  loadModule_ = new global::Google.Tracing.V1.Module();
                }
                input.ReadMessage(loadModule_);
                break;
              }
              case 58: {
                SourceVersion = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Allowed label values.
  /// </summary>
  public sealed partial class LabelValue : pb::IMessage<LabelValue> {
    private static readonly pb::MessageParser<LabelValue> _parser = new pb::MessageParser<LabelValue>(() => new LabelValue());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LabelValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LabelValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LabelValue(LabelValue other) : this() {
      switch (other.ValueCase) {
        case ValueOneofCase.StringValue:
          StringValue = other.StringValue;
          break;
        case ValueOneofCase.IntValue:
          IntValue = other.IntValue;
          break;
        case ValueOneofCase.BoolValue:
          BoolValue = other.BoolValue;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LabelValue Clone() {
      return new LabelValue(this);
    }

    /// <summary>Field number for the "string_value" field.</summary>
    public const int StringValueFieldNumber = 1;
    /// <summary>
    ///  A string value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StringValue {
      get { return valueCase_ == ValueOneofCase.StringValue ? (string) value_ : ""; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        valueCase_ = ValueOneofCase.StringValue;
      }
    }

    /// <summary>Field number for the "int_value" field.</summary>
    public const int IntValueFieldNumber = 2;
    /// <summary>
    ///  An integer value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IntValue {
      get { return valueCase_ == ValueOneofCase.IntValue ? (long) value_ : 0L; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.IntValue;
      }
    }

    /// <summary>Field number for the "bool_value" field.</summary>
    public const int BoolValueFieldNumber = 3;
    /// <summary>
    ///  A boolean value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BoolValue {
      get { return valueCase_ == ValueOneofCase.BoolValue ? (bool) value_ : false; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.BoolValue;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      StringValue = 1,
      IntValue = 2,
      BoolValue = 3,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LabelValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LabelValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StringValue != other.StringValue) return false;
      if (IntValue != other.IntValue) return false;
      if (BoolValue != other.BoolValue) return false;
      if (ValueCase != other.ValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.StringValue) hash ^= StringValue.GetHashCode();
      if (valueCase_ == ValueOneofCase.IntValue) hash ^= IntValue.GetHashCode();
      if (valueCase_ == ValueOneofCase.BoolValue) hash ^= BoolValue.GetHashCode();
      hash ^= (int) valueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.StringValue) {
        output.WriteRawTag(10);
        output.WriteString(StringValue);
      }
      if (valueCase_ == ValueOneofCase.IntValue) {
        output.WriteRawTag(16);
        output.WriteInt64(IntValue);
      }
      if (valueCase_ == ValueOneofCase.BoolValue) {
        output.WriteRawTag(24);
        output.WriteBool(BoolValue);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.StringValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StringValue);
      }
      if (valueCase_ == ValueOneofCase.IntValue) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntValue);
      }
      if (valueCase_ == ValueOneofCase.BoolValue) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LabelValue other) {
      if (other == null) {
        return;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.StringValue:
          StringValue = other.StringValue;
          break;
        case ValueOneofCase.IntValue:
          IntValue = other.IntValue;
          break;
        case ValueOneofCase.BoolValue:
          BoolValue = other.BoolValue;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            StringValue = input.ReadString();
            break;
          }
          case 16: {
            IntValue = input.ReadInt64();
            break;
          }
          case 24: {
            BoolValue = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A span represents a single operation within a trace. Spans can be nested
  ///  and form a trace tree. Often, a trace contains a root span that describes the
  ///  end-to-end latency and, optionally, one or more subspans for
  ///  its sub-operations. Spans do not need to be contiguous. There may be gaps
  ///  between spans in a trace.
  /// </summary>
  public sealed partial class Span : pb::IMessage<Span> {
    private static readonly pb::MessageParser<Span> _parser = new pb::MessageParser<Span>(() => new Span());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Span> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span(Span other) : this() {
      id_ = other.id_;
      name_ = other.name_;
      parentId_ = other.parentId_;
      LocalStartTime = other.localStartTime_ != null ? other.LocalStartTime.Clone() : null;
      LocalEndTime = other.localEndTime_ != null ? other.LocalEndTime.Clone() : null;
      labels_ = other.labels_.Clone();
      StackTrace = other.stackTrace_ != null ? other.StackTrace.Clone() : null;
      timeEvents_ = other.timeEvents_.Clone();
      links_ = other.links_.Clone();
      Status = other.status_ != null ? other.Status.Clone() : null;
      hasRemoteParent_ = other.hasRemoteParent_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span Clone() {
      return new Span(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private ulong id_;
    /// <summary>
    ///  Identifier for the span. Must be a 64-bit integer other than 0 and
    ///  unique within a trace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    ///  Name of the span. The span name is sanitized and displayed in the
    ///  Stackdriver Trace tool in the {% dynamic print site_values.console_name %}.
    ///  The name may be a method name or some other per-call site name.
    ///  For the same executable and the same call point, a best practice is
    ///  to use a consistent name, which makes it easier to correlate
    ///  cross-trace spans.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "parent_id" field.</summary>
    public const int ParentIdFieldNumber = 3;
    private ulong parentId_;
    /// <summary>
    ///  ID of parent span. 0 or missing if this is a root span.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ParentId {
      get { return parentId_; }
      set {
        parentId_ = value;
      }
    }

    /// <summary>Field number for the "local_start_time" field.</summary>
    public const int LocalStartTimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp localStartTime_;
    /// <summary>
    ///  Local machine clock in nanoseconds from the UNIX epoch,
    ///  at which span execution started.
    ///  On the server side these are the times when the server application
    ///  handler starts running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp LocalStartTime {
      get { return localStartTime_; }
      set {
        localStartTime_ = value;
      }
    }

    /// <summary>Field number for the "local_end_time" field.</summary>
    public const int LocalEndTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp localEndTime_;
    /// <summary>
    ///  Local machine clock in nanoseconds from the UNIX epoch,
    ///  at which span execution ended.
    ///  On the server side these are the times when the server application
    ///  handler finishes running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp LocalEndTime {
      get { return localEndTime_; }
      set {
        localEndTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 6;
    private static readonly pbc::MapField<string, global::Google.Tracing.V1.LabelValue>.Codec _map_labels_codec
        = new pbc::MapField<string, global::Google.Tracing.V1.LabelValue>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Tracing.V1.LabelValue.Parser), 50);
    private readonly pbc::MapField<string, global::Google.Tracing.V1.LabelValue> labels_ = new pbc::MapField<string, global::Google.Tracing.V1.LabelValue>();
    /// <summary>
    ///  Properties of a span. Labels at the span level.
    ///  E.g.
    ///  "/instance_id": "my-instance"
    ///  "/zone": "us-central1-a"
    ///  "/grpc/peer_address": "ip:port" (dns, etc.)
    ///  "/grpc/deadline": "Duration"
    ///  "/http/user_agent"
    ///  "/http/request_bytes": 300
    ///  "/http/response_bytes": 1200
    ///  "/http/url": google.com/apis
    ///  "/pid"
    ///  "abc.com/mylabel": "my label value"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Tracing.V1.LabelValue> Labels {
      get { return labels_; }
    }

    /// <summary>Field number for the "stack_trace" field.</summary>
    public const int StackTraceFieldNumber = 7;
    private global::Google.Tracing.V1.StackTrace stackTrace_;
    /// <summary>
    ///  Stack trace captured at the start of the span. This is optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Tracing.V1.StackTrace StackTrace {
      get { return stackTrace_; }
      set {
        stackTrace_ = value;
      }
    }

    /// <summary>Field number for the "time_events" field.</summary>
    public const int TimeEventsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Tracing.V1.Span.Types.TimeEvent> _repeated_timeEvents_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Tracing.V1.Span.Types.TimeEvent.Parser);
    private readonly pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.TimeEvent> timeEvents_ = new pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.TimeEvent>();
    /// <summary>
    ///  A collection of time-stamped events.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.TimeEvent> TimeEvents {
      get { return timeEvents_; }
    }

    /// <summary>Field number for the "links" field.</summary>
    public const int LinksFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Tracing.V1.Span.Types.Link> _repeated_links_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Tracing.V1.Span.Types.Link.Parser);
    private readonly pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.Link> links_ = new pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.Link>();
    /// <summary>
    ///  A collection of links.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Tracing.V1.Span.Types.Link> Links {
      get { return links_; }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 10;
    private global::Google.Rpc.Status status_;
    /// <summary>
    ///  The final status of the Span. This is optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Rpc.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "has_remote_parent" field.</summary>
    public const int HasRemoteParentFieldNumber = 11;
    private bool hasRemoteParent_;
    /// <summary>
    ///  True if this Span has a remote parent (is an RPC server Span).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRemoteParent {
      get { return hasRemoteParent_; }
      set {
        hasRemoteParent_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Span);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Span other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Name != other.Name) return false;
      if (ParentId != other.ParentId) return false;
      if (!object.Equals(LocalStartTime, other.LocalStartTime)) return false;
      if (!object.Equals(LocalEndTime, other.LocalEndTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      if (!object.Equals(StackTrace, other.StackTrace)) return false;
      if(!timeEvents_.Equals(other.timeEvents_)) return false;
      if(!links_.Equals(other.links_)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      if (HasRemoteParent != other.HasRemoteParent) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0UL) hash ^= Id.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (ParentId != 0UL) hash ^= ParentId.GetHashCode();
      if (localStartTime_ != null) hash ^= LocalStartTime.GetHashCode();
      if (localEndTime_ != null) hash ^= LocalEndTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (stackTrace_ != null) hash ^= StackTrace.GetHashCode();
      hash ^= timeEvents_.GetHashCode();
      hash ^= links_.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (HasRemoteParent != false) hash ^= HasRemoteParent.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0UL) {
        output.WriteRawTag(9);
        output.WriteFixed64(Id);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (ParentId != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(ParentId);
      }
      if (localStartTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LocalStartTime);
      }
      if (localEndTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LocalEndTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (stackTrace_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StackTrace);
      }
      timeEvents_.WriteTo(output, _repeated_timeEvents_codec);
      links_.WriteTo(output, _repeated_links_codec);
      if (status_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Status);
      }
      if (HasRemoteParent != false) {
        output.WriteRawTag(88);
        output.WriteBool(HasRemoteParent);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0UL) {
        size += 1 + 8;
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (ParentId != 0UL) {
        size += 1 + 8;
      }
      if (localStartTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalStartTime);
      }
      if (localEndTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalEndTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (stackTrace_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StackTrace);
      }
      size += timeEvents_.CalculateSize(_repeated_timeEvents_codec);
      size += links_.CalculateSize(_repeated_links_codec);
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (HasRemoteParent != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Span other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0UL) {
        Id = other.Id;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.ParentId != 0UL) {
        ParentId = other.ParentId;
      }
      if (other.localStartTime_ != null) {
        if (localStartTime_ == null) {
          localStartTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        LocalStartTime.MergeFrom(other.LocalStartTime);
      }
      if (other.localEndTime_ != null) {
        if (localEndTime_ == null) {
          localEndTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        LocalEndTime.MergeFrom(other.LocalEndTime);
      }
      labels_.Add(other.labels_);
      if (other.stackTrace_ != null) {
        if (stackTrace_ == null) {
          stackTrace_ = new global::Google.Tracing.V1.StackTrace();
        }
        StackTrace.MergeFrom(other.StackTrace);
      }
      timeEvents_.Add(other.timeEvents_);
      links_.Add(other.links_);
      if (other.status_ != null) {
        if (status_ == null) {
          status_ = new global::Google.Rpc.Status();
        }
        Status.MergeFrom(other.Status);
      }
      if (other.HasRemoteParent != false) {
        HasRemoteParent = other.HasRemoteParent;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            Id = input.ReadFixed64();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 25: {
            ParentId = input.ReadFixed64();
            break;
          }
          case 34: {
            if (localStartTime_ == null) {
              localStartTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(localStartTime_);
            break;
          }
          case 42: {
            if (localEndTime_ == null) {
              localEndTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(localEndTime_);
            break;
          }
          case 50: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
          case 58: {
            if (stackTrace_ == null) {
              stackTrace_ = new global::Google.Tracing.V1.StackTrace();
            }
            input.ReadMessage(stackTrace_);
            break;
          }
          case 66: {
            timeEvents_.AddEntriesFrom(input, _repeated_timeEvents_codec);
            break;
          }
          case 74: {
            links_.AddEntriesFrom(input, _repeated_links_codec);
            break;
          }
          case 82: {
            if (status_ == null) {
              status_ = new global::Google.Rpc.Status();
            }
            input.ReadMessage(status_);
            break;
          }
          case 88: {
            HasRemoteParent = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Span message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  A time-stamped annotation in the Span.
      /// </summary>
      public sealed partial class TimeEvent : pb::IMessage<TimeEvent> {
        private static readonly pb::MessageParser<TimeEvent> _parser = new pb::MessageParser<TimeEvent>(() => new TimeEvent());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TimeEvent> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Tracing.V1.Span.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeEvent() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeEvent(TimeEvent other) : this() {
          LocalTime = other.localTime_ != null ? other.LocalTime.Clone() : null;
          switch (other.ValueCase) {
            case ValueOneofCase.Annotation:
              Annotation = other.Annotation.Clone();
              break;
            case ValueOneofCase.NetworkEvent:
              NetworkEvent = other.NetworkEvent.Clone();
              break;
          }

        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeEvent Clone() {
          return new TimeEvent(this);
        }

        /// <summary>Field number for the "local_time" field.</summary>
        public const int LocalTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp localTime_;
        /// <summary>
        ///  The local machine absolute timestamp when this event happened.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp LocalTime {
          get { return localTime_; }
          set {
            localTime_ = value;
          }
        }

        /// <summary>Field number for the "annotation" field.</summary>
        public const int AnnotationFieldNumber = 2;
        /// <summary>
        ///  Optional field for user supplied &lt;string, LabelValue> map
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation Annotation {
          get { return valueCase_ == ValueOneofCase.Annotation ? (global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation) value_ : null; }
          set {
            value_ = value;
            valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Annotation;
          }
        }

        /// <summary>Field number for the "network_event" field.</summary>
        public const int NetworkEventFieldNumber = 3;
        /// <summary>
        ///  Optional field that can be used only for network events.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent NetworkEvent {
          get { return valueCase_ == ValueOneofCase.NetworkEvent ? (global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent) value_ : null; }
          set {
            value_ = value;
            valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.NetworkEvent;
          }
        }

        private object value_;
        /// <summary>Enum of possible cases for the "value" oneof.</summary>
        public enum ValueOneofCase {
          None = 0,
          Annotation = 2,
          NetworkEvent = 3,
        }
        private ValueOneofCase valueCase_ = ValueOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValueOneofCase ValueCase {
          get { return valueCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearValue() {
          valueCase_ = ValueOneofCase.None;
          value_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TimeEvent);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TimeEvent other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(LocalTime, other.LocalTime)) return false;
          if (!object.Equals(Annotation, other.Annotation)) return false;
          if (!object.Equals(NetworkEvent, other.NetworkEvent)) return false;
          if (ValueCase != other.ValueCase) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (localTime_ != null) hash ^= LocalTime.GetHashCode();
          if (valueCase_ == ValueOneofCase.Annotation) hash ^= Annotation.GetHashCode();
          if (valueCase_ == ValueOneofCase.NetworkEvent) hash ^= NetworkEvent.GetHashCode();
          hash ^= (int) valueCase_;
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (localTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(LocalTime);
          }
          if (valueCase_ == ValueOneofCase.Annotation) {
            output.WriteRawTag(18);
            output.WriteMessage(Annotation);
          }
          if (valueCase_ == ValueOneofCase.NetworkEvent) {
            output.WriteRawTag(26);
            output.WriteMessage(NetworkEvent);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (localTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalTime);
          }
          if (valueCase_ == ValueOneofCase.Annotation) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Annotation);
          }
          if (valueCase_ == ValueOneofCase.NetworkEvent) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(NetworkEvent);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TimeEvent other) {
          if (other == null) {
            return;
          }
          if (other.localTime_ != null) {
            if (localTime_ == null) {
              localTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            LocalTime.MergeFrom(other.LocalTime);
          }
          switch (other.ValueCase) {
            case ValueOneofCase.Annotation:
              Annotation = other.Annotation;
              break;
            case ValueOneofCase.NetworkEvent:
              NetworkEvent = other.NetworkEvent;
              break;
          }

        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (localTime_ == null) {
                  localTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(localTime_);
                break;
              }
              case 18: {
                global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation subBuilder = new global::Google.Tracing.V1.Span.Types.TimeEvent.Types.Annotation();
                if (valueCase_ == ValueOneofCase.Annotation) {
                  subBuilder.MergeFrom(Annotation);
                }
                input.ReadMessage(subBuilder);
                Annotation = subBuilder;
                break;
              }
              case 26: {
                global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent subBuilder = new global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent();
                if (valueCase_ == ValueOneofCase.NetworkEvent) {
                  subBuilder.MergeFrom(NetworkEvent);
                }
                input.ReadMessage(subBuilder);
                NetworkEvent = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the TimeEvent message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///  Text annotation with a set of labels.
          /// </summary>
          public sealed partial class Annotation : pb::IMessage<Annotation> {
            private static readonly pb::MessageParser<Annotation> _parser = new pb::MessageParser<Annotation>(() => new Annotation());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Annotation> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Tracing.V1.Span.Types.TimeEvent.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Annotation() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Annotation(Annotation other) : this() {
              description_ = other.description_;
              labels_ = other.labels_.Clone();
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Annotation Clone() {
              return new Annotation(this);
            }

            /// <summary>Field number for the "description" field.</summary>
            public const int DescriptionFieldNumber = 1;
            private string description_ = "";
            /// <summary>
            ///  A user-supplied message describing the event.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Description {
              get { return description_; }
              set {
                description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "labels" field.</summary>
            public const int LabelsFieldNumber = 2;
            private static readonly pbc::MapField<string, global::Google.Tracing.V1.LabelValue>.Codec _map_labels_codec
                = new pbc::MapField<string, global::Google.Tracing.V1.LabelValue>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Tracing.V1.LabelValue.Parser), 18);
            private readonly pbc::MapField<string, global::Google.Tracing.V1.LabelValue> labels_ = new pbc::MapField<string, global::Google.Tracing.V1.LabelValue>();
            /// <summary>
            ///  A set of labels on the annotation.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::MapField<string, global::Google.Tracing.V1.LabelValue> Labels {
              get { return labels_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Annotation);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Annotation other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Description != other.Description) return false;
              if (!Labels.Equals(other.Labels)) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Description.Length != 0) hash ^= Description.GetHashCode();
              hash ^= Labels.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Description.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Description);
              }
              labels_.WriteTo(output, _map_labels_codec);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Description.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
              }
              size += labels_.CalculateSize(_map_labels_codec);
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Annotation other) {
              if (other == null) {
                return;
              }
              if (other.Description.Length != 0) {
                Description = other.Description;
              }
              labels_.Add(other.labels_);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    Description = input.ReadString();
                    break;
                  }
                  case 18: {
                    labels_.AddEntriesFrom(input, _map_labels_codec);
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          ///  An event describing an RPC message sent/received on the network.
          /// </summary>
          public sealed partial class NetworkEvent : pb::IMessage<NetworkEvent> {
            private static readonly pb::MessageParser<NetworkEvent> _parser = new pb::MessageParser<NetworkEvent>(() => new NetworkEvent());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<NetworkEvent> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Tracing.V1.Span.Types.TimeEvent.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public NetworkEvent() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public NetworkEvent(NetworkEvent other) : this() {
              KernelTime = other.kernelTime_ != null ? other.KernelTime.Clone() : null;
              type_ = other.type_;
              messageId_ = other.messageId_;
              messageSize_ = other.messageSize_;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public NetworkEvent Clone() {
              return new NetworkEvent(this);
            }

            /// <summary>Field number for the "kernel_time" field.</summary>
            public const int KernelTimeFieldNumber = 1;
            private global::Google.Protobuf.WellKnownTypes.Timestamp kernelTime_;
            /// <summary>
            ///  If available, this is the kernel time:
            ///  For sent messages, this is the time at which the first bit was sent.
            ///  For received messages, this is the time at which the last bit was
            ///  received.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Protobuf.WellKnownTypes.Timestamp KernelTime {
              get { return kernelTime_; }
              set {
                kernelTime_ = value;
              }
            }

            /// <summary>Field number for the "type" field.</summary>
            public const int TypeFieldNumber = 2;
            private global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent.Types.Type type_ = 0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent.Types.Type Type {
              get { return type_; }
              set {
                type_ = value;
              }
            }

            /// <summary>Field number for the "message_id" field.</summary>
            public const int MessageIdFieldNumber = 3;
            private ulong messageId_;
            /// <summary>
            ///  Every message has an identifier, that must be different from all the
            ///  network messages in this span.
            ///  This is very important when the request/response are streamed.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ulong MessageId {
              get { return messageId_; }
              set {
                messageId_ = value;
              }
            }

            /// <summary>Field number for the "message_size" field.</summary>
            public const int MessageSizeFieldNumber = 4;
            private ulong messageSize_;
            /// <summary>
            ///  Number of bytes send/receive.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ulong MessageSize {
              get { return messageSize_; }
              set {
                messageSize_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as NetworkEvent);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(NetworkEvent other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(KernelTime, other.KernelTime)) return false;
              if (Type != other.Type) return false;
              if (MessageId != other.MessageId) return false;
              if (MessageSize != other.MessageSize) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (kernelTime_ != null) hash ^= KernelTime.GetHashCode();
              if (Type != 0) hash ^= Type.GetHashCode();
              if (MessageId != 0UL) hash ^= MessageId.GetHashCode();
              if (MessageSize != 0UL) hash ^= MessageSize.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (kernelTime_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(KernelTime);
              }
              if (Type != 0) {
                output.WriteRawTag(16);
                output.WriteEnum((int) Type);
              }
              if (MessageId != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(MessageId);
              }
              if (MessageSize != 0UL) {
                output.WriteRawTag(32);
                output.WriteUInt64(MessageSize);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (kernelTime_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(KernelTime);
              }
              if (Type != 0) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
              }
              if (MessageId != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MessageId);
              }
              if (MessageSize != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MessageSize);
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(NetworkEvent other) {
              if (other == null) {
                return;
              }
              if (other.kernelTime_ != null) {
                if (kernelTime_ == null) {
                  kernelTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                KernelTime.MergeFrom(other.KernelTime);
              }
              if (other.Type != 0) {
                Type = other.Type;
              }
              if (other.MessageId != 0UL) {
                MessageId = other.MessageId;
              }
              if (other.MessageSize != 0UL) {
                MessageSize = other.MessageSize;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    if (kernelTime_ == null) {
                      kernelTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                    }
                    input.ReadMessage(kernelTime_);
                    break;
                  }
                  case 16: {
                    type_ = (global::Google.Tracing.V1.Span.Types.TimeEvent.Types.NetworkEvent.Types.Type) input.ReadEnum();
                    break;
                  }
                  case 24: {
                    MessageId = input.ReadUInt64();
                    break;
                  }
                  case 32: {
                    MessageSize = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

            #region Nested types
            /// <summary>Container for nested types declared in the NetworkEvent message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              ///  The type of the network event. SENT or RECV event.
              /// </summary>
              public enum Type {
                [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
                [pbr::OriginalName("SENT")] Sent = 1,
                [pbr::OriginalName("RECV")] Recv = 2,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      ///  Link one span with another which may be in a different Trace. Used (for
      ///  example) in batching operations, where a single batch handler processes
      ///  multiple requests from different traces.
      /// </summary>
      public sealed partial class Link : pb::IMessage<Link> {
        private static readonly pb::MessageParser<Link> _parser = new pb::MessageParser<Link>(() => new Link());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Link> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Tracing.V1.Span.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link(Link other) : this() {
          TraceId = other.traceId_ != null ? other.TraceId.Clone() : null;
          spanId_ = other.spanId_;
          type_ = other.type_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link Clone() {
          return new Link(this);
        }

        /// <summary>Field number for the "trace_id" field.</summary>
        public const int TraceIdFieldNumber = 1;
        private global::Google.Tracing.V1.TraceId traceId_;
        /// <summary>
        ///  The trace and span identifier of the linked span.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Tracing.V1.TraceId TraceId {
          get { return traceId_; }
          set {
            traceId_ = value;
          }
        }

        /// <summary>Field number for the "span_id" field.</summary>
        public const int SpanIdFieldNumber = 2;
        private ulong spanId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong SpanId {
          get { return spanId_; }
          set {
            spanId_ = value;
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 3;
        private global::Google.Tracing.V1.Span.Types.Link.Types.Type type_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Tracing.V1.Span.Types.Link.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Link);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Link other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(TraceId, other.TraceId)) return false;
          if (SpanId != other.SpanId) return false;
          if (Type != other.Type) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (traceId_ != null) hash ^= TraceId.GetHashCode();
          if (SpanId != 0UL) hash ^= SpanId.GetHashCode();
          if (Type != 0) hash ^= Type.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (traceId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(TraceId);
          }
          if (SpanId != 0UL) {
            output.WriteRawTag(17);
            output.WriteFixed64(SpanId);
          }
          if (Type != 0) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Type);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (traceId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TraceId);
          }
          if (SpanId != 0UL) {
            size += 1 + 8;
          }
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Link other) {
          if (other == null) {
            return;
          }
          if (other.traceId_ != null) {
            if (traceId_ == null) {
              traceId_ = new global::Google.Tracing.V1.TraceId();
            }
            TraceId.MergeFrom(other.TraceId);
          }
          if (other.SpanId != 0UL) {
            SpanId = other.SpanId;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (traceId_ == null) {
                  traceId_ = new global::Google.Tracing.V1.TraceId();
                }
                input.ReadMessage(traceId_);
                break;
              }
              case 17: {
                SpanId = input.ReadFixed64();
                break;
              }
              case 24: {
                type_ = (global::Google.Tracing.V1.Span.Types.Link.Types.Type) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Link message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///  The type of the link.
          /// </summary>
          public enum Type {
            [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
            [pbr::OriginalName("CHILD")] Child = 1,
            [pbr::OriginalName("PARENT")] Parent = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///  A trace describes how long it takes for an application to perform some
  ///  operations. It consists of a tree of spans, each of which contains details
  ///  about an operation with time information and operation details.
  /// </summary>
  public sealed partial class Trace : pb::IMessage<Trace> {
    private static readonly pb::MessageParser<Trace> _parser = new pb::MessageParser<Trace>(() => new Trace());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Trace> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Tracing.V1.TraceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trace() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trace(Trace other) : this() {
      TraceId = other.traceId_ != null ? other.TraceId.Clone() : null;
      spans_ = other.spans_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Trace Clone() {
      return new Trace(this);
    }

    /// <summary>Field number for the "trace_id" field.</summary>
    public const int TraceIdFieldNumber = 1;
    private global::Google.Tracing.V1.TraceId traceId_;
    /// <summary>
    ///  Globally unique identifier for the trace. Common to all the spans.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Tracing.V1.TraceId TraceId {
      get { return traceId_; }
      set {
        traceId_ = value;
      }
    }

    /// <summary>Field number for the "spans" field.</summary>
    public const int SpansFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Tracing.V1.Span> _repeated_spans_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Tracing.V1.Span.Parser);
    private readonly pbc::RepeatedField<global::Google.Tracing.V1.Span> spans_ = new pbc::RepeatedField<global::Google.Tracing.V1.Span>();
    /// <summary>
    ///  Collection of spans in the trace. The root span has parent_id == 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Tracing.V1.Span> Spans {
      get { return spans_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Trace);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Trace other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TraceId, other.TraceId)) return false;
      if(!spans_.Equals(other.spans_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (traceId_ != null) hash ^= TraceId.GetHashCode();
      hash ^= spans_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (traceId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TraceId);
      }
      spans_.WriteTo(output, _repeated_spans_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (traceId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TraceId);
      }
      size += spans_.CalculateSize(_repeated_spans_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Trace other) {
      if (other == null) {
        return;
      }
      if (other.traceId_ != null) {
        if (traceId_ == null) {
          traceId_ = new global::Google.Tracing.V1.TraceId();
        }
        TraceId.MergeFrom(other.TraceId);
      }
      spans_.Add(other.spans_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (traceId_ == null) {
              traceId_ = new global::Google.Tracing.V1.TraceId();
            }
            input.ReadMessage(traceId_);
            break;
          }
          case 18: {
            spans_.AddEntriesFrom(input, _repeated_spans_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
