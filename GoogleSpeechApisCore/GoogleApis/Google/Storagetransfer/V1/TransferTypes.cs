// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/storagetransfer/v1/transfer_types.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Storagetransfer.V1 {

  /// <summary>Holder for reflection information generated from google/storagetransfer/v1/transfer_types.proto</summary>
  public static partial class TransferTypesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/storagetransfer/v1/transfer_types.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TransferTypesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci5nb29nbGUvc3RvcmFnZXRyYW5zZmVyL3YxL3RyYW5zZmVyX3R5cGVzLnBy",
            "b3RvEhlnb29nbGUuc3RvcmFnZXRyYW5zZmVyLnYxGhxnb29nbGUvYXBpL2Fu",
            "bm90YXRpb25zLnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJv",
            "dG8aH2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8aFWdvb2dsZS9y",
            "cGMvY29kZS5wcm90bxoWZ29vZ2xlL3R5cGUvZGF0ZS5wcm90bxobZ29vZ2xl",
            "L3R5cGUvdGltZW9mZGF5LnByb3RvIi0KFEdvb2dsZVNlcnZpY2VBY2NvdW50",
            "EhUKDWFjY291bnRfZW1haWwYASABKAkiQAoMQXdzQWNjZXNzS2V5EhUKDWFj",
            "Y2Vzc19rZXlfaWQYASABKAkSGQoRc2VjcmV0X2FjY2Vzc19rZXkYAiABKAki",
            "4AEKEE9iamVjdENvbmRpdGlvbnMSSwoobWluX3RpbWVfZWxhcHNlZF9zaW5j",
            "ZV9sYXN0X21vZGlmaWNhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5E",
            "dXJhdGlvbhJLCihtYXhfdGltZV9lbGFwc2VkX3NpbmNlX2xhc3RfbW9kaWZp",
            "Y2F0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhgKEGlu",
            "Y2x1ZGVfcHJlZml4ZXMYAyADKAkSGAoQZXhjbHVkZV9wcmVmaXhlcxgEIAMo",
            "CSIeCgdHY3NEYXRhEhMKC2J1Y2tldF9uYW1lGAEgASgJImEKCUF3c1MzRGF0",
            "YRITCgtidWNrZXRfbmFtZRgBIAEoCRI/Cg5hd3NfYWNjZXNzX2tleRgCIAEo",
            "CzInLmdvb2dsZS5zdG9yYWdldHJhbnNmZXIudjEuQXdzQWNjZXNzS2V5IhwK",
            "CEh0dHBEYXRhEhAKCGxpc3RfdXJsGAEgASgJIp8BCg9UcmFuc2Zlck9wdGlv",
            "bnMSMgoqb3ZlcndyaXRlX29iamVjdHNfYWxyZWFkeV9leGlzdGluZ19pbl9z",
            "aW5rGAEgASgIEiUKHWRlbGV0ZV9vYmplY3RzX3VuaXF1ZV9pbl9zaW5rGAIg",
            "ASgIEjEKKWRlbGV0ZV9vYmplY3RzX2Zyb21fc291cmNlX2FmdGVyX3RyYW5z",
            "ZmVyGAMgASgIIrkDCgxUcmFuc2ZlclNwZWMSPQoPZ2NzX2RhdGFfc291cmNl",
            "GAEgASgLMiIuZ29vZ2xlLnN0b3JhZ2V0cmFuc2Zlci52MS5HY3NEYXRhSAAS",
            "QgoSYXdzX3MzX2RhdGFfc291cmNlGAIgASgLMiQuZ29vZ2xlLnN0b3JhZ2V0",
            "cmFuc2Zlci52MS5Bd3NTM0RhdGFIABI/ChBodHRwX2RhdGFfc291cmNlGAMg",
            "ASgLMiMuZ29vZ2xlLnN0b3JhZ2V0cmFuc2Zlci52MS5IdHRwRGF0YUgAEjsK",
            "DWdjc19kYXRhX3NpbmsYBCABKAsyIi5nb29nbGUuc3RvcmFnZXRyYW5zZmVy",
            "LnYxLkdjc0RhdGFIARJGChFvYmplY3RfY29uZGl0aW9ucxgFIAEoCzIrLmdv",
            "b2dsZS5zdG9yYWdldHJhbnNmZXIudjEuT2JqZWN0Q29uZGl0aW9ucxJEChB0",
            "cmFuc2Zlcl9vcHRpb25zGAYgASgLMiouZ29vZ2xlLnN0b3JhZ2V0cmFuc2Zl",
            "ci52MS5UcmFuc2Zlck9wdGlvbnNCDQoLZGF0YV9zb3VyY2VCCwoJZGF0YV9z",
            "aW5rIpsBCghTY2hlZHVsZRIuChNzY2hlZHVsZV9zdGFydF9kYXRlGAEgASgL",
            "MhEuZ29vZ2xlLnR5cGUuRGF0ZRIsChFzY2hlZHVsZV9lbmRfZGF0ZRgCIAEo",
            "CzIRLmdvb2dsZS50eXBlLkRhdGUSMQoRc3RhcnRfdGltZV9vZl9kYXkYAyAB",
            "KAsyFi5nb29nbGUudHlwZS5UaW1lT2ZEYXki5gMKC1RyYW5zZmVySm9iEgwK",
            "BG5hbWUYASABKAkSEwoLZGVzY3JpcHRpb24YAiABKAkSEgoKcHJvamVjdF9p",
            "ZBgDIAEoCRI+Cg10cmFuc2Zlcl9zcGVjGAQgASgLMicuZ29vZ2xlLnN0b3Jh",
            "Z2V0cmFuc2Zlci52MS5UcmFuc2ZlclNwZWMSNQoIc2NoZWR1bGUYBSABKAsy",
            "Iy5nb29nbGUuc3RvcmFnZXRyYW5zZmVyLnYxLlNjaGVkdWxlEj0KBnN0YXR1",
            "cxgGIAEoDjItLmdvb2dsZS5zdG9yYWdldHJhbnNmZXIudjEuVHJhbnNmZXJK",
            "b2IuU3RhdHVzEjEKDWNyZWF0aW9uX3RpbWUYByABKAsyGi5nb29nbGUucHJv",
            "dG9idWYuVGltZXN0YW1wEjoKFmxhc3RfbW9kaWZpY2F0aW9uX3RpbWUYCCAB",
            "KAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjEKDWRlbGV0aW9uX3Rp",
            "bWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIkgKBlN0YXR1",
            "cxIWChJTVEFUVVNfVU5TUEVDSUZJRUQQABILCgdFTkFCTEVEEAESDAoIRElT",
            "QUJMRUQQAhILCgdERUxFVEVEEAMiMwoNRXJyb3JMb2dFbnRyeRILCgN1cmwY",
            "ASABKAkSFQoNZXJyb3JfZGV0YWlscxgDIAMoCSKOAQoMRXJyb3JTdW1tYXJ5",
            "EiQKCmVycm9yX2NvZGUYASABKA4yEC5nb29nbGUucnBjLkNvZGUSEwoLZXJy",
            "b3JfY291bnQYAiABKAMSQwoRZXJyb3JfbG9nX2VudHJpZXMYAyADKAsyKC5n",
            "b29nbGUuc3RvcmFnZXRyYW5zZmVyLnYxLkVycm9yTG9nRW50cnki3gQKEFRy",
            "YW5zZmVyQ291bnRlcnMSIQoZb2JqZWN0c19mb3VuZF9mcm9tX3NvdXJjZRgB",
            "IAEoAxIfChdieXRlc19mb3VuZF9mcm9tX3NvdXJjZRgCIAEoAxIkChxvYmpl",
            "Y3RzX2ZvdW5kX29ubHlfZnJvbV9zaW5rGAMgASgDEiIKGmJ5dGVzX2ZvdW5k",
            "X29ubHlfZnJvbV9zaW5rGAQgASgDEisKI29iamVjdHNfZnJvbV9zb3VyY2Vf",
            "c2tpcHBlZF9ieV9zeW5jGAUgASgDEikKIWJ5dGVzX2Zyb21fc291cmNlX3Nr",
            "aXBwZWRfYnlfc3luYxgGIAEoAxIeChZvYmplY3RzX2NvcGllZF90b19zaW5r",
            "GAcgASgDEhwKFGJ5dGVzX2NvcGllZF90b19zaW5rGAggASgDEiMKG29iamVj",
            "dHNfZGVsZXRlZF9mcm9tX3NvdXJjZRgJIAEoAxIhChlieXRlc19kZWxldGVk",
            "X2Zyb21fc291cmNlGAogASgDEiEKGW9iamVjdHNfZGVsZXRlZF9mcm9tX3Np",
            "bmsYCyABKAMSHwoXYnl0ZXNfZGVsZXRlZF9mcm9tX3NpbmsYDCABKAMSIgoa",
            "b2JqZWN0c19mcm9tX3NvdXJjZV9mYWlsZWQYDSABKAMSIAoYYnl0ZXNfZnJv",
            "bV9zb3VyY2VfZmFpbGVkGA4gASgDEioKIm9iamVjdHNfZmFpbGVkX3RvX2Rl",
            "bGV0ZV9mcm9tX3NpbmsYDyABKAMSKAogYnl0ZXNfZmFpbGVkX3RvX2RlbGV0",
            "ZV9mcm9tX3NpbmsYECABKAMimgQKEVRyYW5zZmVyT3BlcmF0aW9uEgwKBG5h",
            "bWUYASABKAkSEgoKcHJvamVjdF9pZBgCIAEoCRI+Cg10cmFuc2Zlcl9zcGVj",
            "GAMgASgLMicuZ29vZ2xlLnN0b3JhZ2V0cmFuc2Zlci52MS5UcmFuc2ZlclNw",
            "ZWMSLgoKc3RhcnRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXASLAoIZW5kX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGlt",
            "ZXN0YW1wEkMKBnN0YXR1cxgGIAEoDjIzLmdvb2dsZS5zdG9yYWdldHJhbnNm",
            "ZXIudjEuVHJhbnNmZXJPcGVyYXRpb24uU3RhdHVzEj0KCGNvdW50ZXJzGAcg",
            "ASgLMisuZ29vZ2xlLnN0b3JhZ2V0cmFuc2Zlci52MS5UcmFuc2ZlckNvdW50",
            "ZXJzEkEKEGVycm9yX2JyZWFrZG93bnMYCCADKAsyJy5nb29nbGUuc3RvcmFn",
            "ZXRyYW5zZmVyLnYxLkVycm9yU3VtbWFyeRIZChF0cmFuc2Zlcl9qb2JfbmFt",
            "ZRgJIAEoCSJjCgZTdGF0dXMSFgoSU1RBVFVTX1VOU1BFQ0lGSUVEEAASDwoL",
            "SU5fUFJPR1JFU1MQARIKCgZQQVVTRUQQAhILCgdTVUNDRVNTEAMSCgoGRkFJ",
            "TEVEEAQSCwoHQUJPUlRFRBAFQoEBCiNjb20uZ29vZ2xlLnN0b3JhZ2V0cmFu",
            "c2Zlci52MS5wcm90b0INVHJhbnNmZXJUeXBlc1pIZ29vZ2xlLmdvbGFuZy5v",
            "cmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9zdG9yYWdldHJhbnNmZXIvdjE7c3Rv",
            "cmFnZXRyYW5zZmVy+AEBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Rpc.CodeReflection.Descriptor, global::Google.Type.DateReflection.Descriptor, global::Google.Type.TimeofdayReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.GoogleServiceAccount), global::Google.Storagetransfer.V1.GoogleServiceAccount.Parser, new[]{ "AccountEmail" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.AwsAccessKey), global::Google.Storagetransfer.V1.AwsAccessKey.Parser, new[]{ "AccessKeyId", "SecretAccessKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.ObjectConditions), global::Google.Storagetransfer.V1.ObjectConditions.Parser, new[]{ "MinTimeElapsedSinceLastModification", "MaxTimeElapsedSinceLastModification", "IncludePrefixes", "ExcludePrefixes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.GcsData), global::Google.Storagetransfer.V1.GcsData.Parser, new[]{ "BucketName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.AwsS3Data), global::Google.Storagetransfer.V1.AwsS3Data.Parser, new[]{ "BucketName", "AwsAccessKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.HttpData), global::Google.Storagetransfer.V1.HttpData.Parser, new[]{ "ListUrl" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.TransferOptions), global::Google.Storagetransfer.V1.TransferOptions.Parser, new[]{ "OverwriteObjectsAlreadyExistingInSink", "DeleteObjectsUniqueInSink", "DeleteObjectsFromSourceAfterTransfer" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.TransferSpec), global::Google.Storagetransfer.V1.TransferSpec.Parser, new[]{ "GcsDataSource", "AwsS3DataSource", "HttpDataSource", "GcsDataSink", "ObjectConditions", "TransferOptions" }, new[]{ "DataSource", "DataSink" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.Schedule), global::Google.Storagetransfer.V1.Schedule.Parser, new[]{ "ScheduleStartDate", "ScheduleEndDate", "StartTimeOfDay" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.TransferJob), global::Google.Storagetransfer.V1.TransferJob.Parser, new[]{ "Name", "Description", "ProjectId", "TransferSpec", "Schedule", "Status", "CreationTime", "LastModificationTime", "DeletionTime" }, null, new[]{ typeof(global::Google.Storagetransfer.V1.TransferJob.Types.Status) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.ErrorLogEntry), global::Google.Storagetransfer.V1.ErrorLogEntry.Parser, new[]{ "Url", "ErrorDetails" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.ErrorSummary), global::Google.Storagetransfer.V1.ErrorSummary.Parser, new[]{ "ErrorCode", "ErrorCount", "ErrorLogEntries" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.TransferCounters), global::Google.Storagetransfer.V1.TransferCounters.Parser, new[]{ "ObjectsFoundFromSource", "BytesFoundFromSource", "ObjectsFoundOnlyFromSink", "BytesFoundOnlyFromSink", "ObjectsFromSourceSkippedBySync", "BytesFromSourceSkippedBySync", "ObjectsCopiedToSink", "BytesCopiedToSink", "ObjectsDeletedFromSource", "BytesDeletedFromSource", "ObjectsDeletedFromSink", "BytesDeletedFromSink", "ObjectsFromSourceFailed", "BytesFromSourceFailed", "ObjectsFailedToDeleteFromSink", "BytesFailedToDeleteFromSink" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Storagetransfer.V1.TransferOperation), global::Google.Storagetransfer.V1.TransferOperation.Parser, new[]{ "Name", "ProjectId", "TransferSpec", "StartTime", "EndTime", "Status", "Counters", "ErrorBreakdowns", "TransferJobName" }, null, new[]{ typeof(global::Google.Storagetransfer.V1.TransferOperation.Types.Status) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  Google service account
  /// </summary>
  public sealed partial class GoogleServiceAccount : pb::IMessage<GoogleServiceAccount> {
    private static readonly pb::MessageParser<GoogleServiceAccount> _parser = new pb::MessageParser<GoogleServiceAccount>(() => new GoogleServiceAccount());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GoogleServiceAccount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoogleServiceAccount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoogleServiceAccount(GoogleServiceAccount other) : this() {
      accountEmail_ = other.accountEmail_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoogleServiceAccount Clone() {
      return new GoogleServiceAccount(this);
    }

    /// <summary>Field number for the "account_email" field.</summary>
    public const int AccountEmailFieldNumber = 1;
    private string accountEmail_ = "";
    /// <summary>
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccountEmail {
      get { return accountEmail_; }
      set {
        accountEmail_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GoogleServiceAccount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GoogleServiceAccount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccountEmail != other.AccountEmail) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AccountEmail.Length != 0) hash ^= AccountEmail.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AccountEmail.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AccountEmail);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AccountEmail.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccountEmail);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GoogleServiceAccount other) {
      if (other == null) {
        return;
      }
      if (other.AccountEmail.Length != 0) {
        AccountEmail = other.AccountEmail;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            AccountEmail = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  AWS access key (see
  ///  [AWS Security Credentials](http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html)).
  /// </summary>
  public sealed partial class AwsAccessKey : pb::IMessage<AwsAccessKey> {
    private static readonly pb::MessageParser<AwsAccessKey> _parser = new pb::MessageParser<AwsAccessKey>(() => new AwsAccessKey());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AwsAccessKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsAccessKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsAccessKey(AwsAccessKey other) : this() {
      accessKeyId_ = other.accessKeyId_;
      secretAccessKey_ = other.secretAccessKey_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsAccessKey Clone() {
      return new AwsAccessKey(this);
    }

    /// <summary>Field number for the "access_key_id" field.</summary>
    public const int AccessKeyIdFieldNumber = 1;
    private string accessKeyId_ = "";
    /// <summary>
    ///  AWS access key ID.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessKeyId {
      get { return accessKeyId_; }
      set {
        accessKeyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "secret_access_key" field.</summary>
    public const int SecretAccessKeyFieldNumber = 2;
    private string secretAccessKey_ = "";
    /// <summary>
    ///  AWS secret access key. This field is not returned in RPC responses.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SecretAccessKey {
      get { return secretAccessKey_; }
      set {
        secretAccessKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AwsAccessKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AwsAccessKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccessKeyId != other.AccessKeyId) return false;
      if (SecretAccessKey != other.SecretAccessKey) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AccessKeyId.Length != 0) hash ^= AccessKeyId.GetHashCode();
      if (SecretAccessKey.Length != 0) hash ^= SecretAccessKey.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AccessKeyId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AccessKeyId);
      }
      if (SecretAccessKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(SecretAccessKey);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AccessKeyId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessKeyId);
      }
      if (SecretAccessKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretAccessKey);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AwsAccessKey other) {
      if (other == null) {
        return;
      }
      if (other.AccessKeyId.Length != 0) {
        AccessKeyId = other.AccessKeyId;
      }
      if (other.SecretAccessKey.Length != 0) {
        SecretAccessKey = other.SecretAccessKey;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            AccessKeyId = input.ReadString();
            break;
          }
          case 18: {
            SecretAccessKey = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Conditions that determine which objects will be transferred.
  /// </summary>
  public sealed partial class ObjectConditions : pb::IMessage<ObjectConditions> {
    private static readonly pb::MessageParser<ObjectConditions> _parser = new pb::MessageParser<ObjectConditions>(() => new ObjectConditions());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ObjectConditions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectConditions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectConditions(ObjectConditions other) : this() {
      MinTimeElapsedSinceLastModification = other.minTimeElapsedSinceLastModification_ != null ? other.MinTimeElapsedSinceLastModification.Clone() : null;
      MaxTimeElapsedSinceLastModification = other.maxTimeElapsedSinceLastModification_ != null ? other.MaxTimeElapsedSinceLastModification.Clone() : null;
      includePrefixes_ = other.includePrefixes_.Clone();
      excludePrefixes_ = other.excludePrefixes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectConditions Clone() {
      return new ObjectConditions(this);
    }

    /// <summary>Field number for the "min_time_elapsed_since_last_modification" field.</summary>
    public const int MinTimeElapsedSinceLastModificationFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration minTimeElapsedSinceLastModification_;
    /// <summary>
    ///  If unspecified, `minTimeElapsedSinceLastModification` takes a zero value
    ///  and `maxTimeElapsedSinceLastModification` takes the maximum possible
    ///  value of Duration. Objects that satisfy the object conditions
    ///  must either have a `lastModificationTime` greater or equal to
    ///  `NOW` - `maxTimeElapsedSinceLastModification` and less than
    ///  `NOW` - `minTimeElapsedSinceLastModification`, or not have a
    ///  `lastModificationTime`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MinTimeElapsedSinceLastModification {
      get { return minTimeElapsedSinceLastModification_; }
      set {
        minTimeElapsedSinceLastModification_ = value;
      }
    }

    /// <summary>Field number for the "max_time_elapsed_since_last_modification" field.</summary>
    public const int MaxTimeElapsedSinceLastModificationFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration maxTimeElapsedSinceLastModification_;
    /// <summary>
    ///  `maxTimeElapsedSinceLastModification` is the complement to
    ///  `minTimeElapsedSinceLastModification`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxTimeElapsedSinceLastModification {
      get { return maxTimeElapsedSinceLastModification_; }
      set {
        maxTimeElapsedSinceLastModification_ = value;
      }
    }

    /// <summary>Field number for the "include_prefixes" field.</summary>
    public const int IncludePrefixesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_includePrefixes_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> includePrefixes_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  If `includePrefixes` is specified, objects that satisfy the object
    ///  conditions must have names that start with one of the `includePrefixes`
    ///  and that do not start with any of the `excludePrefixes`. If `includePrefixes`
    ///  is not specified, all objects except those that have names starting with
    ///  one of the `excludePrefixes` must satisfy the object conditions.
    ///
    ///  Requirements:
    ///
    ///    * Each include-prefix and exclude-prefix can contain any sequence of
    ///      Unicode characters, of max length 1024 bytes when UTF8-encoded, and
    ///      must not contain Carriage Return or Line Feed characters.  Wildcard
    ///      matching and regular expression matching are not supported.
    ///
    ///    * Each include-prefix and exclude-prefix must omit the leading slash.
    ///      For example, to include the `requests.gz` object in a transfer from
    ///      `s3://my-aws-bucket/logs/y=2015/requests.gz`, specify the include
    ///      prefix as `logs/y=2015/requests.gz`.
    ///
    ///    * None of the include-prefix or the exclude-prefix values can be empty,
    ///      if specified.
    ///
    ///    * Each include-prefix must include a distinct portion of the object
    ///      namespace, i.e., no include-prefix may be a prefix of another
    ///      include-prefix.
    ///
    ///    * Each exclude-prefix must exclude a distinct portion of the object
    ///      namespace, i.e., no exclude-prefix may be a prefix of another
    ///      exclude-prefix.
    ///
    ///    * If `includePrefixes` is specified, then each exclude-prefix must start
    ///      with the value of a path explicitly included by `includePrefixes`.
    ///
    ///  The max size of `includePrefixes` is 20.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> IncludePrefixes {
      get { return includePrefixes_; }
    }

    /// <summary>Field number for the "exclude_prefixes" field.</summary>
    public const int ExcludePrefixesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_excludePrefixes_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> excludePrefixes_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  `excludePrefixes` must follow the requirements described for
    ///  `includePrefixes`.
    ///
    ///  The max size of `excludePrefixes` is 20.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExcludePrefixes {
      get { return excludePrefixes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ObjectConditions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ObjectConditions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinTimeElapsedSinceLastModification, other.MinTimeElapsedSinceLastModification)) return false;
      if (!object.Equals(MaxTimeElapsedSinceLastModification, other.MaxTimeElapsedSinceLastModification)) return false;
      if(!includePrefixes_.Equals(other.includePrefixes_)) return false;
      if(!excludePrefixes_.Equals(other.excludePrefixes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minTimeElapsedSinceLastModification_ != null) hash ^= MinTimeElapsedSinceLastModification.GetHashCode();
      if (maxTimeElapsedSinceLastModification_ != null) hash ^= MaxTimeElapsedSinceLastModification.GetHashCode();
      hash ^= includePrefixes_.GetHashCode();
      hash ^= excludePrefixes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (minTimeElapsedSinceLastModification_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinTimeElapsedSinceLastModification);
      }
      if (maxTimeElapsedSinceLastModification_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(MaxTimeElapsedSinceLastModification);
      }
      includePrefixes_.WriteTo(output, _repeated_includePrefixes_codec);
      excludePrefixes_.WriteTo(output, _repeated_excludePrefixes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minTimeElapsedSinceLastModification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinTimeElapsedSinceLastModification);
      }
      if (maxTimeElapsedSinceLastModification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxTimeElapsedSinceLastModification);
      }
      size += includePrefixes_.CalculateSize(_repeated_includePrefixes_codec);
      size += excludePrefixes_.CalculateSize(_repeated_excludePrefixes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ObjectConditions other) {
      if (other == null) {
        return;
      }
      if (other.minTimeElapsedSinceLastModification_ != null) {
        if (minTimeElapsedSinceLastModification_ == null) {
          minTimeElapsedSinceLastModification_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MinTimeElapsedSinceLastModification.MergeFrom(other.MinTimeElapsedSinceLastModification);
      }
      if (other.maxTimeElapsedSinceLastModification_ != null) {
        if (maxTimeElapsedSinceLastModification_ == null) {
          maxTimeElapsedSinceLastModification_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxTimeElapsedSinceLastModification.MergeFrom(other.MaxTimeElapsedSinceLastModification);
      }
      includePrefixes_.Add(other.includePrefixes_);
      excludePrefixes_.Add(other.excludePrefixes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (minTimeElapsedSinceLastModification_ == null) {
              minTimeElapsedSinceLastModification_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(minTimeElapsedSinceLastModification_);
            break;
          }
          case 18: {
            if (maxTimeElapsedSinceLastModification_ == null) {
              maxTimeElapsedSinceLastModification_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(maxTimeElapsedSinceLastModification_);
            break;
          }
          case 26: {
            includePrefixes_.AddEntriesFrom(input, _repeated_includePrefixes_codec);
            break;
          }
          case 34: {
            excludePrefixes_.AddEntriesFrom(input, _repeated_excludePrefixes_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  In a GcsData, an object's name is the Google Cloud Storage object's name and
  ///  its `lastModificationTime` refers to the object's updated time, which changes
  ///  when the content or the metadata of the object is updated.
  /// </summary>
  public sealed partial class GcsData : pb::IMessage<GcsData> {
    private static readonly pb::MessageParser<GcsData> _parser = new pb::MessageParser<GcsData>(() => new GcsData());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GcsData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsData(GcsData other) : this() {
      bucketName_ = other.bucketName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GcsData Clone() {
      return new GcsData(this);
    }

    /// <summary>Field number for the "bucket_name" field.</summary>
    public const int BucketNameFieldNumber = 1;
    private string bucketName_ = "";
    /// <summary>
    ///  Google Cloud Storage bucket name (see
    ///  [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BucketName {
      get { return bucketName_; }
      set {
        bucketName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GcsData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GcsData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BucketName != other.BucketName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BucketName.Length != 0) hash ^= BucketName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BucketName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BucketName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BucketName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BucketName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GcsData other) {
      if (other == null) {
        return;
      }
      if (other.BucketName.Length != 0) {
        BucketName = other.BucketName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            BucketName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  An AwsS3Data can be a data source, but not a data sink.
  ///  In an AwsS3Data, an object's name is the S3 object's key name.
  /// </summary>
  public sealed partial class AwsS3Data : pb::IMessage<AwsS3Data> {
    private static readonly pb::MessageParser<AwsS3Data> _parser = new pb::MessageParser<AwsS3Data>(() => new AwsS3Data());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AwsS3Data> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsS3Data() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsS3Data(AwsS3Data other) : this() {
      bucketName_ = other.bucketName_;
      AwsAccessKey = other.awsAccessKey_ != null ? other.AwsAccessKey.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AwsS3Data Clone() {
      return new AwsS3Data(this);
    }

    /// <summary>Field number for the "bucket_name" field.</summary>
    public const int BucketNameFieldNumber = 1;
    private string bucketName_ = "";
    /// <summary>
    ///  S3 Bucket name (see
    ///  [Creating a bucket](http://docs.aws.amazon.com/AmazonS3/latest/dev/create-bucket-get-location-example.html)).
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BucketName {
      get { return bucketName_; }
      set {
        bucketName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "aws_access_key" field.</summary>
    public const int AwsAccessKeyFieldNumber = 2;
    private global::Google.Storagetransfer.V1.AwsAccessKey awsAccessKey_;
    /// <summary>
    ///  AWS access key used to sign the API requests to the AWS S3 bucket.
    ///  Permissions on the bucket must be granted to the access ID of the
    ///  AWS access key.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.AwsAccessKey AwsAccessKey {
      get { return awsAccessKey_; }
      set {
        awsAccessKey_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AwsS3Data);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AwsS3Data other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BucketName != other.BucketName) return false;
      if (!object.Equals(AwsAccessKey, other.AwsAccessKey)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BucketName.Length != 0) hash ^= BucketName.GetHashCode();
      if (awsAccessKey_ != null) hash ^= AwsAccessKey.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BucketName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BucketName);
      }
      if (awsAccessKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AwsAccessKey);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BucketName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BucketName);
      }
      if (awsAccessKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AwsAccessKey);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AwsS3Data other) {
      if (other == null) {
        return;
      }
      if (other.BucketName.Length != 0) {
        BucketName = other.BucketName;
      }
      if (other.awsAccessKey_ != null) {
        if (awsAccessKey_ == null) {
          awsAccessKey_ = new global::Google.Storagetransfer.V1.AwsAccessKey();
        }
        AwsAccessKey.MergeFrom(other.AwsAccessKey);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            BucketName = input.ReadString();
            break;
          }
          case 18: {
            if (awsAccessKey_ == null) {
              awsAccessKey_ = new global::Google.Storagetransfer.V1.AwsAccessKey();
            }
            input.ReadMessage(awsAccessKey_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  An HttpData specifies a list of objects on the web to be transferred over
  ///  HTTP.  The information of the objects to be transferred is contained in a
  ///  file referenced by a URL. The first line in the file must be
  ///  "TsvHttpData-1.0", which specifies the format of the file.  Subsequent lines
  ///  specify the information of the list of objects, one object per list entry.
  ///  Each entry has the following tab-delimited fields:
  ///
  ///  * HTTP URL - The location of the object.
  ///
  ///  * Length - The size of the object in bytes.
  ///
  ///  * MD5 - The base64-encoded MD5 hash of the object.
  ///
  ///  For an example of a valid TSV file, see
  ///  [Transferring data from URLs](https://cloud.google.com/storage/transfer/#urls)
  ///
  ///  When transferring data based on a URL list, keep the following in mind:
  ///
  ///  * When an object located at `http(s)://hostname:port/&lt;URL-path>` is transferred
  ///  to a data sink, the name of the object at the data sink is
  ///  `&lt;hostname>/&lt;URL-path>`.
  ///
  ///  * If the specified size of an object does not match the actual size of the
  ///  object fetched, the object will not be transferred.
  ///
  ///  * If the specified MD5 does not match the MD5 computed from the transferred
  ///  bytes, the object transfer will fail. For more information, see
  ///  [Generating MD5 hashes](https://cloud.google.com/storage/transfer/#md5)
  ///
  ///  * Ensure that each URL you specify is publicly accessible. For
  ///  example, in Google Cloud Storage you can
  ///  [share an object publicly]
  ///  (https://cloud.google.com/storage/docs/cloud-console#_sharingdata) and get
  ///  a link to it.
  ///
  ///  * Storage Transfer Service obeys `robots.txt` rules and requires the source
  ///  HTTP server to support `Range` requests and to return a `Content-Length`
  ///  header in each response.
  ///
  ///  * [ObjectConditions](#ObjectConditions) have no effect when filtering objects
  ///  to transfer.
  /// </summary>
  public sealed partial class HttpData : pb::IMessage<HttpData> {
    private static readonly pb::MessageParser<HttpData> _parser = new pb::MessageParser<HttpData>(() => new HttpData());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpData(HttpData other) : this() {
      listUrl_ = other.listUrl_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpData Clone() {
      return new HttpData(this);
    }

    /// <summary>Field number for the "list_url" field.</summary>
    public const int ListUrlFieldNumber = 1;
    private string listUrl_ = "";
    /// <summary>
    ///  The URL that points to the file that stores the object list entries.
    ///  This file must allow public access.  Currently, only URLs with HTTP and
    ///  HTTPS schemes are supported.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ListUrl {
      get { return listUrl_; }
      set {
        listUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ListUrl != other.ListUrl) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ListUrl.Length != 0) hash ^= ListUrl.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ListUrl.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ListUrl);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ListUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ListUrl);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpData other) {
      if (other == null) {
        return;
      }
      if (other.ListUrl.Length != 0) {
        ListUrl = other.ListUrl;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ListUrl = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  TransferOptions uses three boolean parameters to define the actions
  ///  to be performed on objects in a transfer.
  /// </summary>
  public sealed partial class TransferOptions : pb::IMessage<TransferOptions> {
    private static readonly pb::MessageParser<TransferOptions> _parser = new pb::MessageParser<TransferOptions>(() => new TransferOptions());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOptions(TransferOptions other) : this() {
      overwriteObjectsAlreadyExistingInSink_ = other.overwriteObjectsAlreadyExistingInSink_;
      deleteObjectsUniqueInSink_ = other.deleteObjectsUniqueInSink_;
      deleteObjectsFromSourceAfterTransfer_ = other.deleteObjectsFromSourceAfterTransfer_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOptions Clone() {
      return new TransferOptions(this);
    }

    /// <summary>Field number for the "overwrite_objects_already_existing_in_sink" field.</summary>
    public const int OverwriteObjectsAlreadyExistingInSinkFieldNumber = 1;
    private bool overwriteObjectsAlreadyExistingInSink_;
    /// <summary>
    ///  Whether overwriting objects that already exist in the sink is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OverwriteObjectsAlreadyExistingInSink {
      get { return overwriteObjectsAlreadyExistingInSink_; }
      set {
        overwriteObjectsAlreadyExistingInSink_ = value;
      }
    }

    /// <summary>Field number for the "delete_objects_unique_in_sink" field.</summary>
    public const int DeleteObjectsUniqueInSinkFieldNumber = 2;
    private bool deleteObjectsUniqueInSink_;
    /// <summary>
    ///  Whether objects that exist only in the sink should be deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DeleteObjectsUniqueInSink {
      get { return deleteObjectsUniqueInSink_; }
      set {
        deleteObjectsUniqueInSink_ = value;
      }
    }

    /// <summary>Field number for the "delete_objects_from_source_after_transfer" field.</summary>
    public const int DeleteObjectsFromSourceAfterTransferFieldNumber = 3;
    private bool deleteObjectsFromSourceAfterTransfer_;
    /// <summary>
    ///  Whether objects should be deleted from the source after they are
    ///  transferred to the sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DeleteObjectsFromSourceAfterTransfer {
      get { return deleteObjectsFromSourceAfterTransfer_; }
      set {
        deleteObjectsFromSourceAfterTransfer_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OverwriteObjectsAlreadyExistingInSink != other.OverwriteObjectsAlreadyExistingInSink) return false;
      if (DeleteObjectsUniqueInSink != other.DeleteObjectsUniqueInSink) return false;
      if (DeleteObjectsFromSourceAfterTransfer != other.DeleteObjectsFromSourceAfterTransfer) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OverwriteObjectsAlreadyExistingInSink != false) hash ^= OverwriteObjectsAlreadyExistingInSink.GetHashCode();
      if (DeleteObjectsUniqueInSink != false) hash ^= DeleteObjectsUniqueInSink.GetHashCode();
      if (DeleteObjectsFromSourceAfterTransfer != false) hash ^= DeleteObjectsFromSourceAfterTransfer.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OverwriteObjectsAlreadyExistingInSink != false) {
        output.WriteRawTag(8);
        output.WriteBool(OverwriteObjectsAlreadyExistingInSink);
      }
      if (DeleteObjectsUniqueInSink != false) {
        output.WriteRawTag(16);
        output.WriteBool(DeleteObjectsUniqueInSink);
      }
      if (DeleteObjectsFromSourceAfterTransfer != false) {
        output.WriteRawTag(24);
        output.WriteBool(DeleteObjectsFromSourceAfterTransfer);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OverwriteObjectsAlreadyExistingInSink != false) {
        size += 1 + 1;
      }
      if (DeleteObjectsUniqueInSink != false) {
        size += 1 + 1;
      }
      if (DeleteObjectsFromSourceAfterTransfer != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferOptions other) {
      if (other == null) {
        return;
      }
      if (other.OverwriteObjectsAlreadyExistingInSink != false) {
        OverwriteObjectsAlreadyExistingInSink = other.OverwriteObjectsAlreadyExistingInSink;
      }
      if (other.DeleteObjectsUniqueInSink != false) {
        DeleteObjectsUniqueInSink = other.DeleteObjectsUniqueInSink;
      }
      if (other.DeleteObjectsFromSourceAfterTransfer != false) {
        DeleteObjectsFromSourceAfterTransfer = other.DeleteObjectsFromSourceAfterTransfer;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            OverwriteObjectsAlreadyExistingInSink = input.ReadBool();
            break;
          }
          case 16: {
            DeleteObjectsUniqueInSink = input.ReadBool();
            break;
          }
          case 24: {
            DeleteObjectsFromSourceAfterTransfer = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Configuration for running a transfer.
  /// </summary>
  public sealed partial class TransferSpec : pb::IMessage<TransferSpec> {
    private static readonly pb::MessageParser<TransferSpec> _parser = new pb::MessageParser<TransferSpec>(() => new TransferSpec());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferSpec(TransferSpec other) : this() {
      ObjectConditions = other.objectConditions_ != null ? other.ObjectConditions.Clone() : null;
      TransferOptions = other.transferOptions_ != null ? other.TransferOptions.Clone() : null;
      switch (other.DataSourceCase) {
        case DataSourceOneofCase.GcsDataSource:
          GcsDataSource = other.GcsDataSource.Clone();
          break;
        case DataSourceOneofCase.AwsS3DataSource:
          AwsS3DataSource = other.AwsS3DataSource.Clone();
          break;
        case DataSourceOneofCase.HttpDataSource:
          HttpDataSource = other.HttpDataSource.Clone();
          break;
      }

      switch (other.DataSinkCase) {
        case DataSinkOneofCase.GcsDataSink:
          GcsDataSink = other.GcsDataSink.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferSpec Clone() {
      return new TransferSpec(this);
    }

    /// <summary>Field number for the "gcs_data_source" field.</summary>
    public const int GcsDataSourceFieldNumber = 1;
    /// <summary>
    ///  A Google Cloud Storage data source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.GcsData GcsDataSource {
      get { return dataSourceCase_ == DataSourceOneofCase.GcsDataSource ? (global::Google.Storagetransfer.V1.GcsData) dataSource_ : null; }
      set {
        dataSource_ = value;
        dataSourceCase_ = value == null ? DataSourceOneofCase.None : DataSourceOneofCase.GcsDataSource;
      }
    }

    /// <summary>Field number for the "aws_s3_data_source" field.</summary>
    public const int AwsS3DataSourceFieldNumber = 2;
    /// <summary>
    ///  An AWS S3 data source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.AwsS3Data AwsS3DataSource {
      get { return dataSourceCase_ == DataSourceOneofCase.AwsS3DataSource ? (global::Google.Storagetransfer.V1.AwsS3Data) dataSource_ : null; }
      set {
        dataSource_ = value;
        dataSourceCase_ = value == null ? DataSourceOneofCase.None : DataSourceOneofCase.AwsS3DataSource;
      }
    }

    /// <summary>Field number for the "http_data_source" field.</summary>
    public const int HttpDataSourceFieldNumber = 3;
    /// <summary>
    ///  An HTTP URL data source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.HttpData HttpDataSource {
      get { return dataSourceCase_ == DataSourceOneofCase.HttpDataSource ? (global::Google.Storagetransfer.V1.HttpData) dataSource_ : null; }
      set {
        dataSource_ = value;
        dataSourceCase_ = value == null ? DataSourceOneofCase.None : DataSourceOneofCase.HttpDataSource;
      }
    }

    /// <summary>Field number for the "gcs_data_sink" field.</summary>
    public const int GcsDataSinkFieldNumber = 4;
    /// <summary>
    ///  A Google Cloud Storage data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.GcsData GcsDataSink {
      get { return dataSinkCase_ == DataSinkOneofCase.GcsDataSink ? (global::Google.Storagetransfer.V1.GcsData) dataSink_ : null; }
      set {
        dataSink_ = value;
        dataSinkCase_ = value == null ? DataSinkOneofCase.None : DataSinkOneofCase.GcsDataSink;
      }
    }

    /// <summary>Field number for the "object_conditions" field.</summary>
    public const int ObjectConditionsFieldNumber = 5;
    private global::Google.Storagetransfer.V1.ObjectConditions objectConditions_;
    /// <summary>
    ///  Only objects that satisfy these object conditions are included in the set
    ///  of data source and data sink objects.  Object conditions based on
    ///  objects' `lastModificationTime` do not exclude objects in a data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.ObjectConditions ObjectConditions {
      get { return objectConditions_; }
      set {
        objectConditions_ = value;
      }
    }

    /// <summary>Field number for the "transfer_options" field.</summary>
    public const int TransferOptionsFieldNumber = 6;
    private global::Google.Storagetransfer.V1.TransferOptions transferOptions_;
    /// <summary>
    ///  If the option `deleteObjectsUniqueInSink` is `true`, object conditions
    ///  based on objects' `lastModificationTime` are ignored and do not exclude
    ///  objects in a data source or a data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferOptions TransferOptions {
      get { return transferOptions_; }
      set {
        transferOptions_ = value;
      }
    }

    private object dataSource_;
    /// <summary>Enum of possible cases for the "data_source" oneof.</summary>
    public enum DataSourceOneofCase {
      None = 0,
      GcsDataSource = 1,
      AwsS3DataSource = 2,
      HttpDataSource = 3,
    }
    private DataSourceOneofCase dataSourceCase_ = DataSourceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataSourceOneofCase DataSourceCase {
      get { return dataSourceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataSource() {
      dataSourceCase_ = DataSourceOneofCase.None;
      dataSource_ = null;
    }

    private object dataSink_;
    /// <summary>Enum of possible cases for the "data_sink" oneof.</summary>
    public enum DataSinkOneofCase {
      None = 0,
      GcsDataSink = 4,
    }
    private DataSinkOneofCase dataSinkCase_ = DataSinkOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataSinkOneofCase DataSinkCase {
      get { return dataSinkCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataSink() {
      dataSinkCase_ = DataSinkOneofCase.None;
      dataSink_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GcsDataSource, other.GcsDataSource)) return false;
      if (!object.Equals(AwsS3DataSource, other.AwsS3DataSource)) return false;
      if (!object.Equals(HttpDataSource, other.HttpDataSource)) return false;
      if (!object.Equals(GcsDataSink, other.GcsDataSink)) return false;
      if (!object.Equals(ObjectConditions, other.ObjectConditions)) return false;
      if (!object.Equals(TransferOptions, other.TransferOptions)) return false;
      if (DataSourceCase != other.DataSourceCase) return false;
      if (DataSinkCase != other.DataSinkCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (dataSourceCase_ == DataSourceOneofCase.GcsDataSource) hash ^= GcsDataSource.GetHashCode();
      if (dataSourceCase_ == DataSourceOneofCase.AwsS3DataSource) hash ^= AwsS3DataSource.GetHashCode();
      if (dataSourceCase_ == DataSourceOneofCase.HttpDataSource) hash ^= HttpDataSource.GetHashCode();
      if (dataSinkCase_ == DataSinkOneofCase.GcsDataSink) hash ^= GcsDataSink.GetHashCode();
      if (objectConditions_ != null) hash ^= ObjectConditions.GetHashCode();
      if (transferOptions_ != null) hash ^= TransferOptions.GetHashCode();
      hash ^= (int) dataSourceCase_;
      hash ^= (int) dataSinkCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (dataSourceCase_ == DataSourceOneofCase.GcsDataSource) {
        output.WriteRawTag(10);
        output.WriteMessage(GcsDataSource);
      }
      if (dataSourceCase_ == DataSourceOneofCase.AwsS3DataSource) {
        output.WriteRawTag(18);
        output.WriteMessage(AwsS3DataSource);
      }
      if (dataSourceCase_ == DataSourceOneofCase.HttpDataSource) {
        output.WriteRawTag(26);
        output.WriteMessage(HttpDataSource);
      }
      if (dataSinkCase_ == DataSinkOneofCase.GcsDataSink) {
        output.WriteRawTag(34);
        output.WriteMessage(GcsDataSink);
      }
      if (objectConditions_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ObjectConditions);
      }
      if (transferOptions_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TransferOptions);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (dataSourceCase_ == DataSourceOneofCase.GcsDataSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcsDataSource);
      }
      if (dataSourceCase_ == DataSourceOneofCase.AwsS3DataSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AwsS3DataSource);
      }
      if (dataSourceCase_ == DataSourceOneofCase.HttpDataSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpDataSource);
      }
      if (dataSinkCase_ == DataSinkOneofCase.GcsDataSink) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcsDataSink);
      }
      if (objectConditions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ObjectConditions);
      }
      if (transferOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransferOptions);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferSpec other) {
      if (other == null) {
        return;
      }
      if (other.objectConditions_ != null) {
        if (objectConditions_ == null) {
          objectConditions_ = new global::Google.Storagetransfer.V1.ObjectConditions();
        }
        ObjectConditions.MergeFrom(other.ObjectConditions);
      }
      if (other.transferOptions_ != null) {
        if (transferOptions_ == null) {
          transferOptions_ = new global::Google.Storagetransfer.V1.TransferOptions();
        }
        TransferOptions.MergeFrom(other.TransferOptions);
      }
      switch (other.DataSourceCase) {
        case DataSourceOneofCase.GcsDataSource:
          GcsDataSource = other.GcsDataSource;
          break;
        case DataSourceOneofCase.AwsS3DataSource:
          AwsS3DataSource = other.AwsS3DataSource;
          break;
        case DataSourceOneofCase.HttpDataSource:
          HttpDataSource = other.HttpDataSource;
          break;
      }

      switch (other.DataSinkCase) {
        case DataSinkOneofCase.GcsDataSink:
          GcsDataSink = other.GcsDataSink;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::Google.Storagetransfer.V1.GcsData subBuilder = new global::Google.Storagetransfer.V1.GcsData();
            if (dataSourceCase_ == DataSourceOneofCase.GcsDataSource) {
              subBuilder.MergeFrom(GcsDataSource);
            }
            input.ReadMessage(subBuilder);
            GcsDataSource = subBuilder;
            break;
          }
          case 18: {
            global::Google.Storagetransfer.V1.AwsS3Data subBuilder = new global::Google.Storagetransfer.V1.AwsS3Data();
            if (dataSourceCase_ == DataSourceOneofCase.AwsS3DataSource) {
              subBuilder.MergeFrom(AwsS3DataSource);
            }
            input.ReadMessage(subBuilder);
            AwsS3DataSource = subBuilder;
            break;
          }
          case 26: {
            global::Google.Storagetransfer.V1.HttpData subBuilder = new global::Google.Storagetransfer.V1.HttpData();
            if (dataSourceCase_ == DataSourceOneofCase.HttpDataSource) {
              subBuilder.MergeFrom(HttpDataSource);
            }
            input.ReadMessage(subBuilder);
            HttpDataSource = subBuilder;
            break;
          }
          case 34: {
            global::Google.Storagetransfer.V1.GcsData subBuilder = new global::Google.Storagetransfer.V1.GcsData();
            if (dataSinkCase_ == DataSinkOneofCase.GcsDataSink) {
              subBuilder.MergeFrom(GcsDataSink);
            }
            input.ReadMessage(subBuilder);
            GcsDataSink = subBuilder;
            break;
          }
          case 42: {
            if (objectConditions_ == null) {
              objectConditions_ = new global::Google.Storagetransfer.V1.ObjectConditions();
            }
            input.ReadMessage(objectConditions_);
            break;
          }
          case 50: {
            if (transferOptions_ == null) {
              transferOptions_ = new global::Google.Storagetransfer.V1.TransferOptions();
            }
            input.ReadMessage(transferOptions_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Transfers can be scheduled to recur or to run just once.
  /// </summary>
  public sealed partial class Schedule : pb::IMessage<Schedule> {
    private static readonly pb::MessageParser<Schedule> _parser = new pb::MessageParser<Schedule>(() => new Schedule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Schedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Schedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Schedule(Schedule other) : this() {
      ScheduleStartDate = other.scheduleStartDate_ != null ? other.ScheduleStartDate.Clone() : null;
      ScheduleEndDate = other.scheduleEndDate_ != null ? other.ScheduleEndDate.Clone() : null;
      StartTimeOfDay = other.startTimeOfDay_ != null ? other.StartTimeOfDay.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Schedule Clone() {
      return new Schedule(this);
    }

    /// <summary>Field number for the "schedule_start_date" field.</summary>
    public const int ScheduleStartDateFieldNumber = 1;
    private global::Google.Type.Date scheduleStartDate_;
    /// <summary>
    ///  The first day the recurring transfer is scheduled to run. If
    ///  `scheduleStartDate` is in the past, the transfer will run for the first
    ///  time on the following day.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.Date ScheduleStartDate {
      get { return scheduleStartDate_; }
      set {
        scheduleStartDate_ = value;
      }
    }

    /// <summary>Field number for the "schedule_end_date" field.</summary>
    public const int ScheduleEndDateFieldNumber = 2;
    private global::Google.Type.Date scheduleEndDate_;
    /// <summary>
    ///  The last day the recurring transfer will be run. If `scheduleEndDate`
    ///  is the same as `scheduleStartDate`, the transfer will be executed only
    ///  once.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.Date ScheduleEndDate {
      get { return scheduleEndDate_; }
      set {
        scheduleEndDate_ = value;
      }
    }

    /// <summary>Field number for the "start_time_of_day" field.</summary>
    public const int StartTimeOfDayFieldNumber = 3;
    private global::Google.Type.TimeOfDay startTimeOfDay_;
    /// <summary>
    ///  The time in UTC at which the transfer will be scheduled to start in a day.
    ///  Transfers may start later than this time. If not specified, recurring and
    ///  one-time transfers that are scheduled to run today will run immediately;
    ///  recurring transfers that are scheduled to run on a future date will start
    ///  at approximately midnight UTC on that date. Note that when configuring a
    ///  transfer with the Cloud Platform Console, the transfer's start time in a
    ///  day is specified in your local timezone.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.TimeOfDay StartTimeOfDay {
      get { return startTimeOfDay_; }
      set {
        startTimeOfDay_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Schedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Schedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScheduleStartDate, other.ScheduleStartDate)) return false;
      if (!object.Equals(ScheduleEndDate, other.ScheduleEndDate)) return false;
      if (!object.Equals(StartTimeOfDay, other.StartTimeOfDay)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (scheduleStartDate_ != null) hash ^= ScheduleStartDate.GetHashCode();
      if (scheduleEndDate_ != null) hash ^= ScheduleEndDate.GetHashCode();
      if (startTimeOfDay_ != null) hash ^= StartTimeOfDay.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (scheduleStartDate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduleStartDate);
      }
      if (scheduleEndDate_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ScheduleEndDate);
      }
      if (startTimeOfDay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(StartTimeOfDay);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (scheduleStartDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduleStartDate);
      }
      if (scheduleEndDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduleEndDate);
      }
      if (startTimeOfDay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTimeOfDay);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Schedule other) {
      if (other == null) {
        return;
      }
      if (other.scheduleStartDate_ != null) {
        if (scheduleStartDate_ == null) {
          scheduleStartDate_ = new global::Google.Type.Date();
        }
        ScheduleStartDate.MergeFrom(other.ScheduleStartDate);
      }
      if (other.scheduleEndDate_ != null) {
        if (scheduleEndDate_ == null) {
          scheduleEndDate_ = new global::Google.Type.Date();
        }
        ScheduleEndDate.MergeFrom(other.ScheduleEndDate);
      }
      if (other.startTimeOfDay_ != null) {
        if (startTimeOfDay_ == null) {
          startTimeOfDay_ = new global::Google.Type.TimeOfDay();
        }
        StartTimeOfDay.MergeFrom(other.StartTimeOfDay);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (scheduleStartDate_ == null) {
              scheduleStartDate_ = new global::Google.Type.Date();
            }
            input.ReadMessage(scheduleStartDate_);
            break;
          }
          case 18: {
            if (scheduleEndDate_ == null) {
              scheduleEndDate_ = new global::Google.Type.Date();
            }
            input.ReadMessage(scheduleEndDate_);
            break;
          }
          case 26: {
            if (startTimeOfDay_ == null) {
              startTimeOfDay_ = new global::Google.Type.TimeOfDay();
            }
            input.ReadMessage(startTimeOfDay_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  This resource represents the configuration of a transfer job that runs
  ///  periodically.
  /// </summary>
  public sealed partial class TransferJob : pb::IMessage<TransferJob> {
    private static readonly pb::MessageParser<TransferJob> _parser = new pb::MessageParser<TransferJob>(() => new TransferJob());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferJob> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferJob() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferJob(TransferJob other) : this() {
      name_ = other.name_;
      description_ = other.description_;
      projectId_ = other.projectId_;
      TransferSpec = other.transferSpec_ != null ? other.TransferSpec.Clone() : null;
      Schedule = other.schedule_ != null ? other.Schedule.Clone() : null;
      status_ = other.status_;
      CreationTime = other.creationTime_ != null ? other.CreationTime.Clone() : null;
      LastModificationTime = other.lastModificationTime_ != null ? other.LastModificationTime.Clone() : null;
      DeletionTime = other.deletionTime_ != null ? other.DeletionTime.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferJob Clone() {
      return new TransferJob(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///  A globally unique name assigned by Storage Transfer Service when the
    ///  job is created. This field should be left empty in requests to create a new
    ///  transfer job; otherwise, the requests result in an `INVALID_ARGUMENT`
    ///  error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 2;
    private string description_ = "";
    /// <summary>
    ///  A description provided by the user for the job. Its max length is 1024
    ///  bytes when Unicode-encoded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 3;
    private string projectId_ = "";
    /// <summary>
    ///  The ID of the Google Cloud Platform Console project that owns the job.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "transfer_spec" field.</summary>
    public const int TransferSpecFieldNumber = 4;
    private global::Google.Storagetransfer.V1.TransferSpec transferSpec_;
    /// <summary>
    ///  Transfer specification.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferSpec TransferSpec {
      get { return transferSpec_; }
      set {
        transferSpec_ = value;
      }
    }

    /// <summary>Field number for the "schedule" field.</summary>
    public const int ScheduleFieldNumber = 5;
    private global::Google.Storagetransfer.V1.Schedule schedule_;
    /// <summary>
    ///  Schedule specification.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.Schedule Schedule {
      get { return schedule_; }
      set {
        schedule_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 6;
    private global::Google.Storagetransfer.V1.TransferJob.Types.Status status_ = 0;
    /// <summary>
    ///  Status of the job. This value MUST be specified for
    ///  `CreateTransferJobRequests`.
    ///
    ///  NOTE: The effect of the new job status takes place during a subsequent job
    ///  run. For example, if you change the job status from `ENABLED` to
    ///  `DISABLED`, and an operation spawned by the transfer is running, the status
    ///  change would not affect the current operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferJob.Types.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "creation_time" field.</summary>
    public const int CreationTimeFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp creationTime_;
    /// <summary>
    ///  This field cannot be changed by user requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreationTime {
      get { return creationTime_; }
      set {
        creationTime_ = value;
      }
    }

    /// <summary>Field number for the "last_modification_time" field.</summary>
    public const int LastModificationTimeFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Timestamp lastModificationTime_;
    /// <summary>
    ///  This field cannot be changed by user requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp LastModificationTime {
      get { return lastModificationTime_; }
      set {
        lastModificationTime_ = value;
      }
    }

    /// <summary>Field number for the "deletion_time" field.</summary>
    public const int DeletionTimeFieldNumber = 9;
    private global::Google.Protobuf.WellKnownTypes.Timestamp deletionTime_;
    /// <summary>
    ///  This field cannot be changed by user requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp DeletionTime {
      get { return deletionTime_; }
      set {
        deletionTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferJob);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferJob other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Description != other.Description) return false;
      if (ProjectId != other.ProjectId) return false;
      if (!object.Equals(TransferSpec, other.TransferSpec)) return false;
      if (!object.Equals(Schedule, other.Schedule)) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(CreationTime, other.CreationTime)) return false;
      if (!object.Equals(LastModificationTime, other.LastModificationTime)) return false;
      if (!object.Equals(DeletionTime, other.DeletionTime)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      if (transferSpec_ != null) hash ^= TransferSpec.GetHashCode();
      if (schedule_ != null) hash ^= Schedule.GetHashCode();
      if (Status != 0) hash ^= Status.GetHashCode();
      if (creationTime_ != null) hash ^= CreationTime.GetHashCode();
      if (lastModificationTime_ != null) hash ^= LastModificationTime.GetHashCode();
      if (deletionTime_ != null) hash ^= DeletionTime.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (ProjectId.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProjectId);
      }
      if (transferSpec_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TransferSpec);
      }
      if (schedule_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Schedule);
      }
      if (Status != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Status);
      }
      if (creationTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CreationTime);
      }
      if (lastModificationTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(LastModificationTime);
      }
      if (deletionTime_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(DeletionTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      if (transferSpec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransferSpec);
      }
      if (schedule_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Schedule);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (creationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreationTime);
      }
      if (lastModificationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastModificationTime);
      }
      if (deletionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeletionTime);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferJob other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      if (other.transferSpec_ != null) {
        if (transferSpec_ == null) {
          transferSpec_ = new global::Google.Storagetransfer.V1.TransferSpec();
        }
        TransferSpec.MergeFrom(other.TransferSpec);
      }
      if (other.schedule_ != null) {
        if (schedule_ == null) {
          schedule_ = new global::Google.Storagetransfer.V1.Schedule();
        }
        Schedule.MergeFrom(other.Schedule);
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.creationTime_ != null) {
        if (creationTime_ == null) {
          creationTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreationTime.MergeFrom(other.CreationTime);
      }
      if (other.lastModificationTime_ != null) {
        if (lastModificationTime_ == null) {
          lastModificationTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        LastModificationTime.MergeFrom(other.LastModificationTime);
      }
      if (other.deletionTime_ != null) {
        if (deletionTime_ == null) {
          deletionTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        DeletionTime.MergeFrom(other.DeletionTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 26: {
            ProjectId = input.ReadString();
            break;
          }
          case 34: {
            if (transferSpec_ == null) {
              transferSpec_ = new global::Google.Storagetransfer.V1.TransferSpec();
            }
            input.ReadMessage(transferSpec_);
            break;
          }
          case 42: {
            if (schedule_ == null) {
              schedule_ = new global::Google.Storagetransfer.V1.Schedule();
            }
            input.ReadMessage(schedule_);
            break;
          }
          case 48: {
            status_ = (global::Google.Storagetransfer.V1.TransferJob.Types.Status) input.ReadEnum();
            break;
          }
          case 58: {
            if (creationTime_ == null) {
              creationTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(creationTime_);
            break;
          }
          case 66: {
            if (lastModificationTime_ == null) {
              lastModificationTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(lastModificationTime_);
            break;
          }
          case 74: {
            if (deletionTime_ == null) {
              deletionTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(deletionTime_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TransferJob message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  The status of the transfer job.
      /// </summary>
      public enum Status {
        /// <summary>
        ///  Zero is an illegal value.
        /// </summary>
        [pbr::OriginalName("STATUS_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        ///  New transfers will be performed based on the schedule.
        /// </summary>
        [pbr::OriginalName("ENABLED")] Enabled = 1,
        /// <summary>
        ///  New transfers will not be scheduled.
        /// </summary>
        [pbr::OriginalName("DISABLED")] Disabled = 2,
        /// <summary>
        ///  This is a soft delete state. After a transfer job is set to this
        ///  state, the job and all the transfer executions are subject to
        ///  garbage collection.
        /// </summary>
        [pbr::OriginalName("DELETED")] Deleted = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///  An entry describing an error that has occurred.
  /// </summary>
  public sealed partial class ErrorLogEntry : pb::IMessage<ErrorLogEntry> {
    private static readonly pb::MessageParser<ErrorLogEntry> _parser = new pb::MessageParser<ErrorLogEntry>(() => new ErrorLogEntry());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ErrorLogEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorLogEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorLogEntry(ErrorLogEntry other) : this() {
      url_ = other.url_;
      errorDetails_ = other.errorDetails_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorLogEntry Clone() {
      return new ErrorLogEntry(this);
    }

    /// <summary>Field number for the "url" field.</summary>
    public const int UrlFieldNumber = 1;
    private string url_ = "";
    /// <summary>
    ///  A URL that refers to the target (a data source, a data sink,
    ///  or an object) with which the error is associated.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Url {
      get { return url_; }
      set {
        url_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "error_details" field.</summary>
    public const int ErrorDetailsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_errorDetails_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> errorDetails_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  A list of messages that carry the error details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ErrorDetails {
      get { return errorDetails_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ErrorLogEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ErrorLogEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Url != other.Url) return false;
      if(!errorDetails_.Equals(other.errorDetails_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Url.Length != 0) hash ^= Url.GetHashCode();
      hash ^= errorDetails_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Url.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Url);
      }
      errorDetails_.WriteTo(output, _repeated_errorDetails_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Url.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Url);
      }
      size += errorDetails_.CalculateSize(_repeated_errorDetails_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ErrorLogEntry other) {
      if (other == null) {
        return;
      }
      if (other.Url.Length != 0) {
        Url = other.Url;
      }
      errorDetails_.Add(other.errorDetails_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Url = input.ReadString();
            break;
          }
          case 26: {
            errorDetails_.AddEntriesFrom(input, _repeated_errorDetails_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A summary of errors by error code, plus a count and sample error log
  ///  entries.
  /// </summary>
  public sealed partial class ErrorSummary : pb::IMessage<ErrorSummary> {
    private static readonly pb::MessageParser<ErrorSummary> _parser = new pb::MessageParser<ErrorSummary>(() => new ErrorSummary());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ErrorSummary> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorSummary() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorSummary(ErrorSummary other) : this() {
      errorCode_ = other.errorCode_;
      errorCount_ = other.errorCount_;
      errorLogEntries_ = other.errorLogEntries_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorSummary Clone() {
      return new ErrorSummary(this);
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 1;
    private global::Google.Rpc.Code errorCode_ = 0;
    /// <summary>
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Rpc.Code ErrorCode {
      get { return errorCode_; }
      set {
        errorCode_ = value;
      }
    }

    /// <summary>Field number for the "error_count" field.</summary>
    public const int ErrorCountFieldNumber = 2;
    private long errorCount_;
    /// <summary>
    ///  Count of this type of error.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ErrorCount {
      get { return errorCount_; }
      set {
        errorCount_ = value;
      }
    }

    /// <summary>Field number for the "error_log_entries" field.</summary>
    public const int ErrorLogEntriesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Storagetransfer.V1.ErrorLogEntry> _repeated_errorLogEntries_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Storagetransfer.V1.ErrorLogEntry.Parser);
    private readonly pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorLogEntry> errorLogEntries_ = new pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorLogEntry>();
    /// <summary>
    ///  Error samples.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorLogEntry> ErrorLogEntries {
      get { return errorLogEntries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ErrorSummary);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ErrorSummary other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ErrorCode != other.ErrorCode) return false;
      if (ErrorCount != other.ErrorCount) return false;
      if(!errorLogEntries_.Equals(other.errorLogEntries_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ErrorCode != 0) hash ^= ErrorCode.GetHashCode();
      if (ErrorCount != 0L) hash ^= ErrorCount.GetHashCode();
      hash ^= errorLogEntries_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ErrorCode != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ErrorCode);
      }
      if (ErrorCount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(ErrorCount);
      }
      errorLogEntries_.WriteTo(output, _repeated_errorLogEntries_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ErrorCode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ErrorCode);
      }
      if (ErrorCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ErrorCount);
      }
      size += errorLogEntries_.CalculateSize(_repeated_errorLogEntries_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ErrorSummary other) {
      if (other == null) {
        return;
      }
      if (other.ErrorCode != 0) {
        ErrorCode = other.ErrorCode;
      }
      if (other.ErrorCount != 0L) {
        ErrorCount = other.ErrorCount;
      }
      errorLogEntries_.Add(other.errorLogEntries_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            errorCode_ = (global::Google.Rpc.Code) input.ReadEnum();
            break;
          }
          case 16: {
            ErrorCount = input.ReadInt64();
            break;
          }
          case 26: {
            errorLogEntries_.AddEntriesFrom(input, _repeated_errorLogEntries_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A collection of counters that report the progress of a transfer operation.
  /// </summary>
  public sealed partial class TransferCounters : pb::IMessage<TransferCounters> {
    private static readonly pb::MessageParser<TransferCounters> _parser = new pb::MessageParser<TransferCounters>(() => new TransferCounters());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferCounters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferCounters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferCounters(TransferCounters other) : this() {
      objectsFoundFromSource_ = other.objectsFoundFromSource_;
      bytesFoundFromSource_ = other.bytesFoundFromSource_;
      objectsFoundOnlyFromSink_ = other.objectsFoundOnlyFromSink_;
      bytesFoundOnlyFromSink_ = other.bytesFoundOnlyFromSink_;
      objectsFromSourceSkippedBySync_ = other.objectsFromSourceSkippedBySync_;
      bytesFromSourceSkippedBySync_ = other.bytesFromSourceSkippedBySync_;
      objectsCopiedToSink_ = other.objectsCopiedToSink_;
      bytesCopiedToSink_ = other.bytesCopiedToSink_;
      objectsDeletedFromSource_ = other.objectsDeletedFromSource_;
      bytesDeletedFromSource_ = other.bytesDeletedFromSource_;
      objectsDeletedFromSink_ = other.objectsDeletedFromSink_;
      bytesDeletedFromSink_ = other.bytesDeletedFromSink_;
      objectsFromSourceFailed_ = other.objectsFromSourceFailed_;
      bytesFromSourceFailed_ = other.bytesFromSourceFailed_;
      objectsFailedToDeleteFromSink_ = other.objectsFailedToDeleteFromSink_;
      bytesFailedToDeleteFromSink_ = other.bytesFailedToDeleteFromSink_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferCounters Clone() {
      return new TransferCounters(this);
    }

    /// <summary>Field number for the "objects_found_from_source" field.</summary>
    public const int ObjectsFoundFromSourceFieldNumber = 1;
    private long objectsFoundFromSource_;
    /// <summary>
    ///  Objects found in the data source that are scheduled to be transferred,
    ///  which will be copied, excluded based on conditions, or skipped due to
    ///  failures.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsFoundFromSource {
      get { return objectsFoundFromSource_; }
      set {
        objectsFoundFromSource_ = value;
      }
    }

    /// <summary>Field number for the "bytes_found_from_source" field.</summary>
    public const int BytesFoundFromSourceFieldNumber = 2;
    private long bytesFoundFromSource_;
    /// <summary>
    ///  Bytes found in the data source that are scheduled to be transferred,
    ///  which will be copied, excluded based on conditions, or skipped due to
    ///  failures.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesFoundFromSource {
      get { return bytesFoundFromSource_; }
      set {
        bytesFoundFromSource_ = value;
      }
    }

    /// <summary>Field number for the "objects_found_only_from_sink" field.</summary>
    public const int ObjectsFoundOnlyFromSinkFieldNumber = 3;
    private long objectsFoundOnlyFromSink_;
    /// <summary>
    ///  Objects found only in the data sink that are scheduled to be deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsFoundOnlyFromSink {
      get { return objectsFoundOnlyFromSink_; }
      set {
        objectsFoundOnlyFromSink_ = value;
      }
    }

    /// <summary>Field number for the "bytes_found_only_from_sink" field.</summary>
    public const int BytesFoundOnlyFromSinkFieldNumber = 4;
    private long bytesFoundOnlyFromSink_;
    /// <summary>
    ///  Bytes found only in the data sink that are scheduled to be deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesFoundOnlyFromSink {
      get { return bytesFoundOnlyFromSink_; }
      set {
        bytesFoundOnlyFromSink_ = value;
      }
    }

    /// <summary>Field number for the "objects_from_source_skipped_by_sync" field.</summary>
    public const int ObjectsFromSourceSkippedBySyncFieldNumber = 5;
    private long objectsFromSourceSkippedBySync_;
    /// <summary>
    ///  Objects in the data source that are not transferred because they already
    ///  exist in the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsFromSourceSkippedBySync {
      get { return objectsFromSourceSkippedBySync_; }
      set {
        objectsFromSourceSkippedBySync_ = value;
      }
    }

    /// <summary>Field number for the "bytes_from_source_skipped_by_sync" field.</summary>
    public const int BytesFromSourceSkippedBySyncFieldNumber = 6;
    private long bytesFromSourceSkippedBySync_;
    /// <summary>
    ///  Bytes in the data source that are not transferred because they already
    ///  exist in the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesFromSourceSkippedBySync {
      get { return bytesFromSourceSkippedBySync_; }
      set {
        bytesFromSourceSkippedBySync_ = value;
      }
    }

    /// <summary>Field number for the "objects_copied_to_sink" field.</summary>
    public const int ObjectsCopiedToSinkFieldNumber = 7;
    private long objectsCopiedToSink_;
    /// <summary>
    ///  Objects that are copied to the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsCopiedToSink {
      get { return objectsCopiedToSink_; }
      set {
        objectsCopiedToSink_ = value;
      }
    }

    /// <summary>Field number for the "bytes_copied_to_sink" field.</summary>
    public const int BytesCopiedToSinkFieldNumber = 8;
    private long bytesCopiedToSink_;
    /// <summary>
    ///  Bytes that are copied to the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesCopiedToSink {
      get { return bytesCopiedToSink_; }
      set {
        bytesCopiedToSink_ = value;
      }
    }

    /// <summary>Field number for the "objects_deleted_from_source" field.</summary>
    public const int ObjectsDeletedFromSourceFieldNumber = 9;
    private long objectsDeletedFromSource_;
    /// <summary>
    ///  Objects that are deleted from the data source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsDeletedFromSource {
      get { return objectsDeletedFromSource_; }
      set {
        objectsDeletedFromSource_ = value;
      }
    }

    /// <summary>Field number for the "bytes_deleted_from_source" field.</summary>
    public const int BytesDeletedFromSourceFieldNumber = 10;
    private long bytesDeletedFromSource_;
    /// <summary>
    ///  Bytes that are deleted from the data source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesDeletedFromSource {
      get { return bytesDeletedFromSource_; }
      set {
        bytesDeletedFromSource_ = value;
      }
    }

    /// <summary>Field number for the "objects_deleted_from_sink" field.</summary>
    public const int ObjectsDeletedFromSinkFieldNumber = 11;
    private long objectsDeletedFromSink_;
    /// <summary>
    ///  Objects that are deleted from the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsDeletedFromSink {
      get { return objectsDeletedFromSink_; }
      set {
        objectsDeletedFromSink_ = value;
      }
    }

    /// <summary>Field number for the "bytes_deleted_from_sink" field.</summary>
    public const int BytesDeletedFromSinkFieldNumber = 12;
    private long bytesDeletedFromSink_;
    /// <summary>
    ///  Bytes that are deleted from the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesDeletedFromSink {
      get { return bytesDeletedFromSink_; }
      set {
        bytesDeletedFromSink_ = value;
      }
    }

    /// <summary>Field number for the "objects_from_source_failed" field.</summary>
    public const int ObjectsFromSourceFailedFieldNumber = 13;
    private long objectsFromSourceFailed_;
    /// <summary>
    ///  Objects in the data source that failed during the transfer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsFromSourceFailed {
      get { return objectsFromSourceFailed_; }
      set {
        objectsFromSourceFailed_ = value;
      }
    }

    /// <summary>Field number for the "bytes_from_source_failed" field.</summary>
    public const int BytesFromSourceFailedFieldNumber = 14;
    private long bytesFromSourceFailed_;
    /// <summary>
    ///  Bytes in the data source that failed during the transfer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesFromSourceFailed {
      get { return bytesFromSourceFailed_; }
      set {
        bytesFromSourceFailed_ = value;
      }
    }

    /// <summary>Field number for the "objects_failed_to_delete_from_sink" field.</summary>
    public const int ObjectsFailedToDeleteFromSinkFieldNumber = 15;
    private long objectsFailedToDeleteFromSink_;
    /// <summary>
    ///  Objects that failed to be deleted from the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ObjectsFailedToDeleteFromSink {
      get { return objectsFailedToDeleteFromSink_; }
      set {
        objectsFailedToDeleteFromSink_ = value;
      }
    }

    /// <summary>Field number for the "bytes_failed_to_delete_from_sink" field.</summary>
    public const int BytesFailedToDeleteFromSinkFieldNumber = 16;
    private long bytesFailedToDeleteFromSink_;
    /// <summary>
    ///  Bytes that failed to be deleted from the data sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BytesFailedToDeleteFromSink {
      get { return bytesFailedToDeleteFromSink_; }
      set {
        bytesFailedToDeleteFromSink_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferCounters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferCounters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ObjectsFoundFromSource != other.ObjectsFoundFromSource) return false;
      if (BytesFoundFromSource != other.BytesFoundFromSource) return false;
      if (ObjectsFoundOnlyFromSink != other.ObjectsFoundOnlyFromSink) return false;
      if (BytesFoundOnlyFromSink != other.BytesFoundOnlyFromSink) return false;
      if (ObjectsFromSourceSkippedBySync != other.ObjectsFromSourceSkippedBySync) return false;
      if (BytesFromSourceSkippedBySync != other.BytesFromSourceSkippedBySync) return false;
      if (ObjectsCopiedToSink != other.ObjectsCopiedToSink) return false;
      if (BytesCopiedToSink != other.BytesCopiedToSink) return false;
      if (ObjectsDeletedFromSource != other.ObjectsDeletedFromSource) return false;
      if (BytesDeletedFromSource != other.BytesDeletedFromSource) return false;
      if (ObjectsDeletedFromSink != other.ObjectsDeletedFromSink) return false;
      if (BytesDeletedFromSink != other.BytesDeletedFromSink) return false;
      if (ObjectsFromSourceFailed != other.ObjectsFromSourceFailed) return false;
      if (BytesFromSourceFailed != other.BytesFromSourceFailed) return false;
      if (ObjectsFailedToDeleteFromSink != other.ObjectsFailedToDeleteFromSink) return false;
      if (BytesFailedToDeleteFromSink != other.BytesFailedToDeleteFromSink) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ObjectsFoundFromSource != 0L) hash ^= ObjectsFoundFromSource.GetHashCode();
      if (BytesFoundFromSource != 0L) hash ^= BytesFoundFromSource.GetHashCode();
      if (ObjectsFoundOnlyFromSink != 0L) hash ^= ObjectsFoundOnlyFromSink.GetHashCode();
      if (BytesFoundOnlyFromSink != 0L) hash ^= BytesFoundOnlyFromSink.GetHashCode();
      if (ObjectsFromSourceSkippedBySync != 0L) hash ^= ObjectsFromSourceSkippedBySync.GetHashCode();
      if (BytesFromSourceSkippedBySync != 0L) hash ^= BytesFromSourceSkippedBySync.GetHashCode();
      if (ObjectsCopiedToSink != 0L) hash ^= ObjectsCopiedToSink.GetHashCode();
      if (BytesCopiedToSink != 0L) hash ^= BytesCopiedToSink.GetHashCode();
      if (ObjectsDeletedFromSource != 0L) hash ^= ObjectsDeletedFromSource.GetHashCode();
      if (BytesDeletedFromSource != 0L) hash ^= BytesDeletedFromSource.GetHashCode();
      if (ObjectsDeletedFromSink != 0L) hash ^= ObjectsDeletedFromSink.GetHashCode();
      if (BytesDeletedFromSink != 0L) hash ^= BytesDeletedFromSink.GetHashCode();
      if (ObjectsFromSourceFailed != 0L) hash ^= ObjectsFromSourceFailed.GetHashCode();
      if (BytesFromSourceFailed != 0L) hash ^= BytesFromSourceFailed.GetHashCode();
      if (ObjectsFailedToDeleteFromSink != 0L) hash ^= ObjectsFailedToDeleteFromSink.GetHashCode();
      if (BytesFailedToDeleteFromSink != 0L) hash ^= BytesFailedToDeleteFromSink.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ObjectsFoundFromSource != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ObjectsFoundFromSource);
      }
      if (BytesFoundFromSource != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(BytesFoundFromSource);
      }
      if (ObjectsFoundOnlyFromSink != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ObjectsFoundOnlyFromSink);
      }
      if (BytesFoundOnlyFromSink != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(BytesFoundOnlyFromSink);
      }
      if (ObjectsFromSourceSkippedBySync != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(ObjectsFromSourceSkippedBySync);
      }
      if (BytesFromSourceSkippedBySync != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(BytesFromSourceSkippedBySync);
      }
      if (ObjectsCopiedToSink != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(ObjectsCopiedToSink);
      }
      if (BytesCopiedToSink != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(BytesCopiedToSink);
      }
      if (ObjectsDeletedFromSource != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(ObjectsDeletedFromSource);
      }
      if (BytesDeletedFromSource != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(BytesDeletedFromSource);
      }
      if (ObjectsDeletedFromSink != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(ObjectsDeletedFromSink);
      }
      if (BytesDeletedFromSink != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(BytesDeletedFromSink);
      }
      if (ObjectsFromSourceFailed != 0L) {
        output.WriteRawTag(104);
        output.WriteInt64(ObjectsFromSourceFailed);
      }
      if (BytesFromSourceFailed != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(BytesFromSourceFailed);
      }
      if (ObjectsFailedToDeleteFromSink != 0L) {
        output.WriteRawTag(120);
        output.WriteInt64(ObjectsFailedToDeleteFromSink);
      }
      if (BytesFailedToDeleteFromSink != 0L) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(BytesFailedToDeleteFromSink);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ObjectsFoundFromSource != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsFoundFromSource);
      }
      if (BytesFoundFromSource != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesFoundFromSource);
      }
      if (ObjectsFoundOnlyFromSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsFoundOnlyFromSink);
      }
      if (BytesFoundOnlyFromSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesFoundOnlyFromSink);
      }
      if (ObjectsFromSourceSkippedBySync != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsFromSourceSkippedBySync);
      }
      if (BytesFromSourceSkippedBySync != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesFromSourceSkippedBySync);
      }
      if (ObjectsCopiedToSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsCopiedToSink);
      }
      if (BytesCopiedToSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesCopiedToSink);
      }
      if (ObjectsDeletedFromSource != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsDeletedFromSource);
      }
      if (BytesDeletedFromSource != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesDeletedFromSource);
      }
      if (ObjectsDeletedFromSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsDeletedFromSink);
      }
      if (BytesDeletedFromSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesDeletedFromSink);
      }
      if (ObjectsFromSourceFailed != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsFromSourceFailed);
      }
      if (BytesFromSourceFailed != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BytesFromSourceFailed);
      }
      if (ObjectsFailedToDeleteFromSink != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObjectsFailedToDeleteFromSink);
      }
      if (BytesFailedToDeleteFromSink != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(BytesFailedToDeleteFromSink);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferCounters other) {
      if (other == null) {
        return;
      }
      if (other.ObjectsFoundFromSource != 0L) {
        ObjectsFoundFromSource = other.ObjectsFoundFromSource;
      }
      if (other.BytesFoundFromSource != 0L) {
        BytesFoundFromSource = other.BytesFoundFromSource;
      }
      if (other.ObjectsFoundOnlyFromSink != 0L) {
        ObjectsFoundOnlyFromSink = other.ObjectsFoundOnlyFromSink;
      }
      if (other.BytesFoundOnlyFromSink != 0L) {
        BytesFoundOnlyFromSink = other.BytesFoundOnlyFromSink;
      }
      if (other.ObjectsFromSourceSkippedBySync != 0L) {
        ObjectsFromSourceSkippedBySync = other.ObjectsFromSourceSkippedBySync;
      }
      if (other.BytesFromSourceSkippedBySync != 0L) {
        BytesFromSourceSkippedBySync = other.BytesFromSourceSkippedBySync;
      }
      if (other.ObjectsCopiedToSink != 0L) {
        ObjectsCopiedToSink = other.ObjectsCopiedToSink;
      }
      if (other.BytesCopiedToSink != 0L) {
        BytesCopiedToSink = other.BytesCopiedToSink;
      }
      if (other.ObjectsDeletedFromSource != 0L) {
        ObjectsDeletedFromSource = other.ObjectsDeletedFromSource;
      }
      if (other.BytesDeletedFromSource != 0L) {
        BytesDeletedFromSource = other.BytesDeletedFromSource;
      }
      if (other.ObjectsDeletedFromSink != 0L) {
        ObjectsDeletedFromSink = other.ObjectsDeletedFromSink;
      }
      if (other.BytesDeletedFromSink != 0L) {
        BytesDeletedFromSink = other.BytesDeletedFromSink;
      }
      if (other.ObjectsFromSourceFailed != 0L) {
        ObjectsFromSourceFailed = other.ObjectsFromSourceFailed;
      }
      if (other.BytesFromSourceFailed != 0L) {
        BytesFromSourceFailed = other.BytesFromSourceFailed;
      }
      if (other.ObjectsFailedToDeleteFromSink != 0L) {
        ObjectsFailedToDeleteFromSink = other.ObjectsFailedToDeleteFromSink;
      }
      if (other.BytesFailedToDeleteFromSink != 0L) {
        BytesFailedToDeleteFromSink = other.BytesFailedToDeleteFromSink;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            ObjectsFoundFromSource = input.ReadInt64();
            break;
          }
          case 16: {
            BytesFoundFromSource = input.ReadInt64();
            break;
          }
          case 24: {
            ObjectsFoundOnlyFromSink = input.ReadInt64();
            break;
          }
          case 32: {
            BytesFoundOnlyFromSink = input.ReadInt64();
            break;
          }
          case 40: {
            ObjectsFromSourceSkippedBySync = input.ReadInt64();
            break;
          }
          case 48: {
            BytesFromSourceSkippedBySync = input.ReadInt64();
            break;
          }
          case 56: {
            ObjectsCopiedToSink = input.ReadInt64();
            break;
          }
          case 64: {
            BytesCopiedToSink = input.ReadInt64();
            break;
          }
          case 72: {
            ObjectsDeletedFromSource = input.ReadInt64();
            break;
          }
          case 80: {
            BytesDeletedFromSource = input.ReadInt64();
            break;
          }
          case 88: {
            ObjectsDeletedFromSink = input.ReadInt64();
            break;
          }
          case 96: {
            BytesDeletedFromSink = input.ReadInt64();
            break;
          }
          case 104: {
            ObjectsFromSourceFailed = input.ReadInt64();
            break;
          }
          case 112: {
            BytesFromSourceFailed = input.ReadInt64();
            break;
          }
          case 120: {
            ObjectsFailedToDeleteFromSink = input.ReadInt64();
            break;
          }
          case 128: {
            BytesFailedToDeleteFromSink = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A description of the execution of a transfer.
  /// </summary>
  public sealed partial class TransferOperation : pb::IMessage<TransferOperation> {
    private static readonly pb::MessageParser<TransferOperation> _parser = new pb::MessageParser<TransferOperation>(() => new TransferOperation());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Storagetransfer.V1.TransferTypesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOperation(TransferOperation other) : this() {
      name_ = other.name_;
      projectId_ = other.projectId_;
      TransferSpec = other.transferSpec_ != null ? other.TransferSpec.Clone() : null;
      StartTime = other.startTime_ != null ? other.StartTime.Clone() : null;
      EndTime = other.endTime_ != null ? other.EndTime.Clone() : null;
      status_ = other.status_;
      Counters = other.counters_ != null ? other.Counters.Clone() : null;
      errorBreakdowns_ = other.errorBreakdowns_.Clone();
      transferJobName_ = other.transferJobName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferOperation Clone() {
      return new TransferOperation(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///  A globally unique ID assigned by the system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 2;
    private string projectId_ = "";
    /// <summary>
    ///  The ID of the Google Cloud Platform Console project that owns the operation.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "transfer_spec" field.</summary>
    public const int TransferSpecFieldNumber = 3;
    private global::Google.Storagetransfer.V1.TransferSpec transferSpec_;
    /// <summary>
    ///  Transfer specification.
    ///  Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferSpec TransferSpec {
      get { return transferSpec_; }
      set {
        transferSpec_ = value;
      }
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
    /// <summary>
    ///  Start time of this transfer execution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    ///  End time of this transfer execution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 6;
    private global::Google.Storagetransfer.V1.TransferOperation.Types.Status status_ = 0;
    /// <summary>
    ///  Status of the transfer operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferOperation.Types.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "counters" field.</summary>
    public const int CountersFieldNumber = 7;
    private global::Google.Storagetransfer.V1.TransferCounters counters_;
    /// <summary>
    ///  Information about the progress of the transfer operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Storagetransfer.V1.TransferCounters Counters {
      get { return counters_; }
      set {
        counters_ = value;
      }
    }

    /// <summary>Field number for the "error_breakdowns" field.</summary>
    public const int ErrorBreakdownsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Storagetransfer.V1.ErrorSummary> _repeated_errorBreakdowns_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Storagetransfer.V1.ErrorSummary.Parser);
    private readonly pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorSummary> errorBreakdowns_ = new pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorSummary>();
    /// <summary>
    ///  Summarizes errors encountered with sample error log entries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Storagetransfer.V1.ErrorSummary> ErrorBreakdowns {
      get { return errorBreakdowns_; }
    }

    /// <summary>Field number for the "transfer_job_name" field.</summary>
    public const int TransferJobNameFieldNumber = 9;
    private string transferJobName_ = "";
    /// <summary>
    ///  The name of the transfer job that triggers this transfer operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TransferJobName {
      get { return transferJobName_; }
      set {
        transferJobName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (ProjectId != other.ProjectId) return false;
      if (!object.Equals(TransferSpec, other.TransferSpec)) return false;
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if (!object.Equals(EndTime, other.EndTime)) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(Counters, other.Counters)) return false;
      if(!errorBreakdowns_.Equals(other.errorBreakdowns_)) return false;
      if (TransferJobName != other.TransferJobName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      if (transferSpec_ != null) hash ^= TransferSpec.GetHashCode();
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      if (Status != 0) hash ^= Status.GetHashCode();
      if (counters_ != null) hash ^= Counters.GetHashCode();
      hash ^= errorBreakdowns_.GetHashCode();
      if (TransferJobName.Length != 0) hash ^= TransferJobName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (ProjectId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProjectId);
      }
      if (transferSpec_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TransferSpec);
      }
      if (startTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(EndTime);
      }
      if (Status != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Status);
      }
      if (counters_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Counters);
      }
      errorBreakdowns_.WriteTo(output, _repeated_errorBreakdowns_codec);
      if (TransferJobName.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(TransferJobName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      if (transferSpec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransferSpec);
      }
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (counters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Counters);
      }
      size += errorBreakdowns_.CalculateSize(_repeated_errorBreakdowns_codec);
      if (TransferJobName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TransferJobName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferOperation other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      if (other.transferSpec_ != null) {
        if (transferSpec_ == null) {
          transferSpec_ = new global::Google.Storagetransfer.V1.TransferSpec();
        }
        TransferSpec.MergeFrom(other.TransferSpec);
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.counters_ != null) {
        if (counters_ == null) {
          counters_ = new global::Google.Storagetransfer.V1.TransferCounters();
        }
        Counters.MergeFrom(other.Counters);
      }
      errorBreakdowns_.Add(other.errorBreakdowns_);
      if (other.TransferJobName.Length != 0) {
        TransferJobName = other.TransferJobName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            ProjectId = input.ReadString();
            break;
          }
          case 26: {
            if (transferSpec_ == null) {
              transferSpec_ = new global::Google.Storagetransfer.V1.TransferSpec();
            }
            input.ReadMessage(transferSpec_);
            break;
          }
          case 34: {
            if (startTime_ == null) {
              startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(startTime_);
            break;
          }
          case 42: {
            if (endTime_ == null) {
              endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(endTime_);
            break;
          }
          case 48: {
            status_ = (global::Google.Storagetransfer.V1.TransferOperation.Types.Status) input.ReadEnum();
            break;
          }
          case 58: {
            if (counters_ == null) {
              counters_ = new global::Google.Storagetransfer.V1.TransferCounters();
            }
            input.ReadMessage(counters_);
            break;
          }
          case 66: {
            errorBreakdowns_.AddEntriesFrom(input, _repeated_errorBreakdowns_codec);
            break;
          }
          case 74: {
            TransferJobName = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TransferOperation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  The status of a TransferOperation.
      /// </summary>
      public enum Status {
        /// <summary>
        ///  Zero is an illegal value.
        /// </summary>
        [pbr::OriginalName("STATUS_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        ///  In progress.
        /// </summary>
        [pbr::OriginalName("IN_PROGRESS")] InProgress = 1,
        /// <summary>
        ///  Paused.
        /// </summary>
        [pbr::OriginalName("PAUSED")] Paused = 2,
        /// <summary>
        ///  Completed successfully.
        /// </summary>
        [pbr::OriginalName("SUCCESS")] Success = 3,
        /// <summary>
        ///  Terminated due to an unrecoverable failure.
        /// </summary>
        [pbr::OriginalName("FAILED")] Failed = 4,
        /// <summary>
        ///  Aborted by the user.
        /// </summary>
        [pbr::OriginalName("ABORTED")] Aborted = 5,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
