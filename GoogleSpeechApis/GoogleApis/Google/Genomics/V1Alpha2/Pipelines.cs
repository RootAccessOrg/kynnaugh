// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/genomics/v1alpha2/pipelines.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Genomics.V1Alpha2 {

  /// <summary>Holder for reflection information generated from google/genomics/v1alpha2/pipelines.proto</summary>
  public static partial class PipelinesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/genomics/v1alpha2/pipelines.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PipelinesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cihnb29nbGUvZ2Vub21pY3MvdjFhbHBoYTIvcGlwZWxpbmVzLnByb3RvEhhn",
            "b29nbGUuZ2Vub21pY3MudjFhbHBoYTIaHGdvb2dsZS9hcGkvYW5ub3RhdGlv",
            "bnMucHJvdG8aI2dvb2dsZS9sb25ncnVubmluZy9vcGVyYXRpb25zLnByb3Rv",
            "Gh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aG2dvb2dsZS9wcm90",
            "b2J1Zi9lbXB0eS5wcm90bxofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5w",
            "cm90bxoVZ29vZ2xlL3JwYy9jb2RlLnByb3RvIl4KDUNvbXB1dGVFbmdpbmUS",
            "FQoNaW5zdGFuY2VfbmFtZRgBIAEoCRIMCgR6b25lGAIgASgJEhQKDG1hY2hp",
            "bmVfdHlwZRgDIAEoCRISCgpkaXNrX25hbWVzGAQgAygJIlIKD1J1bnRpbWVN",
            "ZXRhZGF0YRI/Cg5jb21wdXRlX2VuZ2luZRgBIAEoCzInLmdvb2dsZS5nZW5v",
            "bWljcy52MWFscGhhMi5Db21wdXRlRW5naW5lIu0CCghQaXBlbGluZRISCgpw",
            "cm9qZWN0X2lkGAEgASgJEgwKBG5hbWUYAiABKAkSEwoLZGVzY3JpcHRpb24Y",
            "AyABKAkSRQoQaW5wdXRfcGFyYW1ldGVycxgIIAMoCzIrLmdvb2dsZS5nZW5v",
            "bWljcy52MWFscGhhMi5QaXBlbGluZVBhcmFtZXRlchJGChFvdXRwdXRfcGFy",
            "YW1ldGVycxgJIAMoCzIrLmdvb2dsZS5nZW5vbWljcy52MWFscGhhMi5QaXBl",
            "bGluZVBhcmFtZXRlchI6CgZkb2NrZXIYBSABKAsyKC5nb29nbGUuZ2Vub21p",
            "Y3MudjFhbHBoYTIuRG9ja2VyRXhlY3V0b3JIABI+CglyZXNvdXJjZXMYBiAB",
            "KAsyKy5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuUGlwZWxpbmVSZXNvdXJj",
            "ZXMSEwoLcGlwZWxpbmVfaWQYByABKAlCCgoIZXhlY3V0b3IiTQoVQ3JlYXRl",
            "UGlwZWxpbmVSZXF1ZXN0EjQKCHBpcGVsaW5lGAEgASgLMiIuZ29vZ2xlLmdl",
            "bm9taWNzLnYxYWxwaGEyLlBpcGVsaW5lIqsECg9SdW5QaXBlbGluZUFyZ3MS",
            "EgoKcHJvamVjdF9pZBgBIAEoCRJFCgZpbnB1dHMYAiADKAsyNS5nb29nbGUu",
            "Z2Vub21pY3MudjFhbHBoYTIuUnVuUGlwZWxpbmVBcmdzLklucHV0c0VudHJ5",
            "EkcKB291dHB1dHMYAyADKAsyNi5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIu",
            "UnVuUGlwZWxpbmVBcmdzLk91dHB1dHNFbnRyeRJBCg9zZXJ2aWNlX2FjY291",
            "bnQYBCABKAsyKC5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuU2VydmljZUFj",
            "Y291bnQSEQoJY2xpZW50X2lkGAUgASgJEj4KCXJlc291cmNlcxgGIAEoCzIr",
            "Lmdvb2dsZS5nZW5vbWljcy52MWFscGhhMi5QaXBlbGluZVJlc291cmNlcxI5",
            "Cgdsb2dnaW5nGAcgASgLMiguZ29vZ2xlLmdlbm9taWNzLnYxYWxwaGEyLkxv",
            "Z2dpbmdPcHRpb25zEkQKIWtlZXBfdm1fYWxpdmVfb25fZmFpbHVyZV9kdXJh",
            "dGlvbhgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhotCgtJbnB1",
            "dHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGi4KDE91",
            "dHB1dHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIrsB",
            "ChJSdW5QaXBlbGluZVJlcXVlc3QSFQoLcGlwZWxpbmVfaWQYASABKAlIABJA",
            "ChJlcGhlbWVyYWxfcGlwZWxpbmUYAiABKAsyIi5nb29nbGUuZ2Vub21pY3Mu",
            "djFhbHBoYTIuUGlwZWxpbmVIABJACg1waXBlbGluZV9hcmdzGAMgASgLMiku",
            "Z29vZ2xlLmdlbm9taWNzLnYxYWxwaGEyLlJ1blBpcGVsaW5lQXJnc0IKCghw",
            "aXBlbGluZSIpChJHZXRQaXBlbGluZVJlcXVlc3QSEwoLcGlwZWxpbmVfaWQY",
            "ASABKAkiZgoUTGlzdFBpcGVsaW5lc1JlcXVlc3QSEgoKcHJvamVjdF9pZBgB",
            "IAEoCRITCgtuYW1lX3ByZWZpeBgCIAEoCRIRCglwYWdlX3NpemUYAyABKAUS",
            "EgoKcGFnZV90b2tlbhgEIAEoCSJnChVMaXN0UGlwZWxpbmVzUmVzcG9uc2US",
            "NQoJcGlwZWxpbmVzGAEgAygLMiIuZ29vZ2xlLmdlbm9taWNzLnYxYWxwaGEy",
            "LlBpcGVsaW5lEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSIsChVEZWxldGVQ",
            "aXBlbGluZVJlcXVlc3QSEwoLcGlwZWxpbmVfaWQYASABKAkiTAoaR2V0Q29u",
            "dHJvbGxlckNvbmZpZ1JlcXVlc3QSFAoMb3BlcmF0aW9uX2lkGAEgASgJEhgK",
            "EHZhbGlkYXRpb25fdG9rZW4YAiABKAQi2QUKEENvbnRyb2xsZXJDb25maWcS",
            "DQoFaW1hZ2UYASABKAkSCwoDY21kGAIgASgJEhQKDGdjc19sb2dfcGF0aBgD",
            "IAEoCRIUCgxtYWNoaW5lX3R5cGUYBCABKAkSQgoEdmFycxgFIAMoCzI0Lmdv",
            "b2dsZS5nZW5vbWljcy52MWFscGhhMi5Db250cm9sbGVyQ29uZmlnLlZhcnNF",
            "bnRyeRJECgVkaXNrcxgGIAMoCzI1Lmdvb2dsZS5nZW5vbWljcy52MWFscGhh",
            "Mi5Db250cm9sbGVyQ29uZmlnLkRpc2tzRW50cnkSTwoLZ2NzX3NvdXJjZXMY",
            "ByADKAsyOi5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuQ29udHJvbGxlckNv",
            "bmZpZy5HY3NTb3VyY2VzRW50cnkSSwoJZ2NzX3NpbmtzGAggAygLMjguZ29v",
            "Z2xlLmdlbm9taWNzLnYxYWxwaGEyLkNvbnRyb2xsZXJDb25maWcuR2NzU2lu",
            "a3NFbnRyeRogCg5SZXBlYXRlZFN0cmluZxIOCgZ2YWx1ZXMYASADKAkaKwoJ",
            "VmFyc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaLAoK",
            "RGlza3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGmwK",
            "D0djc1NvdXJjZXNFbnRyeRILCgNrZXkYASABKAkSSAoFdmFsdWUYAiABKAsy",
            "OS5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuQ29udHJvbGxlckNvbmZpZy5S",
            "ZXBlYXRlZFN0cmluZzoCOAEaagoNR2NzU2lua3NFbnRyeRILCgNrZXkYASAB",
            "KAkSSAoFdmFsdWUYAiABKAsyOS5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIu",
            "Q29udHJvbGxlckNvbmZpZy5SZXBlYXRlZFN0cmluZzoCOAEiVAoOVGltZXN0",
            "YW1wRXZlbnQSEwoLZGVzY3JpcHRpb24YASABKAkSLQoJdGltZXN0YW1wGAIg",
            "ASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCLMAQoZU2V0T3BlcmF0",
            "aW9uU3RhdHVzUmVxdWVzdBIUCgxvcGVyYXRpb25faWQYASABKAkSQgoQdGlt",
            "ZXN0YW1wX2V2ZW50cxgCIAMoCzIoLmdvb2dsZS5nZW5vbWljcy52MWFscGhh",
            "Mi5UaW1lc3RhbXBFdmVudBIkCgplcnJvcl9jb2RlGAMgASgOMhAuZ29vZ2xl",
            "LnJwYy5Db2RlEhUKDWVycm9yX21lc3NhZ2UYBCABKAkSGAoQdmFsaWRhdGlv",
            "bl90b2tlbhgFIAEoBCIvCg5TZXJ2aWNlQWNjb3VudBINCgVlbWFpbBgBIAEo",
            "CRIOCgZzY29wZXMYAiADKAkiIgoOTG9nZ2luZ09wdGlvbnMSEAoIZ2NzX3Bh",
            "dGgYASABKAki1QMKEVBpcGVsaW5lUmVzb3VyY2VzEhkKEW1pbmltdW1fY3B1",
            "X2NvcmVzGAEgASgFEhMKC3ByZWVtcHRpYmxlGAIgASgIEhYKDm1pbmltdW1f",
            "cmFtX2diGAMgASgBEj8KBWRpc2tzGAQgAygLMjAuZ29vZ2xlLmdlbm9taWNz",
            "LnYxYWxwaGEyLlBpcGVsaW5lUmVzb3VyY2VzLkRpc2sSDQoFem9uZXMYBSAD",
            "KAkSGQoRYm9vdF9kaXNrX3NpemVfZ2IYBiABKAUajAIKBERpc2sSDAoEbmFt",
            "ZRgBIAEoCRJDCgR0eXBlGAIgASgOMjUuZ29vZ2xlLmdlbm9taWNzLnYxYWxw",
            "aGEyLlBpcGVsaW5lUmVzb3VyY2VzLkRpc2suVHlwZRIPCgdzaXplX2diGAMg",
            "ASgFEg4KBnNvdXJjZRgEIAEoCRITCgthdXRvX2RlbGV0ZRgGIAEoCBIRCgly",
            "ZWFkX29ubHkYByABKAgSEwoLbW91bnRfcG9pbnQYCCABKAkiUwoEVHlwZRIU",
            "ChBUWVBFX1VOU1BFQ0lGSUVEEAASEgoOUEVSU0lTVEVOVF9IREQQARISCg5Q",
            "RVJTSVNURU5UX1NTRBACEg0KCUxPQ0FMX1NTRBADIsEBChFQaXBlbGluZVBh",
            "cmFtZXRlchIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIgASgJEhUK",
            "DWRlZmF1bHRfdmFsdWUYBSABKAkSSQoKbG9jYWxfY29weRgGIAEoCzI1Lmdv",
            "b2dsZS5nZW5vbWljcy52MWFscGhhMi5QaXBlbGluZVBhcmFtZXRlci5Mb2Nh",
            "bENvcHkaJwoJTG9jYWxDb3B5EgwKBHBhdGgYASABKAkSDAoEZGlzaxgCIAEo",
            "CSIxCg5Eb2NrZXJFeGVjdXRvchISCgppbWFnZV9uYW1lGAEgASgJEgsKA2Nt",
            "ZBgCIAEoCTKICAoRUGlwZWxpbmVzVjFBbHBoYTISjAEKDkNyZWF0ZVBpcGVs",
            "aW5lEi8uZ29vZ2xlLmdlbm9taWNzLnYxYWxwaGEyLkNyZWF0ZVBpcGVsaW5l",
            "UmVxdWVzdBoiLmdvb2dsZS5nZW5vbWljcy52MWFscGhhMi5QaXBlbGluZSIl",
            "gtPkkwIfIhMvdjFhbHBoYTIvcGlwZWxpbmVzOghwaXBlbGluZRJ+CgtSdW5Q",
            "aXBlbGluZRIsLmdvb2dsZS5nZW5vbWljcy52MWFscGhhMi5SdW5QaXBlbGlu",
            "ZVJlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIiKC0+ST",
            "AhwiFy92MWFscGhhMi9waXBlbGluZXM6cnVuOgEqEooBCgtHZXRQaXBlbGlu",
            "ZRIsLmdvb2dsZS5nZW5vbWljcy52MWFscGhhMi5HZXRQaXBlbGluZVJlcXVl",
            "c3QaIi5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuUGlwZWxpbmUiKYLT5JMC",
            "IxIhL3YxYWxwaGEyL3BpcGVsaW5lcy97cGlwZWxpbmVfaWR9Eo0BCg1MaXN0",
            "UGlwZWxpbmVzEi4uZ29vZ2xlLmdlbm9taWNzLnYxYWxwaGEyLkxpc3RQaXBl",
            "bGluZXNSZXF1ZXN0Gi8uZ29vZ2xlLmdlbm9taWNzLnYxYWxwaGEyLkxpc3RQ",
            "aXBlbGluZXNSZXNwb25zZSIbgtPkkwIVEhMvdjFhbHBoYTIvcGlwZWxpbmVz",
            "EoQBCg5EZWxldGVQaXBlbGluZRIvLmdvb2dsZS5nZW5vbWljcy52MWFscGhh",
            "Mi5EZWxldGVQaXBlbGluZVJlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1w",
            "dHkiKYLT5JMCIyohL3YxYWxwaGEyL3BpcGVsaW5lcy97cGlwZWxpbmVfaWR9",
            "EqgBChNHZXRDb250cm9sbGVyQ29uZmlnEjQuZ29vZ2xlLmdlbm9taWNzLnYx",
            "YWxwaGEyLkdldENvbnRyb2xsZXJDb25maWdSZXF1ZXN0GiouZ29vZ2xlLmdl",
            "bm9taWNzLnYxYWxwaGEyLkNvbnRyb2xsZXJDb25maWciL4LT5JMCKRInL3Yx",
            "YWxwaGEyL3BpcGVsaW5lczpnZXRDb250cm9sbGVyQ29uZmlnEpQBChJTZXRP",
            "cGVyYXRpb25TdGF0dXMSMy5nb29nbGUuZ2Vub21pY3MudjFhbHBoYTIuU2V0",
            "T3BlcmF0aW9uU3RhdHVzUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0",
            "eSIxgtPkkwIrGiYvdjFhbHBoYTIvcGlwZWxpbmVzOnNldE9wZXJhdGlvblN0",
            "YXR1czoBKkJwChdjb20uZ29vZ2xlLmdlbm9taWNzLnYxYUIOUGlwZWxpbmVz",
            "UHJvdG9QAVpAZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBp",
            "cy9nZW5vbWljcy92MWFscGhhMjtnZW5vbWljc/gBAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.LongRunning.OperationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.EmptyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Rpc.CodeReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ComputeEngine), global::Google.Genomics.V1Alpha2.ComputeEngine.Parser, new[]{ "InstanceName", "Zone", "MachineType", "DiskNames" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.RuntimeMetadata), global::Google.Genomics.V1Alpha2.RuntimeMetadata.Parser, new[]{ "ComputeEngine" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.Pipeline), global::Google.Genomics.V1Alpha2.Pipeline.Parser, new[]{ "ProjectId", "Name", "Description", "InputParameters", "OutputParameters", "Docker", "Resources", "PipelineId" }, new[]{ "Executor" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.CreatePipelineRequest), global::Google.Genomics.V1Alpha2.CreatePipelineRequest.Parser, new[]{ "Pipeline" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.RunPipelineArgs), global::Google.Genomics.V1Alpha2.RunPipelineArgs.Parser, new[]{ "ProjectId", "Inputs", "Outputs", "ServiceAccount", "ClientId", "Resources", "Logging", "KeepVmAliveOnFailureDuration" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.RunPipelineRequest), global::Google.Genomics.V1Alpha2.RunPipelineRequest.Parser, new[]{ "PipelineId", "EphemeralPipeline", "PipelineArgs" }, new[]{ "Pipeline" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.GetPipelineRequest), global::Google.Genomics.V1Alpha2.GetPipelineRequest.Parser, new[]{ "PipelineId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ListPipelinesRequest), global::Google.Genomics.V1Alpha2.ListPipelinesRequest.Parser, new[]{ "ProjectId", "NamePrefix", "PageSize", "PageToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ListPipelinesResponse), global::Google.Genomics.V1Alpha2.ListPipelinesResponse.Parser, new[]{ "Pipelines", "NextPageToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.DeletePipelineRequest), global::Google.Genomics.V1Alpha2.DeletePipelineRequest.Parser, new[]{ "PipelineId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.GetControllerConfigRequest), global::Google.Genomics.V1Alpha2.GetControllerConfigRequest.Parser, new[]{ "OperationId", "ValidationToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ControllerConfig), global::Google.Genomics.V1Alpha2.ControllerConfig.Parser, new[]{ "Image", "Cmd", "GcsLogPath", "MachineType", "Vars", "Disks", "GcsSources", "GcsSinks" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString), global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString.Parser, new[]{ "Values" }, null, null, null),
            null, null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.TimestampEvent), global::Google.Genomics.V1Alpha2.TimestampEvent.Parser, new[]{ "Description", "Timestamp" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.SetOperationStatusRequest), global::Google.Genomics.V1Alpha2.SetOperationStatusRequest.Parser, new[]{ "OperationId", "TimestampEvents", "ErrorCode", "ErrorMessage", "ValidationToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.ServiceAccount), global::Google.Genomics.V1Alpha2.ServiceAccount.Parser, new[]{ "Email", "Scopes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.LoggingOptions), global::Google.Genomics.V1Alpha2.LoggingOptions.Parser, new[]{ "GcsPath" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.PipelineResources), global::Google.Genomics.V1Alpha2.PipelineResources.Parser, new[]{ "MinimumCpuCores", "Preemptible", "MinimumRamGb", "Disks", "Zones", "BootDiskSizeGb" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk), global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Parser, new[]{ "Name", "Type", "SizeGb", "Source", "AutoDelete", "ReadOnly", "MountPoint" }, null, new[]{ typeof(global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Types.Type) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.PipelineParameter), global::Google.Genomics.V1Alpha2.PipelineParameter.Parser, new[]{ "Name", "Description", "DefaultValue", "LocalCopy" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy), global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy.Parser, new[]{ "Path", "Disk" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Genomics.V1Alpha2.DockerExecutor), global::Google.Genomics.V1Alpha2.DockerExecutor.Parser, new[]{ "ImageName", "Cmd" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  Describes a Compute Engine resource that is being managed by a running
  ///  [pipeline][google.genomics.v1alpha2.Pipeline].
  /// </summary>
  public sealed partial class ComputeEngine : pb::IMessage<ComputeEngine> {
    private static readonly pb::MessageParser<ComputeEngine> _parser = new pb::MessageParser<ComputeEngine>(() => new ComputeEngine());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ComputeEngine> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputeEngine() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputeEngine(ComputeEngine other) : this() {
      instanceName_ = other.instanceName_;
      zone_ = other.zone_;
      machineType_ = other.machineType_;
      diskNames_ = other.diskNames_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ComputeEngine Clone() {
      return new ComputeEngine(this);
    }

    /// <summary>Field number for the "instance_name" field.</summary>
    public const int InstanceNameFieldNumber = 1;
    private string instanceName_ = "";
    /// <summary>
    ///  The instance on which the operation is running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string InstanceName {
      get { return instanceName_; }
      set {
        instanceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "zone" field.</summary>
    public const int ZoneFieldNumber = 2;
    private string zone_ = "";
    /// <summary>
    ///  The availability zone in which the instance resides.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Zone {
      get { return zone_; }
      set {
        zone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 3;
    private string machineType_ = "";
    /// <summary>
    ///  The machine type of the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disk_names" field.</summary>
    public const int DiskNamesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_diskNames_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> diskNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  The names of the disks that were created for this pipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> DiskNames {
      get { return diskNames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ComputeEngine);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ComputeEngine other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InstanceName != other.InstanceName) return false;
      if (Zone != other.Zone) return false;
      if (MachineType != other.MachineType) return false;
      if(!diskNames_.Equals(other.diskNames_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (InstanceName.Length != 0) hash ^= InstanceName.GetHashCode();
      if (Zone.Length != 0) hash ^= Zone.GetHashCode();
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      hash ^= diskNames_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (InstanceName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(InstanceName);
      }
      if (Zone.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Zone);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MachineType);
      }
      diskNames_.WriteTo(output, _repeated_diskNames_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (InstanceName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(InstanceName);
      }
      if (Zone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Zone);
      }
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      size += diskNames_.CalculateSize(_repeated_diskNames_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ComputeEngine other) {
      if (other == null) {
        return;
      }
      if (other.InstanceName.Length != 0) {
        InstanceName = other.InstanceName;
      }
      if (other.Zone.Length != 0) {
        Zone = other.Zone;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      diskNames_.Add(other.diskNames_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            InstanceName = input.ReadString();
            break;
          }
          case 18: {
            Zone = input.ReadString();
            break;
          }
          case 26: {
            MachineType = input.ReadString();
            break;
          }
          case 34: {
            diskNames_.AddEntriesFrom(input, _repeated_diskNames_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Runtime metadata that will be populated in the
  ///  [runtimeMetadata][google.genomics.v1.OperationMetadata.runtime_metadata]
  ///  field of the Operation associated with a RunPipeline execution.
  /// </summary>
  public sealed partial class RuntimeMetadata : pb::IMessage<RuntimeMetadata> {
    private static readonly pb::MessageParser<RuntimeMetadata> _parser = new pb::MessageParser<RuntimeMetadata>(() => new RuntimeMetadata());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RuntimeMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuntimeMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuntimeMetadata(RuntimeMetadata other) : this() {
      ComputeEngine = other.computeEngine_ != null ? other.ComputeEngine.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuntimeMetadata Clone() {
      return new RuntimeMetadata(this);
    }

    /// <summary>Field number for the "compute_engine" field.</summary>
    public const int ComputeEngineFieldNumber = 1;
    private global::Google.Genomics.V1Alpha2.ComputeEngine computeEngine_;
    /// <summary>
    ///  Execution information specific to Google Compute Engine.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.ComputeEngine ComputeEngine {
      get { return computeEngine_; }
      set {
        computeEngine_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RuntimeMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RuntimeMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ComputeEngine, other.ComputeEngine)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (computeEngine_ != null) hash ^= ComputeEngine.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (computeEngine_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ComputeEngine);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (computeEngine_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ComputeEngine);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RuntimeMetadata other) {
      if (other == null) {
        return;
      }
      if (other.computeEngine_ != null) {
        if (computeEngine_ == null) {
          computeEngine_ = new global::Google.Genomics.V1Alpha2.ComputeEngine();
        }
        ComputeEngine.MergeFrom(other.ComputeEngine);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (computeEngine_ == null) {
              computeEngine_ = new global::Google.Genomics.V1Alpha2.ComputeEngine();
            }
            input.ReadMessage(computeEngine_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The pipeline object. Represents a transformation from a set of input
  ///  parameters to a set of output parameters. The transformation is defined
  ///  as a docker image and command to run within that image. Each pipeline
  ///  is run on a Google Compute Engine VM. A pipeline can be created with the
  ///  `create` method and then later run with the `run` method, or a pipeline can
  ///  be defined and run all at once with the `run` method.
  /// </summary>
  public sealed partial class Pipeline : pb::IMessage<Pipeline> {
    private static readonly pb::MessageParser<Pipeline> _parser = new pb::MessageParser<Pipeline>(() => new Pipeline());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Pipeline> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipeline() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipeline(Pipeline other) : this() {
      projectId_ = other.projectId_;
      name_ = other.name_;
      description_ = other.description_;
      inputParameters_ = other.inputParameters_.Clone();
      outputParameters_ = other.outputParameters_.Clone();
      Resources = other.resources_ != null ? other.Resources.Clone() : null;
      pipelineId_ = other.pipelineId_;
      switch (other.ExecutorCase) {
        case ExecutorOneofCase.Docker:
          Docker = other.Docker.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipeline Clone() {
      return new Pipeline(this);
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 1;
    private string projectId_ = "";
    /// <summary>
    ///  Required. The project in which to create the pipeline. The caller must have
    ///  WRITE access.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    ///  Required. A user specified pipeline name that does not have to be unique.
    ///  This name can be used for filtering Pipelines in ListPipelines.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 3;
    private string description_ = "";
    /// <summary>
    ///  User-specified description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input_parameters" field.</summary>
    public const int InputParametersFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Genomics.V1Alpha2.PipelineParameter> _repeated_inputParameters_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Genomics.V1Alpha2.PipelineParameter.Parser);
    private readonly pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter> inputParameters_ = new pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter>();
    /// <summary>
    ///  Input parameters of the pipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter> InputParameters {
      get { return inputParameters_; }
    }

    /// <summary>Field number for the "output_parameters" field.</summary>
    public const int OutputParametersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Genomics.V1Alpha2.PipelineParameter> _repeated_outputParameters_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Genomics.V1Alpha2.PipelineParameter.Parser);
    private readonly pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter> outputParameters_ = new pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter>();
    /// <summary>
    ///  Output parameters of the pipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineParameter> OutputParameters {
      get { return outputParameters_; }
    }

    /// <summary>Field number for the "docker" field.</summary>
    public const int DockerFieldNumber = 5;
    /// <summary>
    ///  Specifies the docker run information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.DockerExecutor Docker {
      get { return executorCase_ == ExecutorOneofCase.Docker ? (global::Google.Genomics.V1Alpha2.DockerExecutor) executor_ : null; }
      set {
        executor_ = value;
        executorCase_ = value == null ? ExecutorOneofCase.None : ExecutorOneofCase.Docker;
      }
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 6;
    private global::Google.Genomics.V1Alpha2.PipelineResources resources_;
    /// <summary>
    ///  Required. Specifies resource requirements for the pipeline run.
    ///  Required fields:
    ///
    ///  *
    ///  [minimumCpuCores][google.genomics.v1alpha2.PipelineResources.minimum_cpu_cores]
    ///
    ///  *
    ///  [minimumRamGb][google.genomics.v1alpha2.PipelineResources.minimum_ram_gb]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.PipelineResources Resources {
      get { return resources_; }
      set {
        resources_ = value;
      }
    }

    /// <summary>Field number for the "pipeline_id" field.</summary>
    public const int PipelineIdFieldNumber = 7;
    private string pipelineId_ = "";
    /// <summary>
    ///  Unique pipeline id that is generated by the service when CreatePipeline
    ///  is called. Cannot be specified in the Pipeline used in the
    ///  CreatePipelineRequest, and will be populated in the response to
    ///  CreatePipeline and all subsequent Get and List calls. Indicates that the
    ///  service has registered this pipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PipelineId {
      get { return pipelineId_; }
      set {
        pipelineId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object executor_;
    /// <summary>Enum of possible cases for the "executor" oneof.</summary>
    public enum ExecutorOneofCase {
      None = 0,
      Docker = 5,
    }
    private ExecutorOneofCase executorCase_ = ExecutorOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExecutorOneofCase ExecutorCase {
      get { return executorCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExecutor() {
      executorCase_ = ExecutorOneofCase.None;
      executor_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Pipeline);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Pipeline other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProjectId != other.ProjectId) return false;
      if (Name != other.Name) return false;
      if (Description != other.Description) return false;
      if(!inputParameters_.Equals(other.inputParameters_)) return false;
      if(!outputParameters_.Equals(other.outputParameters_)) return false;
      if (!object.Equals(Docker, other.Docker)) return false;
      if (!object.Equals(Resources, other.Resources)) return false;
      if (PipelineId != other.PipelineId) return false;
      if (ExecutorCase != other.ExecutorCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      hash ^= inputParameters_.GetHashCode();
      hash ^= outputParameters_.GetHashCode();
      if (executorCase_ == ExecutorOneofCase.Docker) hash ^= Docker.GetHashCode();
      if (resources_ != null) hash ^= Resources.GetHashCode();
      if (PipelineId.Length != 0) hash ^= PipelineId.GetHashCode();
      hash ^= (int) executorCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProjectId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProjectId);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Description);
      }
      if (executorCase_ == ExecutorOneofCase.Docker) {
        output.WriteRawTag(42);
        output.WriteMessage(Docker);
      }
      if (resources_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Resources);
      }
      if (PipelineId.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(PipelineId);
      }
      inputParameters_.WriteTo(output, _repeated_inputParameters_codec);
      outputParameters_.WriteTo(output, _repeated_outputParameters_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      size += inputParameters_.CalculateSize(_repeated_inputParameters_codec);
      size += outputParameters_.CalculateSize(_repeated_outputParameters_codec);
      if (executorCase_ == ExecutorOneofCase.Docker) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Docker);
      }
      if (resources_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resources);
      }
      if (PipelineId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PipelineId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Pipeline other) {
      if (other == null) {
        return;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      inputParameters_.Add(other.inputParameters_);
      outputParameters_.Add(other.outputParameters_);
      if (other.resources_ != null) {
        if (resources_ == null) {
          resources_ = new global::Google.Genomics.V1Alpha2.PipelineResources();
        }
        Resources.MergeFrom(other.Resources);
      }
      if (other.PipelineId.Length != 0) {
        PipelineId = other.PipelineId;
      }
      switch (other.ExecutorCase) {
        case ExecutorOneofCase.Docker:
          Docker = other.Docker;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ProjectId = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Description = input.ReadString();
            break;
          }
          case 42: {
            global::Google.Genomics.V1Alpha2.DockerExecutor subBuilder = new global::Google.Genomics.V1Alpha2.DockerExecutor();
            if (executorCase_ == ExecutorOneofCase.Docker) {
              subBuilder.MergeFrom(Docker);
            }
            input.ReadMessage(subBuilder);
            Docker = subBuilder;
            break;
          }
          case 50: {
            if (resources_ == null) {
              resources_ = new global::Google.Genomics.V1Alpha2.PipelineResources();
            }
            input.ReadMessage(resources_);
            break;
          }
          case 58: {
            PipelineId = input.ReadString();
            break;
          }
          case 66: {
            inputParameters_.AddEntriesFrom(input, _repeated_inputParameters_codec);
            break;
          }
          case 74: {
            outputParameters_.AddEntriesFrom(input, _repeated_outputParameters_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The request to create a pipeline. The pipeline field here should not have
  ///  `pipelineId` populated, as that will be populated by the server.
  /// </summary>
  public sealed partial class CreatePipelineRequest : pb::IMessage<CreatePipelineRequest> {
    private static readonly pb::MessageParser<CreatePipelineRequest> _parser = new pb::MessageParser<CreatePipelineRequest>(() => new CreatePipelineRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreatePipelineRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreatePipelineRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreatePipelineRequest(CreatePipelineRequest other) : this() {
      Pipeline = other.pipeline_ != null ? other.Pipeline.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreatePipelineRequest Clone() {
      return new CreatePipelineRequest(this);
    }

    /// <summary>Field number for the "pipeline" field.</summary>
    public const int PipelineFieldNumber = 1;
    private global::Google.Genomics.V1Alpha2.Pipeline pipeline_;
    /// <summary>
    ///  The pipeline to create. Should not have `pipelineId` populated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.Pipeline Pipeline {
      get { return pipeline_; }
      set {
        pipeline_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreatePipelineRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreatePipelineRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Pipeline, other.Pipeline)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pipeline_ != null) hash ^= Pipeline.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pipeline_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Pipeline);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pipeline_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pipeline);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreatePipelineRequest other) {
      if (other == null) {
        return;
      }
      if (other.pipeline_ != null) {
        if (pipeline_ == null) {
          pipeline_ = new global::Google.Genomics.V1Alpha2.Pipeline();
        }
        Pipeline.MergeFrom(other.Pipeline);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (pipeline_ == null) {
              pipeline_ = new global::Google.Genomics.V1Alpha2.Pipeline();
            }
            input.ReadMessage(pipeline_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The pipeline run arguments.
  /// </summary>
  public sealed partial class RunPipelineArgs : pb::IMessage<RunPipelineArgs> {
    private static readonly pb::MessageParser<RunPipelineArgs> _parser = new pb::MessageParser<RunPipelineArgs>(() => new RunPipelineArgs());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RunPipelineArgs> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineArgs() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineArgs(RunPipelineArgs other) : this() {
      projectId_ = other.projectId_;
      inputs_ = other.inputs_.Clone();
      outputs_ = other.outputs_.Clone();
      ServiceAccount = other.serviceAccount_ != null ? other.ServiceAccount.Clone() : null;
      clientId_ = other.clientId_;
      Resources = other.resources_ != null ? other.Resources.Clone() : null;
      Logging = other.logging_ != null ? other.Logging.Clone() : null;
      KeepVmAliveOnFailureDuration = other.keepVmAliveOnFailureDuration_ != null ? other.KeepVmAliveOnFailureDuration.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineArgs Clone() {
      return new RunPipelineArgs(this);
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 1;
    private string projectId_ = "";
    /// <summary>
    ///  Required. The project in which to run the pipeline. The caller must have
    ///  WRITER access to all Google Cloud services and resources (e.g. Google
    ///  Compute Engine) will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_inputs_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> inputs_ = new pbc::MapField<string, string>();
    /// <summary>
    ///  Pipeline input arguments; keys are defined in the pipeline documentation.
    ///  All input parameters that do not have default values  must be specified.
    ///  If parameters with defaults are specified here, the defaults will be
    ///  overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Inputs {
      get { return inputs_; }
    }

    /// <summary>Field number for the "outputs" field.</summary>
    public const int OutputsFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_outputs_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
    private readonly pbc::MapField<string, string> outputs_ = new pbc::MapField<string, string>();
    /// <summary>
    ///  Pipeline output arguments; keys are defined in the pipeline
    ///  documentation.  All output parameters of without default values
    ///  must be specified.  If parameters with defaults are specified
    ///  here, the defaults will be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Outputs {
      get { return outputs_; }
    }

    /// <summary>Field number for the "service_account" field.</summary>
    public const int ServiceAccountFieldNumber = 4;
    private global::Google.Genomics.V1Alpha2.ServiceAccount serviceAccount_;
    /// <summary>
    ///  The Google Cloud Service Account that will be used to access data and
    ///  services. By default, the compute service account associated with
    ///  `projectId` is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.ServiceAccount ServiceAccount {
      get { return serviceAccount_; }
      set {
        serviceAccount_ = value;
      }
    }

    /// <summary>Field number for the "client_id" field.</summary>
    public const int ClientIdFieldNumber = 5;
    private string clientId_ = "";
    /// <summary>
    ///  Client-specified pipeline operation identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClientId {
      get { return clientId_; }
      set {
        clientId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 6;
    private global::Google.Genomics.V1Alpha2.PipelineResources resources_;
    /// <summary>
    ///  Specifies resource requirements/overrides for the pipeline run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.PipelineResources Resources {
      get { return resources_; }
      set {
        resources_ = value;
      }
    }

    /// <summary>Field number for the "logging" field.</summary>
    public const int LoggingFieldNumber = 7;
    private global::Google.Genomics.V1Alpha2.LoggingOptions logging_;
    /// <summary>
    ///  Required. Logging options. Used by the service to communicate results
    ///  to the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.LoggingOptions Logging {
      get { return logging_; }
      set {
        logging_ = value;
      }
    }

    /// <summary>Field number for the "keep_vm_alive_on_failure_duration" field.</summary>
    public const int KeepVmAliveOnFailureDurationFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration keepVmAliveOnFailureDuration_;
    /// <summary>
    ///  How long to keep the VM up after a failure (for example docker command
    ///  failed, copying input or output files failed, etc). While the VM is up, one
    ///  can ssh into the VM to debug. Default is 0; maximum allowed value is 1 day.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration KeepVmAliveOnFailureDuration {
      get { return keepVmAliveOnFailureDuration_; }
      set {
        keepVmAliveOnFailureDuration_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RunPipelineArgs);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RunPipelineArgs other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProjectId != other.ProjectId) return false;
      if (!Inputs.Equals(other.Inputs)) return false;
      if (!Outputs.Equals(other.Outputs)) return false;
      if (!object.Equals(ServiceAccount, other.ServiceAccount)) return false;
      if (ClientId != other.ClientId) return false;
      if (!object.Equals(Resources, other.Resources)) return false;
      if (!object.Equals(Logging, other.Logging)) return false;
      if (!object.Equals(KeepVmAliveOnFailureDuration, other.KeepVmAliveOnFailureDuration)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      hash ^= Inputs.GetHashCode();
      hash ^= Outputs.GetHashCode();
      if (serviceAccount_ != null) hash ^= ServiceAccount.GetHashCode();
      if (ClientId.Length != 0) hash ^= ClientId.GetHashCode();
      if (resources_ != null) hash ^= Resources.GetHashCode();
      if (logging_ != null) hash ^= Logging.GetHashCode();
      if (keepVmAliveOnFailureDuration_ != null) hash ^= KeepVmAliveOnFailureDuration.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProjectId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProjectId);
      }
      inputs_.WriteTo(output, _map_inputs_codec);
      outputs_.WriteTo(output, _map_outputs_codec);
      if (serviceAccount_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ServiceAccount);
      }
      if (ClientId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ClientId);
      }
      if (resources_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Resources);
      }
      if (logging_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Logging);
      }
      if (keepVmAliveOnFailureDuration_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(KeepVmAliveOnFailureDuration);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      size += inputs_.CalculateSize(_map_inputs_codec);
      size += outputs_.CalculateSize(_map_outputs_codec);
      if (serviceAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServiceAccount);
      }
      if (ClientId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClientId);
      }
      if (resources_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resources);
      }
      if (logging_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Logging);
      }
      if (keepVmAliveOnFailureDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeepVmAliveOnFailureDuration);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RunPipelineArgs other) {
      if (other == null) {
        return;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      inputs_.Add(other.inputs_);
      outputs_.Add(other.outputs_);
      if (other.serviceAccount_ != null) {
        if (serviceAccount_ == null) {
          serviceAccount_ = new global::Google.Genomics.V1Alpha2.ServiceAccount();
        }
        ServiceAccount.MergeFrom(other.ServiceAccount);
      }
      if (other.ClientId.Length != 0) {
        ClientId = other.ClientId;
      }
      if (other.resources_ != null) {
        if (resources_ == null) {
          resources_ = new global::Google.Genomics.V1Alpha2.PipelineResources();
        }
        Resources.MergeFrom(other.Resources);
      }
      if (other.logging_ != null) {
        if (logging_ == null) {
          logging_ = new global::Google.Genomics.V1Alpha2.LoggingOptions();
        }
        Logging.MergeFrom(other.Logging);
      }
      if (other.keepVmAliveOnFailureDuration_ != null) {
        if (keepVmAliveOnFailureDuration_ == null) {
          keepVmAliveOnFailureDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        KeepVmAliveOnFailureDuration.MergeFrom(other.KeepVmAliveOnFailureDuration);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ProjectId = input.ReadString();
            break;
          }
          case 18: {
            inputs_.AddEntriesFrom(input, _map_inputs_codec);
            break;
          }
          case 26: {
            outputs_.AddEntriesFrom(input, _map_outputs_codec);
            break;
          }
          case 34: {
            if (serviceAccount_ == null) {
              serviceAccount_ = new global::Google.Genomics.V1Alpha2.ServiceAccount();
            }
            input.ReadMessage(serviceAccount_);
            break;
          }
          case 42: {
            ClientId = input.ReadString();
            break;
          }
          case 50: {
            if (resources_ == null) {
              resources_ = new global::Google.Genomics.V1Alpha2.PipelineResources();
            }
            input.ReadMessage(resources_);
            break;
          }
          case 58: {
            if (logging_ == null) {
              logging_ = new global::Google.Genomics.V1Alpha2.LoggingOptions();
            }
            input.ReadMessage(logging_);
            break;
          }
          case 66: {
            if (keepVmAliveOnFailureDuration_ == null) {
              keepVmAliveOnFailureDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(keepVmAliveOnFailureDuration_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The request to run a pipeline. If `pipelineId` is specified, it
  ///  refers to a saved pipeline created with CreatePipeline and set as
  ///  the `pipelineId` of the returned Pipeline object. If
  ///  `ephemeralPipeline` is specified, that pipeline is run once
  ///  with the given args and not saved. It is an error to specify both
  ///  `pipelineId` and `ephemeralPipeline`. `pipelineArgs`
  ///  must be specified.
  /// </summary>
  public sealed partial class RunPipelineRequest : pb::IMessage<RunPipelineRequest> {
    private static readonly pb::MessageParser<RunPipelineRequest> _parser = new pb::MessageParser<RunPipelineRequest>(() => new RunPipelineRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RunPipelineRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineRequest(RunPipelineRequest other) : this() {
      PipelineArgs = other.pipelineArgs_ != null ? other.PipelineArgs.Clone() : null;
      switch (other.PipelineCase) {
        case PipelineOneofCase.PipelineId:
          PipelineId = other.PipelineId;
          break;
        case PipelineOneofCase.EphemeralPipeline:
          EphemeralPipeline = other.EphemeralPipeline.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RunPipelineRequest Clone() {
      return new RunPipelineRequest(this);
    }

    /// <summary>Field number for the "pipeline_id" field.</summary>
    public const int PipelineIdFieldNumber = 1;
    /// <summary>
    ///  The already created pipeline to run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PipelineId {
      get { return pipelineCase_ == PipelineOneofCase.PipelineId ? (string) pipeline_ : ""; }
      set {
        pipeline_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pipelineCase_ = PipelineOneofCase.PipelineId;
      }
    }

    /// <summary>Field number for the "ephemeral_pipeline" field.</summary>
    public const int EphemeralPipelineFieldNumber = 2;
    /// <summary>
    ///  A new pipeline object to run once and then delete.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.Pipeline EphemeralPipeline {
      get { return pipelineCase_ == PipelineOneofCase.EphemeralPipeline ? (global::Google.Genomics.V1Alpha2.Pipeline) pipeline_ : null; }
      set {
        pipeline_ = value;
        pipelineCase_ = value == null ? PipelineOneofCase.None : PipelineOneofCase.EphemeralPipeline;
      }
    }

    /// <summary>Field number for the "pipeline_args" field.</summary>
    public const int PipelineArgsFieldNumber = 3;
    private global::Google.Genomics.V1Alpha2.RunPipelineArgs pipelineArgs_;
    /// <summary>
    ///  The arguments to use when running this pipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.RunPipelineArgs PipelineArgs {
      get { return pipelineArgs_; }
      set {
        pipelineArgs_ = value;
      }
    }

    private object pipeline_;
    /// <summary>Enum of possible cases for the "pipeline" oneof.</summary>
    public enum PipelineOneofCase {
      None = 0,
      PipelineId = 1,
      EphemeralPipeline = 2,
    }
    private PipelineOneofCase pipelineCase_ = PipelineOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineOneofCase PipelineCase {
      get { return pipelineCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPipeline() {
      pipelineCase_ = PipelineOneofCase.None;
      pipeline_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RunPipelineRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RunPipelineRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PipelineId != other.PipelineId) return false;
      if (!object.Equals(EphemeralPipeline, other.EphemeralPipeline)) return false;
      if (!object.Equals(PipelineArgs, other.PipelineArgs)) return false;
      if (PipelineCase != other.PipelineCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pipelineCase_ == PipelineOneofCase.PipelineId) hash ^= PipelineId.GetHashCode();
      if (pipelineCase_ == PipelineOneofCase.EphemeralPipeline) hash ^= EphemeralPipeline.GetHashCode();
      if (pipelineArgs_ != null) hash ^= PipelineArgs.GetHashCode();
      hash ^= (int) pipelineCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pipelineCase_ == PipelineOneofCase.PipelineId) {
        output.WriteRawTag(10);
        output.WriteString(PipelineId);
      }
      if (pipelineCase_ == PipelineOneofCase.EphemeralPipeline) {
        output.WriteRawTag(18);
        output.WriteMessage(EphemeralPipeline);
      }
      if (pipelineArgs_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PipelineArgs);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pipelineCase_ == PipelineOneofCase.PipelineId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PipelineId);
      }
      if (pipelineCase_ == PipelineOneofCase.EphemeralPipeline) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EphemeralPipeline);
      }
      if (pipelineArgs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PipelineArgs);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RunPipelineRequest other) {
      if (other == null) {
        return;
      }
      if (other.pipelineArgs_ != null) {
        if (pipelineArgs_ == null) {
          pipelineArgs_ = new global::Google.Genomics.V1Alpha2.RunPipelineArgs();
        }
        PipelineArgs.MergeFrom(other.PipelineArgs);
      }
      switch (other.PipelineCase) {
        case PipelineOneofCase.PipelineId:
          PipelineId = other.PipelineId;
          break;
        case PipelineOneofCase.EphemeralPipeline:
          EphemeralPipeline = other.EphemeralPipeline;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            PipelineId = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Genomics.V1Alpha2.Pipeline subBuilder = new global::Google.Genomics.V1Alpha2.Pipeline();
            if (pipelineCase_ == PipelineOneofCase.EphemeralPipeline) {
              subBuilder.MergeFrom(EphemeralPipeline);
            }
            input.ReadMessage(subBuilder);
            EphemeralPipeline = subBuilder;
            break;
          }
          case 26: {
            if (pipelineArgs_ == null) {
              pipelineArgs_ = new global::Google.Genomics.V1Alpha2.RunPipelineArgs();
            }
            input.ReadMessage(pipelineArgs_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A request to get a saved pipeline by id.
  /// </summary>
  public sealed partial class GetPipelineRequest : pb::IMessage<GetPipelineRequest> {
    private static readonly pb::MessageParser<GetPipelineRequest> _parser = new pb::MessageParser<GetPipelineRequest>(() => new GetPipelineRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetPipelineRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPipelineRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPipelineRequest(GetPipelineRequest other) : this() {
      pipelineId_ = other.pipelineId_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPipelineRequest Clone() {
      return new GetPipelineRequest(this);
    }

    /// <summary>Field number for the "pipeline_id" field.</summary>
    public const int PipelineIdFieldNumber = 1;
    private string pipelineId_ = "";
    /// <summary>
    ///  Caller must have READ access to the project in which this pipeline
    ///  is defined.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PipelineId {
      get { return pipelineId_; }
      set {
        pipelineId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetPipelineRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetPipelineRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PipelineId != other.PipelineId) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PipelineId.Length != 0) hash ^= PipelineId.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PipelineId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(PipelineId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PipelineId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PipelineId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetPipelineRequest other) {
      if (other == null) {
        return;
      }
      if (other.PipelineId.Length != 0) {
        PipelineId = other.PipelineId;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            PipelineId = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A request to list pipelines in a given project. Pipelines can be
  ///  filtered by name using `namePrefix`: all pipelines with names that
  ///  begin with `namePrefix` will be returned. Uses standard pagination:
  ///  `pageSize` indicates how many pipelines to return, and
  ///  `pageToken` comes from a previous ListPipelinesResponse to
  ///  indicate offset.
  /// </summary>
  public sealed partial class ListPipelinesRequest : pb::IMessage<ListPipelinesRequest> {
    private static readonly pb::MessageParser<ListPipelinesRequest> _parser = new pb::MessageParser<ListPipelinesRequest>(() => new ListPipelinesRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListPipelinesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesRequest(ListPipelinesRequest other) : this() {
      projectId_ = other.projectId_;
      namePrefix_ = other.namePrefix_;
      pageSize_ = other.pageSize_;
      pageToken_ = other.pageToken_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesRequest Clone() {
      return new ListPipelinesRequest(this);
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 1;
    private string projectId_ = "";
    /// <summary>
    ///  Required. The name of the project to search for pipelines. Caller
    ///  must have READ access to this project.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name_prefix" field.</summary>
    public const int NamePrefixFieldNumber = 2;
    private string namePrefix_ = "";
    /// <summary>
    ///  Pipelines with names that match this prefix should be
    ///  returned.  If unspecified, all pipelines in the project, up to
    ///  `pageSize`, will be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NamePrefix {
      get { return namePrefix_; }
      set {
        namePrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 3;
    private int pageSize_;
    /// <summary>
    ///  Number of pipelines to return at once. Defaults to 256, and max
    ///  is 2048.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 4;
    private string pageToken_ = "";
    /// <summary>
    ///  Token to use to indicate where to start getting results.
    ///  If unspecified, returns the first page of results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListPipelinesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListPipelinesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProjectId != other.ProjectId) return false;
      if (NamePrefix != other.NamePrefix) return false;
      if (PageSize != other.PageSize) return false;
      if (PageToken != other.PageToken) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      if (NamePrefix.Length != 0) hash ^= NamePrefix.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProjectId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProjectId);
      }
      if (NamePrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NamePrefix);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PageToken);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      if (NamePrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NamePrefix);
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListPipelinesRequest other) {
      if (other == null) {
        return;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      if (other.NamePrefix.Length != 0) {
        NamePrefix = other.NamePrefix;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ProjectId = input.ReadString();
            break;
          }
          case 18: {
            NamePrefix = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
          case 34: {
            PageToken = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The response of ListPipelines. Contains at most `pageSize`
  ///  pipelines. If it contains `pageSize` pipelines, and more pipelines
  ///  exist, then `nextPageToken` will be populated and should be
  ///  used as the `pageToken` argument to a subsequent ListPipelines
  ///  request.
  /// </summary>
  public sealed partial class ListPipelinesResponse : pb::IMessage<ListPipelinesResponse> {
    private static readonly pb::MessageParser<ListPipelinesResponse> _parser = new pb::MessageParser<ListPipelinesResponse>(() => new ListPipelinesResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListPipelinesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesResponse(ListPipelinesResponse other) : this() {
      pipelines_ = other.pipelines_.Clone();
      nextPageToken_ = other.nextPageToken_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListPipelinesResponse Clone() {
      return new ListPipelinesResponse(this);
    }

    /// <summary>Field number for the "pipelines" field.</summary>
    public const int PipelinesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Genomics.V1Alpha2.Pipeline> _repeated_pipelines_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Genomics.V1Alpha2.Pipeline.Parser);
    private readonly pbc::RepeatedField<global::Google.Genomics.V1Alpha2.Pipeline> pipelines_ = new pbc::RepeatedField<global::Google.Genomics.V1Alpha2.Pipeline>();
    /// <summary>
    ///  The matched pipelines.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Genomics.V1Alpha2.Pipeline> Pipelines {
      get { return pipelines_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    ///  The token to use to get the next page of results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListPipelinesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListPipelinesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!pipelines_.Equals(other.pipelines_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= pipelines_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      pipelines_.WriteTo(output, _repeated_pipelines_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += pipelines_.CalculateSize(_repeated_pipelines_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListPipelinesResponse other) {
      if (other == null) {
        return;
      }
      pipelines_.Add(other.pipelines_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            pipelines_.AddEntriesFrom(input, _repeated_pipelines_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The request to delete a saved pipeline by ID.
  /// </summary>
  public sealed partial class DeletePipelineRequest : pb::IMessage<DeletePipelineRequest> {
    private static readonly pb::MessageParser<DeletePipelineRequest> _parser = new pb::MessageParser<DeletePipelineRequest>(() => new DeletePipelineRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeletePipelineRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeletePipelineRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeletePipelineRequest(DeletePipelineRequest other) : this() {
      pipelineId_ = other.pipelineId_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeletePipelineRequest Clone() {
      return new DeletePipelineRequest(this);
    }

    /// <summary>Field number for the "pipeline_id" field.</summary>
    public const int PipelineIdFieldNumber = 1;
    private string pipelineId_ = "";
    /// <summary>
    ///  Caller must have WRITE access to the project in which this pipeline
    ///  is defined.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PipelineId {
      get { return pipelineId_; }
      set {
        pipelineId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeletePipelineRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeletePipelineRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PipelineId != other.PipelineId) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PipelineId.Length != 0) hash ^= PipelineId.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PipelineId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(PipelineId);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PipelineId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PipelineId);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeletePipelineRequest other) {
      if (other == null) {
        return;
      }
      if (other.PipelineId.Length != 0) {
        PipelineId = other.PipelineId;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            PipelineId = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Request to get controller configuation.  Should only be used
  ///  by VMs created by the Pipelines Service and not by end users.
  /// </summary>
  public sealed partial class GetControllerConfigRequest : pb::IMessage<GetControllerConfigRequest> {
    private static readonly pb::MessageParser<GetControllerConfigRequest> _parser = new pb::MessageParser<GetControllerConfigRequest>(() => new GetControllerConfigRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetControllerConfigRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetControllerConfigRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetControllerConfigRequest(GetControllerConfigRequest other) : this() {
      operationId_ = other.operationId_;
      validationToken_ = other.validationToken_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetControllerConfigRequest Clone() {
      return new GetControllerConfigRequest(this);
    }

    /// <summary>Field number for the "operation_id" field.</summary>
    public const int OperationIdFieldNumber = 1;
    private string operationId_ = "";
    /// <summary>
    ///  The operation to retrieve controller configuration for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OperationId {
      get { return operationId_; }
      set {
        operationId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "validation_token" field.</summary>
    public const int ValidationTokenFieldNumber = 2;
    private ulong validationToken_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ValidationToken {
      get { return validationToken_; }
      set {
        validationToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetControllerConfigRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetControllerConfigRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OperationId != other.OperationId) return false;
      if (ValidationToken != other.ValidationToken) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OperationId.Length != 0) hash ^= OperationId.GetHashCode();
      if (ValidationToken != 0UL) hash ^= ValidationToken.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OperationId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(OperationId);
      }
      if (ValidationToken != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(ValidationToken);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OperationId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OperationId);
      }
      if (ValidationToken != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ValidationToken);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetControllerConfigRequest other) {
      if (other == null) {
        return;
      }
      if (other.OperationId.Length != 0) {
        OperationId = other.OperationId;
      }
      if (other.ValidationToken != 0UL) {
        ValidationToken = other.ValidationToken;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            OperationId = input.ReadString();
            break;
          }
          case 16: {
            ValidationToken = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Stores the information that the controller will fetch from the
  ///  server in order to run. Should only be used by VMs created by the
  ///  Pipelines Service and not by end users.
  /// </summary>
  public sealed partial class ControllerConfig : pb::IMessage<ControllerConfig> {
    private static readonly pb::MessageParser<ControllerConfig> _parser = new pb::MessageParser<ControllerConfig>(() => new ControllerConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerConfig(ControllerConfig other) : this() {
      image_ = other.image_;
      cmd_ = other.cmd_;
      gcsLogPath_ = other.gcsLogPath_;
      machineType_ = other.machineType_;
      vars_ = other.vars_.Clone();
      disks_ = other.disks_.Clone();
      gcsSources_ = other.gcsSources_.Clone();
      gcsSinks_ = other.gcsSinks_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerConfig Clone() {
      return new ControllerConfig(this);
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 1;
    private string image_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Image {
      get { return image_; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cmd" field.</summary>
    public const int CmdFieldNumber = 2;
    private string cmd_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Cmd {
      get { return cmd_; }
      set {
        cmd_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "gcs_log_path" field.</summary>
    public const int GcsLogPathFieldNumber = 3;
    private string gcsLogPath_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GcsLogPath {
      get { return gcsLogPath_; }
      set {
        gcsLogPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 4;
    private string machineType_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vars" field.</summary>
    public const int VarsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_vars_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 42);
    private readonly pbc::MapField<string, string> vars_ = new pbc::MapField<string, string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Vars {
      get { return vars_; }
    }

    /// <summary>Field number for the "disks" field.</summary>
    public const int DisksFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_disks_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
    private readonly pbc::MapField<string, string> disks_ = new pbc::MapField<string, string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Disks {
      get { return disks_; }
    }

    /// <summary>Field number for the "gcs_sources" field.</summary>
    public const int GcsSourcesFieldNumber = 7;
    private static readonly pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>.Codec _map_gcsSources_codec
        = new pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString.Parser), 58);
    private readonly pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString> gcsSources_ = new pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString> GcsSources {
      get { return gcsSources_; }
    }

    /// <summary>Field number for the "gcs_sinks" field.</summary>
    public const int GcsSinksFieldNumber = 8;
    private static readonly pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>.Codec _map_gcsSinks_codec
        = new pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString.Parser), 66);
    private readonly pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString> gcsSinks_ = new pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Genomics.V1Alpha2.ControllerConfig.Types.RepeatedString> GcsSinks {
      get { return gcsSinks_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Image != other.Image) return false;
      if (Cmd != other.Cmd) return false;
      if (GcsLogPath != other.GcsLogPath) return false;
      if (MachineType != other.MachineType) return false;
      if (!Vars.Equals(other.Vars)) return false;
      if (!Disks.Equals(other.Disks)) return false;
      if (!GcsSources.Equals(other.GcsSources)) return false;
      if (!GcsSinks.Equals(other.GcsSinks)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Image.Length != 0) hash ^= Image.GetHashCode();
      if (Cmd.Length != 0) hash ^= Cmd.GetHashCode();
      if (GcsLogPath.Length != 0) hash ^= GcsLogPath.GetHashCode();
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      hash ^= Vars.GetHashCode();
      hash ^= Disks.GetHashCode();
      hash ^= GcsSources.GetHashCode();
      hash ^= GcsSinks.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Image.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Image);
      }
      if (Cmd.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Cmd);
      }
      if (GcsLogPath.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(GcsLogPath);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(MachineType);
      }
      vars_.WriteTo(output, _map_vars_codec);
      disks_.WriteTo(output, _map_disks_codec);
      gcsSources_.WriteTo(output, _map_gcsSources_codec);
      gcsSinks_.WriteTo(output, _map_gcsSinks_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Image.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      if (Cmd.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cmd);
      }
      if (GcsLogPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GcsLogPath);
      }
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      size += vars_.CalculateSize(_map_vars_codec);
      size += disks_.CalculateSize(_map_disks_codec);
      size += gcsSources_.CalculateSize(_map_gcsSources_codec);
      size += gcsSinks_.CalculateSize(_map_gcsSinks_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerConfig other) {
      if (other == null) {
        return;
      }
      if (other.Image.Length != 0) {
        Image = other.Image;
      }
      if (other.Cmd.Length != 0) {
        Cmd = other.Cmd;
      }
      if (other.GcsLogPath.Length != 0) {
        GcsLogPath = other.GcsLogPath;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      vars_.Add(other.vars_);
      disks_.Add(other.disks_);
      gcsSources_.Add(other.gcsSources_);
      gcsSinks_.Add(other.gcsSinks_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Image = input.ReadString();
            break;
          }
          case 18: {
            Cmd = input.ReadString();
            break;
          }
          case 26: {
            GcsLogPath = input.ReadString();
            break;
          }
          case 34: {
            MachineType = input.ReadString();
            break;
          }
          case 42: {
            vars_.AddEntriesFrom(input, _map_vars_codec);
            break;
          }
          case 50: {
            disks_.AddEntriesFrom(input, _map_disks_codec);
            break;
          }
          case 58: {
            gcsSources_.AddEntriesFrom(input, _map_gcsSources_codec);
            break;
          }
          case 66: {
            gcsSinks_.AddEntriesFrom(input, _map_gcsSinks_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ControllerConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class RepeatedString : pb::IMessage<RepeatedString> {
        private static readonly pb::MessageParser<RepeatedString> _parser = new pb::MessageParser<RepeatedString>(() => new RepeatedString());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RepeatedString> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Genomics.V1Alpha2.ControllerConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RepeatedString() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RepeatedString(RepeatedString other) : this() {
          values_ = other.values_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RepeatedString Clone() {
          return new RepeatedString(this);
        }

        /// <summary>Field number for the "values" field.</summary>
        public const int ValuesFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_values_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Values {
          get { return values_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RepeatedString);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RepeatedString other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!values_.Equals(other.values_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= values_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          values_.WriteTo(output, _repeated_values_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += values_.CalculateSize(_repeated_values_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RepeatedString other) {
          if (other == null) {
            return;
          }
          values_.Add(other.values_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                values_.AddEntriesFrom(input, _repeated_values_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Stores the list of events and times they occured for major events in job
  ///  execution.
  /// </summary>
  public sealed partial class TimestampEvent : pb::IMessage<TimestampEvent> {
    private static readonly pb::MessageParser<TimestampEvent> _parser = new pb::MessageParser<TimestampEvent>(() => new TimestampEvent());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimestampEvent> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampEvent() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampEvent(TimestampEvent other) : this() {
      description_ = other.description_;
      Timestamp = other.timestamp_ != null ? other.Timestamp.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampEvent Clone() {
      return new TimestampEvent(this);
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 1;
    private string description_ = "";
    /// <summary>
    ///  String indicating the type of event
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
    /// <summary>
    ///  The time this event occured.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimestampEvent);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimestampEvent other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Description != other.Description) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Description.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Description);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimestampEvent other) {
      if (other == null) {
        return;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          timestamp_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Description = input.ReadString();
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              timestamp_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(timestamp_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Request to set operation status. Should only be used by VMs
  ///  created by the Pipelines Service and not by end users.
  /// </summary>
  public sealed partial class SetOperationStatusRequest : pb::IMessage<SetOperationStatusRequest> {
    private static readonly pb::MessageParser<SetOperationStatusRequest> _parser = new pb::MessageParser<SetOperationStatusRequest>(() => new SetOperationStatusRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SetOperationStatusRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SetOperationStatusRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SetOperationStatusRequest(SetOperationStatusRequest other) : this() {
      operationId_ = other.operationId_;
      timestampEvents_ = other.timestampEvents_.Clone();
      errorCode_ = other.errorCode_;
      errorMessage_ = other.errorMessage_;
      validationToken_ = other.validationToken_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SetOperationStatusRequest Clone() {
      return new SetOperationStatusRequest(this);
    }

    /// <summary>Field number for the "operation_id" field.</summary>
    public const int OperationIdFieldNumber = 1;
    private string operationId_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OperationId {
      get { return operationId_; }
      set {
        operationId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "timestamp_events" field.</summary>
    public const int TimestampEventsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Genomics.V1Alpha2.TimestampEvent> _repeated_timestampEvents_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Genomics.V1Alpha2.TimestampEvent.Parser);
    private readonly pbc::RepeatedField<global::Google.Genomics.V1Alpha2.TimestampEvent> timestampEvents_ = new pbc::RepeatedField<global::Google.Genomics.V1Alpha2.TimestampEvent>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Genomics.V1Alpha2.TimestampEvent> TimestampEvents {
      get { return timestampEvents_; }
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 3;
    private global::Google.Rpc.Code errorCode_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Rpc.Code ErrorCode {
      get { return errorCode_; }
      set {
        errorCode_ = value;
      }
    }

    /// <summary>Field number for the "error_message" field.</summary>
    public const int ErrorMessageFieldNumber = 4;
    private string errorMessage_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ErrorMessage {
      get { return errorMessage_; }
      set {
        errorMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "validation_token" field.</summary>
    public const int ValidationTokenFieldNumber = 5;
    private ulong validationToken_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ValidationToken {
      get { return validationToken_; }
      set {
        validationToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SetOperationStatusRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SetOperationStatusRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OperationId != other.OperationId) return false;
      if(!timestampEvents_.Equals(other.timestampEvents_)) return false;
      if (ErrorCode != other.ErrorCode) return false;
      if (ErrorMessage != other.ErrorMessage) return false;
      if (ValidationToken != other.ValidationToken) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OperationId.Length != 0) hash ^= OperationId.GetHashCode();
      hash ^= timestampEvents_.GetHashCode();
      if (ErrorCode != 0) hash ^= ErrorCode.GetHashCode();
      if (ErrorMessage.Length != 0) hash ^= ErrorMessage.GetHashCode();
      if (ValidationToken != 0UL) hash ^= ValidationToken.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OperationId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(OperationId);
      }
      timestampEvents_.WriteTo(output, _repeated_timestampEvents_codec);
      if (ErrorCode != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ErrorCode);
      }
      if (ErrorMessage.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ErrorMessage);
      }
      if (ValidationToken != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(ValidationToken);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OperationId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OperationId);
      }
      size += timestampEvents_.CalculateSize(_repeated_timestampEvents_codec);
      if (ErrorCode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ErrorCode);
      }
      if (ErrorMessage.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ErrorMessage);
      }
      if (ValidationToken != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ValidationToken);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SetOperationStatusRequest other) {
      if (other == null) {
        return;
      }
      if (other.OperationId.Length != 0) {
        OperationId = other.OperationId;
      }
      timestampEvents_.Add(other.timestampEvents_);
      if (other.ErrorCode != 0) {
        ErrorCode = other.ErrorCode;
      }
      if (other.ErrorMessage.Length != 0) {
        ErrorMessage = other.ErrorMessage;
      }
      if (other.ValidationToken != 0UL) {
        ValidationToken = other.ValidationToken;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            OperationId = input.ReadString();
            break;
          }
          case 18: {
            timestampEvents_.AddEntriesFrom(input, _repeated_timestampEvents_codec);
            break;
          }
          case 24: {
            errorCode_ = (global::Google.Rpc.Code) input.ReadEnum();
            break;
          }
          case 34: {
            ErrorMessage = input.ReadString();
            break;
          }
          case 40: {
            ValidationToken = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  A Google Cloud Service Account.
  /// </summary>
  public sealed partial class ServiceAccount : pb::IMessage<ServiceAccount> {
    private static readonly pb::MessageParser<ServiceAccount> _parser = new pb::MessageParser<ServiceAccount>(() => new ServiceAccount());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ServiceAccount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceAccount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceAccount(ServiceAccount other) : this() {
      email_ = other.email_;
      scopes_ = other.scopes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceAccount Clone() {
      return new ServiceAccount(this);
    }

    /// <summary>Field number for the "email" field.</summary>
    public const int EmailFieldNumber = 1;
    private string email_ = "";
    /// <summary>
    ///  Email address of the service account. Defaults to `default`,
    ///  which uses the compute service account associated with the project.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Email {
      get { return email_; }
      set {
        email_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "scopes" field.</summary>
    public const int ScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_scopes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> scopes_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  List of scopes to be enabled for this service account on the
    ///  pipeline virtual machine.
    ///  The following scopes are automatically included:
    ///  * https://www.googleapis.com/auth/genomics
    ///  * https://www.googleapis.com/auth/compute
    ///  * https://www.googleapis.com/auth/devstorage.full_control
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Scopes {
      get { return scopes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ServiceAccount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ServiceAccount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Email != other.Email) return false;
      if(!scopes_.Equals(other.scopes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Email.Length != 0) hash ^= Email.GetHashCode();
      hash ^= scopes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Email.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Email);
      }
      scopes_.WriteTo(output, _repeated_scopes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Email.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Email);
      }
      size += scopes_.CalculateSize(_repeated_scopes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ServiceAccount other) {
      if (other == null) {
        return;
      }
      if (other.Email.Length != 0) {
        Email = other.Email;
      }
      scopes_.Add(other.scopes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Email = input.ReadString();
            break;
          }
          case 18: {
            scopes_.AddEntriesFrom(input, _repeated_scopes_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The logging options for the pipeline run.
  /// </summary>
  public sealed partial class LoggingOptions : pb::IMessage<LoggingOptions> {
    private static readonly pb::MessageParser<LoggingOptions> _parser = new pb::MessageParser<LoggingOptions>(() => new LoggingOptions());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LoggingOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoggingOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoggingOptions(LoggingOptions other) : this() {
      gcsPath_ = other.gcsPath_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoggingOptions Clone() {
      return new LoggingOptions(this);
    }

    /// <summary>Field number for the "gcs_path" field.</summary>
    public const int GcsPathFieldNumber = 1;
    private string gcsPath_ = "";
    /// <summary>
    ///  The location in Google Cloud Storage to which the pipeline logs
    ///  will be copied. Can be specified as a fully qualified directory
    ///  path, in which case logs will be output with a unique identifier
    ///  as the filename in that directory, or as a fully specified path,
    ///  which must end in `.log`, in which case that path will be
    ///  used, and the user must ensure that logs are not
    ///  overwritten. Stdout and stderr logs from the run are also
    ///  generated and output as `-stdout.log` and `-stderr.log`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GcsPath {
      get { return gcsPath_; }
      set {
        gcsPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LoggingOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LoggingOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GcsPath != other.GcsPath) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (GcsPath.Length != 0) hash ^= GcsPath.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (GcsPath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GcsPath);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (GcsPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GcsPath);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LoggingOptions other) {
      if (other == null) {
        return;
      }
      if (other.GcsPath.Length != 0) {
        GcsPath = other.GcsPath;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            GcsPath = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  The system resources for the pipeline run.
  /// </summary>
  public sealed partial class PipelineResources : pb::IMessage<PipelineResources> {
    private static readonly pb::MessageParser<PipelineResources> _parser = new pb::MessageParser<PipelineResources>(() => new PipelineResources());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PipelineResources> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineResources() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineResources(PipelineResources other) : this() {
      minimumCpuCores_ = other.minimumCpuCores_;
      preemptible_ = other.preemptible_;
      minimumRamGb_ = other.minimumRamGb_;
      disks_ = other.disks_.Clone();
      zones_ = other.zones_.Clone();
      bootDiskSizeGb_ = other.bootDiskSizeGb_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineResources Clone() {
      return new PipelineResources(this);
    }

    /// <summary>Field number for the "minimum_cpu_cores" field.</summary>
    public const int MinimumCpuCoresFieldNumber = 1;
    private int minimumCpuCores_;
    /// <summary>
    ///  The minimum number of cores to use. Defaults to 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinimumCpuCores {
      get { return minimumCpuCores_; }
      set {
        minimumCpuCores_ = value;
      }
    }

    /// <summary>Field number for the "preemptible" field.</summary>
    public const int PreemptibleFieldNumber = 2;
    private bool preemptible_;
    /// <summary>
    ///  At create time means that preemptible machines may be
    ///  used for the run. At run time, means they should be used. Cannot
    ///  be true at run time if false at create time.
    ///  Defaults to `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Preemptible {
      get { return preemptible_; }
      set {
        preemptible_ = value;
      }
    }

    /// <summary>Field number for the "minimum_ram_gb" field.</summary>
    public const int MinimumRamGbFieldNumber = 3;
    private double minimumRamGb_;
    /// <summary>
    ///  The minimum amount of RAM to use. Defaults to 3.75 (GB)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinimumRamGb {
      get { return minimumRamGb_; }
      set {
        minimumRamGb_ = value;
      }
    }

    /// <summary>Field number for the "disks" field.</summary>
    public const int DisksFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk> _repeated_disks_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Parser);
    private readonly pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk> disks_ = new pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk>();
    /// <summary>
    ///  Disks to attach.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk> Disks {
      get { return disks_; }
    }

    /// <summary>Field number for the "zones" field.</summary>
    public const int ZonesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_zones_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> zones_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  List of Google Compute Engine availability zones to which resource
    ///  creation will restricted. If empty, any zone may be chosen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Zones {
      get { return zones_; }
    }

    /// <summary>Field number for the "boot_disk_size_gb" field.</summary>
    public const int BootDiskSizeGbFieldNumber = 6;
    private int bootDiskSizeGb_;
    /// <summary>
    ///  The size of the boot disk. Defaults to 10 (GB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BootDiskSizeGb {
      get { return bootDiskSizeGb_; }
      set {
        bootDiskSizeGb_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PipelineResources);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PipelineResources other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinimumCpuCores != other.MinimumCpuCores) return false;
      if (Preemptible != other.Preemptible) return false;
      if (MinimumRamGb != other.MinimumRamGb) return false;
      if(!disks_.Equals(other.disks_)) return false;
      if(!zones_.Equals(other.zones_)) return false;
      if (BootDiskSizeGb != other.BootDiskSizeGb) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinimumCpuCores != 0) hash ^= MinimumCpuCores.GetHashCode();
      if (Preemptible != false) hash ^= Preemptible.GetHashCode();
      if (MinimumRamGb != 0D) hash ^= MinimumRamGb.GetHashCode();
      hash ^= disks_.GetHashCode();
      hash ^= zones_.GetHashCode();
      if (BootDiskSizeGb != 0) hash ^= BootDiskSizeGb.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinimumCpuCores != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MinimumCpuCores);
      }
      if (Preemptible != false) {
        output.WriteRawTag(16);
        output.WriteBool(Preemptible);
      }
      if (MinimumRamGb != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(MinimumRamGb);
      }
      disks_.WriteTo(output, _repeated_disks_codec);
      zones_.WriteTo(output, _repeated_zones_codec);
      if (BootDiskSizeGb != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(BootDiskSizeGb);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinimumCpuCores != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinimumCpuCores);
      }
      if (Preemptible != false) {
        size += 1 + 1;
      }
      if (MinimumRamGb != 0D) {
        size += 1 + 8;
      }
      size += disks_.CalculateSize(_repeated_disks_codec);
      size += zones_.CalculateSize(_repeated_zones_codec);
      if (BootDiskSizeGb != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BootDiskSizeGb);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PipelineResources other) {
      if (other == null) {
        return;
      }
      if (other.MinimumCpuCores != 0) {
        MinimumCpuCores = other.MinimumCpuCores;
      }
      if (other.Preemptible != false) {
        Preemptible = other.Preemptible;
      }
      if (other.MinimumRamGb != 0D) {
        MinimumRamGb = other.MinimumRamGb;
      }
      disks_.Add(other.disks_);
      zones_.Add(other.zones_);
      if (other.BootDiskSizeGb != 0) {
        BootDiskSizeGb = other.BootDiskSizeGb;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            MinimumCpuCores = input.ReadInt32();
            break;
          }
          case 16: {
            Preemptible = input.ReadBool();
            break;
          }
          case 25: {
            MinimumRamGb = input.ReadDouble();
            break;
          }
          case 34: {
            disks_.AddEntriesFrom(input, _repeated_disks_codec);
            break;
          }
          case 42: {
            zones_.AddEntriesFrom(input, _repeated_zones_codec);
            break;
          }
          case 48: {
            BootDiskSizeGb = input.ReadInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PipelineResources message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  A Google Compute Engine disk resource specification.
      /// </summary>
      public sealed partial class Disk : pb::IMessage<Disk> {
        private static readonly pb::MessageParser<Disk> _parser = new pb::MessageParser<Disk>(() => new Disk());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Disk> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Genomics.V1Alpha2.PipelineResources.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Disk() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Disk(Disk other) : this() {
          name_ = other.name_;
          type_ = other.type_;
          sizeGb_ = other.sizeGb_;
          source_ = other.source_;
          autoDelete_ = other.autoDelete_;
          readOnly_ = other.readOnly_;
          mountPoint_ = other.mountPoint_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Disk Clone() {
          return new Disk(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        ///  Required. The name of the disk that can be used in the pipeline
        ///  parameters. Must be 1 - 63 characters.
        ///  The name "boot" is reserved for system use.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Types.Type type_ = 0;
        /// <summary>
        ///  Required. The type of the disk to create.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "size_gb" field.</summary>
        public const int SizeGbFieldNumber = 3;
        private int sizeGb_;
        /// <summary>
        ///  The size of the disk. Defaults to 500 (GB).
        ///  This field is not applicable for local SSD.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int SizeGb {
          get { return sizeGb_; }
          set {
            sizeGb_ = value;
          }
        }

        /// <summary>Field number for the "source" field.</summary>
        public const int SourceFieldNumber = 4;
        private string source_ = "";
        /// <summary>
        ///  The full or partial URL of the persistent disk to attach. See
        ///  https://cloud.google.com/compute/docs/reference/latest/instances#resource
        ///  and
        ///  https://cloud.google.com/compute/docs/disks/persistent-disks#snapshots
        ///  for more details.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Source {
          get { return source_; }
          set {
            source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "auto_delete" field.</summary>
        public const int AutoDeleteFieldNumber = 6;
        private bool autoDelete_;
        /// <summary>
        ///  Specifies whether or not to delete the disk when the pipeline
        ///  completes. This field is applicable only for newly created disks. See
        ///  https://cloud.google.com/compute/docs/reference/latest/instances#resource
        ///  for more details.
        ///  By default, `autoDelete` is `false`. `autoDelete` will be enabled if set
        ///  to `true` at create time or run time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool AutoDelete {
          get { return autoDelete_; }
          set {
            autoDelete_ = value;
          }
        }

        /// <summary>Field number for the "read_only" field.</summary>
        public const int ReadOnlyFieldNumber = 7;
        private bool readOnly_;
        /// <summary>
        ///  Specifies how a sourced-base persistent disk will be mounted. See
        ///  https://cloud.google.com/compute/docs/disks/persistent-disks#use_multi_instances
        ///  for more details.
        ///  Can only be set at create time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ReadOnly {
          get { return readOnly_; }
          set {
            readOnly_ = value;
          }
        }

        /// <summary>Field number for the "mount_point" field.</summary>
        public const int MountPointFieldNumber = 8;
        private string mountPoint_ = "";
        /// <summary>
        ///  Required at create time and cannot be overridden at run time.
        ///  Specifies the path in the docker container where files on
        ///  this disk should be located. For example, if `mountPoint`
        ///  is `/mnt/disk`, and the parameter has `localPath`
        ///  `inputs/file.txt`, the docker container can access the data at
        ///  `/mnt/disk/inputs/file.txt`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string MountPoint {
          get { return mountPoint_; }
          set {
            mountPoint_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Disk);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Disk other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Type != other.Type) return false;
          if (SizeGb != other.SizeGb) return false;
          if (Source != other.Source) return false;
          if (AutoDelete != other.AutoDelete) return false;
          if (ReadOnly != other.ReadOnly) return false;
          if (MountPoint != other.MountPoint) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Type != 0) hash ^= Type.GetHashCode();
          if (SizeGb != 0) hash ^= SizeGb.GetHashCode();
          if (Source.Length != 0) hash ^= Source.GetHashCode();
          if (AutoDelete != false) hash ^= AutoDelete.GetHashCode();
          if (ReadOnly != false) hash ^= ReadOnly.GetHashCode();
          if (MountPoint.Length != 0) hash ^= MountPoint.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Type != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Type);
          }
          if (SizeGb != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(SizeGb);
          }
          if (Source.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(Source);
          }
          if (AutoDelete != false) {
            output.WriteRawTag(48);
            output.WriteBool(AutoDelete);
          }
          if (ReadOnly != false) {
            output.WriteRawTag(56);
            output.WriteBool(ReadOnly);
          }
          if (MountPoint.Length != 0) {
            output.WriteRawTag(66);
            output.WriteString(MountPoint);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (SizeGb != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(SizeGb);
          }
          if (Source.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
          }
          if (AutoDelete != false) {
            size += 1 + 1;
          }
          if (ReadOnly != false) {
            size += 1 + 1;
          }
          if (MountPoint.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(MountPoint);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Disk other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
          if (other.SizeGb != 0) {
            SizeGb = other.SizeGb;
          }
          if (other.Source.Length != 0) {
            Source = other.Source;
          }
          if (other.AutoDelete != false) {
            AutoDelete = other.AutoDelete;
          }
          if (other.ReadOnly != false) {
            ReadOnly = other.ReadOnly;
          }
          if (other.MountPoint.Length != 0) {
            MountPoint = other.MountPoint;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                type_ = (global::Google.Genomics.V1Alpha2.PipelineResources.Types.Disk.Types.Type) input.ReadEnum();
                break;
              }
              case 24: {
                SizeGb = input.ReadInt32();
                break;
              }
              case 34: {
                Source = input.ReadString();
                break;
              }
              case 48: {
                AutoDelete = input.ReadBool();
                break;
              }
              case 56: {
                ReadOnly = input.ReadBool();
                break;
              }
              case 66: {
                MountPoint = input.ReadString();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Disk message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          ///  The types of disks that may be attached to VMs.
          /// </summary>
          public enum Type {
            /// <summary>
            ///  Default disk type. Use one of the other options below.
            /// </summary>
            [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            ///  Specifies a Google Compute Engine persistent hard disk. See
            ///  https://cloud.google.com/compute/docs/disks/#pdspecs for details.
            /// </summary>
            [pbr::OriginalName("PERSISTENT_HDD")] PersistentHdd = 1,
            /// <summary>
            ///  Specifies a Google Compute Engine persistent solid-state disk. See
            ///  https://cloud.google.com/compute/docs/disks/#pdspecs for details.
            /// </summary>
            [pbr::OriginalName("PERSISTENT_SSD")] PersistentSsd = 2,
            /// <summary>
            ///  Specifies a Google Compute Engine local SSD.
            ///  See https://cloud.google.com/compute/docs/disks/local-ssd for details.
            /// </summary>
            [pbr::OriginalName("LOCAL_SSD")] LocalSsd = 3,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///  Parameters facilitate setting and delivering data into the
  ///  pipeline's execution environment. They are defined at create time,
  ///  with optional defaults, and can be overridden at run time.
  ///
  ///  If `localCopy` is unset, then the parameter specifies a string that
  ///  is passed as-is into the pipeline, as the value of the environment
  ///  variable with the given name.  A default value can be optionally
  ///  specified at create time. The default can be overridden at run time
  ///  using the inputs map. If no default is given, a value must be
  ///  supplied at runtime.
  ///
  ///  If `localCopy` is defined, then the parameter specifies a data
  ///  source or sink, both in Google Cloud Storage and on the Docker container
  ///  where the pipeline computation is run. The [service account associated with
  ///  the Pipeline][google.genomics.v1alpha2.RunPipelineArgs.service_account] (by
  ///  default the project's Compute Engine service account) must have access to the
  ///  Google Cloud Storage paths.
  ///
  ///  At run time, the Google Cloud Storage paths can be overridden if a default
  ///  was provided at create time, or must be set otherwise. The pipeline runner
  ///  should add a key/value pair to either the inputs or outputs map. The
  ///  indicated data copies will be carried out before/after pipeline execution,
  ///  just as if the corresponding arguments were provided to `gsutil cp`.
  ///
  ///  For example: Given the following `PipelineParameter`, specified
  ///  in the `inputParameters` list:
  ///
  ///  ```
  ///  {name: "input_file", localCopy: {path: "file.txt", disk: "pd1"}}
  ///  ```
  ///
  ///  where `disk` is defined in the `PipelineResources` object as:
  ///
  ///  ```
  ///  {name: "pd1", mountPoint: "/mnt/disk/"}
  ///  ```
  ///
  ///  We create a disk named `pd1`, mount it on the host VM, and map
  ///  `/mnt/pd1` to `/mnt/disk` in the docker container.  At
  ///  runtime, an entry for `input_file` would be required in the inputs
  ///  map, such as:
  ///
  ///  ```
  ///    inputs["input_file"] = "gs://my-bucket/bar.txt"
  ///  ```
  ///
  ///  This would generate the following gsutil call:
  ///
  ///  ```
  ///    gsutil cp gs://my-bucket/bar.txt /mnt/pd1/file.txt
  ///  ```
  ///
  ///  The file `/mnt/pd1/file.txt` maps to `/mnt/disk/file.txt` in the
  ///  Docker container. Acceptable paths are:
  ///
  ///  &lt;table>
  ///    &lt;thead>
  ///      &lt;tr>&lt;th>Google Cloud storage path&lt;/th>&lt;th>Local path&lt;/th>&lt;/tr>
  ///    &lt;/thead>
  ///    &lt;tbody>
  ///      &lt;tr>&lt;td>file&lt;/td>&lt;td>file&lt;/td>&lt;/tr>
  ///      &lt;tr>&lt;td>glob&lt;/td>&lt;td>directory&lt;/td>&lt;/tr>
  ///    &lt;/tbody>
  ///  &lt;/table>
  ///
  ///  For outputs, the direction of the copy is reversed:
  ///
  ///  ```
  ///    gsutil cp /mnt/disk/file.txt gs://my-bucket/bar.txt
  ///  ```
  ///
  ///  Acceptable paths are:
  ///
  ///  &lt;table>
  ///    &lt;thead>
  ///      &lt;tr>&lt;th>Local path&lt;/th>&lt;th>Google Cloud Storage path&lt;/th>&lt;/tr>
  ///    &lt;/thead>
  ///    &lt;tbody>
  ///      &lt;tr>&lt;td>file&lt;/td>&lt;td>file&lt;/td>&lt;/tr>
  ///      &lt;tr>
  ///        &lt;td>file&lt;/td>
  ///        &lt;td>directory - directory must already exist&lt;/td>
  ///      &lt;/tr>
  ///      &lt;tr>
  ///        &lt;td>glob&lt;/td>
  ///        &lt;td>directory - directory will be created if it doesn't exist&lt;/td>&lt;/tr>
  ///    &lt;/tbody>
  ///  &lt;/table>
  ///
  ///  One restriction due to docker limitations, is that for outputs that are found
  ///  on the boot disk, the local path cannot be a glob and must be a file.
  /// </summary>
  public sealed partial class PipelineParameter : pb::IMessage<PipelineParameter> {
    private static readonly pb::MessageParser<PipelineParameter> _parser = new pb::MessageParser<PipelineParameter>(() => new PipelineParameter());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PipelineParameter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineParameter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineParameter(PipelineParameter other) : this() {
      name_ = other.name_;
      description_ = other.description_;
      defaultValue_ = other.defaultValue_;
      LocalCopy = other.localCopy_ != null ? other.LocalCopy.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PipelineParameter Clone() {
      return new PipelineParameter(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///  Required. Name of the parameter - the pipeline runner uses this string
    ///  as the key to the input and output maps in RunPipeline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 2;
    private string description_ = "";
    /// <summary>
    ///  Human-readable description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "default_value" field.</summary>
    public const int DefaultValueFieldNumber = 5;
    private string defaultValue_ = "";
    /// <summary>
    ///  The default value for this parameter. Can be overridden at runtime.
    ///  If `localCopy` is present, then this must be a Google Cloud Storage path
    ///  beginning with `gs://`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DefaultValue {
      get { return defaultValue_; }
      set {
        defaultValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "local_copy" field.</summary>
    public const int LocalCopyFieldNumber = 6;
    private global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy localCopy_;
    /// <summary>
    ///  If present, this parameter is marked for copying to and from the VM.
    ///  `LocalCopy` indicates where on the VM the file should be. The value
    ///  given to this parameter (either at runtime or using `defaultValue`)
    ///  must be the remote path where the file should be.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy LocalCopy {
      get { return localCopy_; }
      set {
        localCopy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PipelineParameter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PipelineParameter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Description != other.Description) return false;
      if (DefaultValue != other.DefaultValue) return false;
      if (!object.Equals(LocalCopy, other.LocalCopy)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (DefaultValue.Length != 0) hash ^= DefaultValue.GetHashCode();
      if (localCopy_ != null) hash ^= LocalCopy.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (DefaultValue.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(DefaultValue);
      }
      if (localCopy_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(LocalCopy);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (DefaultValue.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultValue);
      }
      if (localCopy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalCopy);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PipelineParameter other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.DefaultValue.Length != 0) {
        DefaultValue = other.DefaultValue;
      }
      if (other.localCopy_ != null) {
        if (localCopy_ == null) {
          localCopy_ = new global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy();
        }
        LocalCopy.MergeFrom(other.LocalCopy);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 42: {
            DefaultValue = input.ReadString();
            break;
          }
          case 50: {
            if (localCopy_ == null) {
              localCopy_ = new global::Google.Genomics.V1Alpha2.PipelineParameter.Types.LocalCopy();
            }
            input.ReadMessage(localCopy_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PipelineParameter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  LocalCopy defines how a remote file should be copied to and from the VM.
      /// </summary>
      public sealed partial class LocalCopy : pb::IMessage<LocalCopy> {
        private static readonly pb::MessageParser<LocalCopy> _parser = new pb::MessageParser<LocalCopy>(() => new LocalCopy());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LocalCopy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Genomics.V1Alpha2.PipelineParameter.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LocalCopy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LocalCopy(LocalCopy other) : this() {
          path_ = other.path_;
          disk_ = other.disk_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LocalCopy Clone() {
          return new LocalCopy(this);
        }

        /// <summary>Field number for the "path" field.</summary>
        public const int PathFieldNumber = 1;
        private string path_ = "";
        /// <summary>
        ///  Required. The path within the user's docker container where
        ///  this input should be localized to and from, relative to the specified
        ///  disk's mount point. For example: file.txt,
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Path {
          get { return path_; }
          set {
            path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "disk" field.</summary>
        public const int DiskFieldNumber = 2;
        private string disk_ = "";
        /// <summary>
        ///  Required. The name of the disk where this parameter is
        ///  located. Can be the name of one of the disks specified in the
        ///  Resources field, or "boot", which represents the Docker
        ///  instance's boot disk and has a mount point of `/`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Disk {
          get { return disk_; }
          set {
            disk_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LocalCopy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LocalCopy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Path != other.Path) return false;
          if (Disk != other.Disk) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Path.Length != 0) hash ^= Path.GetHashCode();
          if (Disk.Length != 0) hash ^= Disk.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Path.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Path);
          }
          if (Disk.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Disk);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Path.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
          }
          if (Disk.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Disk);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LocalCopy other) {
          if (other == null) {
            return;
          }
          if (other.Path.Length != 0) {
            Path = other.Path;
          }
          if (other.Disk.Length != 0) {
            Disk = other.Disk;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Path = input.ReadString();
                break;
              }
              case 18: {
                Disk = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  The Docker execuctor specification.
  /// </summary>
  public sealed partial class DockerExecutor : pb::IMessage<DockerExecutor> {
    private static readonly pb::MessageParser<DockerExecutor> _parser = new pb::MessageParser<DockerExecutor>(() => new DockerExecutor());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockerExecutor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Genomics.V1Alpha2.PipelinesReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockerExecutor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockerExecutor(DockerExecutor other) : this() {
      imageName_ = other.imageName_;
      cmd_ = other.cmd_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockerExecutor Clone() {
      return new DockerExecutor(this);
    }

    /// <summary>Field number for the "image_name" field.</summary>
    public const int ImageNameFieldNumber = 1;
    private string imageName_ = "";
    /// <summary>
    ///  Required. Image name from either Docker Hub or Google Container Repository.
    ///  Users that run pipelines must have READ access to the image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ImageName {
      get { return imageName_; }
      set {
        imageName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cmd" field.</summary>
    public const int CmdFieldNumber = 2;
    private string cmd_ = "";
    /// <summary>
    ///  Required. The command string to run. Parameters that do not have
    ///  `localCopy` specified should be used as environment variables, while
    ///  those that do can be accessed at the defined paths.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Cmd {
      get { return cmd_; }
      set {
        cmd_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockerExecutor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockerExecutor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ImageName != other.ImageName) return false;
      if (Cmd != other.Cmd) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ImageName.Length != 0) hash ^= ImageName.GetHashCode();
      if (Cmd.Length != 0) hash ^= Cmd.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ImageName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ImageName);
      }
      if (Cmd.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Cmd);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ImageName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImageName);
      }
      if (Cmd.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cmd);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockerExecutor other) {
      if (other == null) {
        return;
      }
      if (other.ImageName.Length != 0) {
        ImageName = other.ImageName;
      }
      if (other.Cmd.Length != 0) {
        Cmd = other.Cmd;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            ImageName = input.ReadString();
            break;
          }
          case 18: {
            Cmd = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
