// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/bigtable/v1/bigtable_data.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Bigtable.V1 {

  /// <summary>Holder for reflection information generated from google/bigtable/v1/bigtable_data.proto</summary>
  public static partial class BigtableDataReflection {

    #region Descriptor
    /// <summary>File descriptor for google/bigtable/v1/bigtable_data.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BigtableDataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiZnb29nbGUvYmlndGFibGUvdjEvYmlndGFibGVfZGF0YS5wcm90bxISZ29v",
            "Z2xlLmJpZ3RhYmxlLnYxIkAKA1JvdxILCgNrZXkYASABKAwSLAoIZmFtaWxp",
            "ZXMYAiADKAsyGi5nb29nbGUuYmlndGFibGUudjEuRmFtaWx5IkMKBkZhbWls",
            "eRIMCgRuYW1lGAEgASgJEisKB2NvbHVtbnMYAiADKAsyGi5nb29nbGUuYmln",
            "dGFibGUudjEuQ29sdW1uIkQKBkNvbHVtbhIRCglxdWFsaWZpZXIYASABKAwS",
            "JwoFY2VsbHMYAiADKAsyGC5nb29nbGUuYmlndGFibGUudjEuQ2VsbCI/CgRD",
            "ZWxsEhgKEHRpbWVzdGFtcF9taWNyb3MYASABKAMSDQoFdmFsdWUYAiABKAwS",
            "DgoGbGFiZWxzGAMgAygJIi4KCFJvd1JhbmdlEhEKCXN0YXJ0X2tleRgCIAEo",
            "DBIPCgdlbmRfa2V5GAMgASgMIkwKBlJvd1NldBIQCghyb3dfa2V5cxgBIAMo",
            "DBIwCgpyb3dfcmFuZ2VzGAIgAygLMhwuZ29vZ2xlLmJpZ3RhYmxlLnYxLlJv",
            "d1JhbmdlItYBCgtDb2x1bW5SYW5nZRITCgtmYW1pbHlfbmFtZRgBIAEoCRIj",
            "ChlzdGFydF9xdWFsaWZpZXJfaW5jbHVzaXZlGAIgASgMSAASIwoZc3RhcnRf",
            "cXVhbGlmaWVyX2V4Y2x1c2l2ZRgDIAEoDEgAEiEKF2VuZF9xdWFsaWZpZXJf",
            "aW5jbHVzaXZlGAQgASgMSAESIQoXZW5kX3F1YWxpZmllcl9leGNsdXNpdmUY",
            "BSABKAxIAUIRCg9zdGFydF9xdWFsaWZpZXJCDwoNZW5kX3F1YWxpZmllciJO",
            "Cg5UaW1lc3RhbXBSYW5nZRIeChZzdGFydF90aW1lc3RhbXBfbWljcm9zGAEg",
            "ASgDEhwKFGVuZF90aW1lc3RhbXBfbWljcm9zGAIgASgDIqgBCgpWYWx1ZVJh",
            "bmdlEh8KFXN0YXJ0X3ZhbHVlX2luY2x1c2l2ZRgBIAEoDEgAEh8KFXN0YXJ0",
            "X3ZhbHVlX2V4Y2x1c2l2ZRgCIAEoDEgAEh0KE2VuZF92YWx1ZV9pbmNsdXNp",
            "dmUYAyABKAxIARIdChNlbmRfdmFsdWVfZXhjbHVzaXZlGAQgASgMSAFCDQoL",
            "c3RhcnRfdmFsdWVCCwoJZW5kX3ZhbHVlIt8ICglSb3dGaWx0ZXISNAoFY2hh",
            "aW4YASABKAsyIy5nb29nbGUuYmlndGFibGUudjEuUm93RmlsdGVyLkNoYWlu",
            "SAASPgoKaW50ZXJsZWF2ZRgCIAEoCzIoLmdvb2dsZS5iaWd0YWJsZS52MS5S",
            "b3dGaWx0ZXIuSW50ZXJsZWF2ZUgAEjwKCWNvbmRpdGlvbhgDIAEoCzInLmdv",
            "b2dsZS5iaWd0YWJsZS52MS5Sb3dGaWx0ZXIuQ29uZGl0aW9uSAASDgoEc2lu",
            "axgQIAEoCEgAEhkKD3Bhc3NfYWxsX2ZpbHRlchgRIAEoCEgAEhoKEGJsb2Nr",
            "X2FsbF9maWx0ZXIYEiABKAhIABIeChRyb3dfa2V5X3JlZ2V4X2ZpbHRlchgE",
            "IAEoDEgAEhsKEXJvd19zYW1wbGVfZmlsdGVyGA4gASgBSAASIgoYZmFtaWx5",
            "X25hbWVfcmVnZXhfZmlsdGVyGAUgASgJSAASJwodY29sdW1uX3F1YWxpZmll",
            "cl9yZWdleF9maWx0ZXIYBiABKAxIABI+ChNjb2x1bW5fcmFuZ2VfZmlsdGVy",
            "GAcgASgLMh8uZ29vZ2xlLmJpZ3RhYmxlLnYxLkNvbHVtblJhbmdlSAASRAoW",
            "dGltZXN0YW1wX3JhbmdlX2ZpbHRlchgIIAEoCzIiLmdvb2dsZS5iaWd0YWJs",
            "ZS52MS5UaW1lc3RhbXBSYW5nZUgAEhwKEnZhbHVlX3JlZ2V4X2ZpbHRlchgJ",
            "IAEoDEgAEjwKEnZhbHVlX3JhbmdlX2ZpbHRlchgPIAEoCzIeLmdvb2dsZS5i",
            "aWd0YWJsZS52MS5WYWx1ZVJhbmdlSAASJQobY2VsbHNfcGVyX3Jvd19vZmZz",
            "ZXRfZmlsdGVyGAogASgFSAASJAoaY2VsbHNfcGVyX3Jvd19saW1pdF9maWx0",
            "ZXIYCyABKAVIABInCh1jZWxsc19wZXJfY29sdW1uX2xpbWl0X2ZpbHRlchgM",
            "IAEoBUgAEiEKF3N0cmlwX3ZhbHVlX3RyYW5zZm9ybWVyGA0gASgISAASIQoX",
            "YXBwbHlfbGFiZWxfdHJhbnNmb3JtZXIYEyABKAlIABo3CgVDaGFpbhIuCgdm",
            "aWx0ZXJzGAEgAygLMh0uZ29vZ2xlLmJpZ3RhYmxlLnYxLlJvd0ZpbHRlcho8",
            "CgpJbnRlcmxlYXZlEi4KB2ZpbHRlcnMYASADKAsyHS5nb29nbGUuYmlndGFi",
            "bGUudjEuUm93RmlsdGVyGq0BCglDb25kaXRpb24SNwoQcHJlZGljYXRlX2Zp",
            "bHRlchgBIAEoCzIdLmdvb2dsZS5iaWd0YWJsZS52MS5Sb3dGaWx0ZXISMgoL",
            "dHJ1ZV9maWx0ZXIYAiABKAsyHS5nb29nbGUuYmlndGFibGUudjEuUm93Rmls",
            "dGVyEjMKDGZhbHNlX2ZpbHRlchgDIAEoCzIdLmdvb2dsZS5iaWd0YWJsZS52",
            "MS5Sb3dGaWx0ZXJCCAoGZmlsdGVyIskECghNdXRhdGlvbhI4CghzZXRfY2Vs",
            "bBgBIAEoCzIkLmdvb2dsZS5iaWd0YWJsZS52MS5NdXRhdGlvbi5TZXRDZWxs",
            "SAASSwoSZGVsZXRlX2Zyb21fY29sdW1uGAIgASgLMi0uZ29vZ2xlLmJpZ3Rh",
            "YmxlLnYxLk11dGF0aW9uLkRlbGV0ZUZyb21Db2x1bW5IABJLChJkZWxldGVf",
            "ZnJvbV9mYW1pbHkYAyABKAsyLS5nb29nbGUuYmlndGFibGUudjEuTXV0YXRp",
            "b24uRGVsZXRlRnJvbUZhbWlseUgAEkUKD2RlbGV0ZV9mcm9tX3JvdxgEIAEo",
            "CzIqLmdvb2dsZS5iaWd0YWJsZS52MS5NdXRhdGlvbi5EZWxldGVGcm9tUm93",
            "SAAaYQoHU2V0Q2VsbBITCgtmYW1pbHlfbmFtZRgBIAEoCRIYChBjb2x1bW5f",
            "cXVhbGlmaWVyGAIgASgMEhgKEHRpbWVzdGFtcF9taWNyb3MYAyABKAMSDQoF",
            "dmFsdWUYBCABKAwaeQoQRGVsZXRlRnJvbUNvbHVtbhITCgtmYW1pbHlfbmFt",
            "ZRgBIAEoCRIYChBjb2x1bW5fcXVhbGlmaWVyGAIgASgMEjYKCnRpbWVfcmFu",
            "Z2UYAyABKAsyIi5nb29nbGUuYmlndGFibGUudjEuVGltZXN0YW1wUmFuZ2Ua",
            "JwoQRGVsZXRlRnJvbUZhbWlseRITCgtmYW1pbHlfbmFtZRgBIAEoCRoPCg1E",
            "ZWxldGVGcm9tUm93QgoKCG11dGF0aW9uIoABChNSZWFkTW9kaWZ5V3JpdGVS",
            "dWxlEhMKC2ZhbWlseV9uYW1lGAEgASgJEhgKEGNvbHVtbl9xdWFsaWZpZXIY",
            "AiABKAwSFgoMYXBwZW5kX3ZhbHVlGAMgASgMSAASGgoQaW5jcmVtZW50X2Ft",
            "b3VudBgEIAEoA0gAQgYKBHJ1bGVCaQoWY29tLmdvb2dsZS5iaWd0YWJsZS52",
            "MUIRQmlndGFibGVEYXRhUHJvdG9QAVo6Z29vZ2xlLmdvbGFuZy5vcmcvZ2Vu",
            "cHJvdG8vZ29vZ2xlYXBpcy9iaWd0YWJsZS92MTtiaWd0YWJsZWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Row), global::Google.Bigtable.V1.Row.Parser, new[]{ "Key", "Families" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Family), global::Google.Bigtable.V1.Family.Parser, new[]{ "Name", "Columns" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Column), global::Google.Bigtable.V1.Column.Parser, new[]{ "Qualifier", "Cells" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Cell), global::Google.Bigtable.V1.Cell.Parser, new[]{ "TimestampMicros", "Value", "Labels" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowRange), global::Google.Bigtable.V1.RowRange.Parser, new[]{ "StartKey", "EndKey" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowSet), global::Google.Bigtable.V1.RowSet.Parser, new[]{ "RowKeys", "RowRanges" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.ColumnRange), global::Google.Bigtable.V1.ColumnRange.Parser, new[]{ "FamilyName", "StartQualifierInclusive", "StartQualifierExclusive", "EndQualifierInclusive", "EndQualifierExclusive" }, new[]{ "StartQualifier", "EndQualifier" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.TimestampRange), global::Google.Bigtable.V1.TimestampRange.Parser, new[]{ "StartTimestampMicros", "EndTimestampMicros" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.ValueRange), global::Google.Bigtable.V1.ValueRange.Parser, new[]{ "StartValueInclusive", "StartValueExclusive", "EndValueInclusive", "EndValueExclusive" }, new[]{ "StartValue", "EndValue" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowFilter), global::Google.Bigtable.V1.RowFilter.Parser, new[]{ "Chain", "Interleave", "Condition", "Sink", "PassAllFilter", "BlockAllFilter", "RowKeyRegexFilter", "RowSampleFilter", "FamilyNameRegexFilter", "ColumnQualifierRegexFilter", "ColumnRangeFilter", "TimestampRangeFilter", "ValueRegexFilter", "ValueRangeFilter", "CellsPerRowOffsetFilter", "CellsPerRowLimitFilter", "CellsPerColumnLimitFilter", "StripValueTransformer", "ApplyLabelTransformer" }, new[]{ "Filter" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowFilter.Types.Chain), global::Google.Bigtable.V1.RowFilter.Types.Chain.Parser, new[]{ "Filters" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowFilter.Types.Interleave), global::Google.Bigtable.V1.RowFilter.Types.Interleave.Parser, new[]{ "Filters" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.RowFilter.Types.Condition), global::Google.Bigtable.V1.RowFilter.Types.Condition.Parser, new[]{ "PredicateFilter", "TrueFilter", "FalseFilter" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Mutation), global::Google.Bigtable.V1.Mutation.Parser, new[]{ "SetCell", "DeleteFromColumn", "DeleteFromFamily", "DeleteFromRow" }, new[]{ "Mutation" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Mutation.Types.SetCell), global::Google.Bigtable.V1.Mutation.Types.SetCell.Parser, new[]{ "FamilyName", "ColumnQualifier", "TimestampMicros", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn), global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn.Parser, new[]{ "FamilyName", "ColumnQualifier", "TimeRange" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily), global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily.Parser, new[]{ "FamilyName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow), global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Bigtable.V1.ReadModifyWriteRule), global::Google.Bigtable.V1.ReadModifyWriteRule.Parser, new[]{ "FamilyName", "ColumnQualifier", "AppendValue", "IncrementAmount" }, new[]{ "Rule" }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  Specifies the complete (requested) contents of a single row of a table.
  ///  Rows which exceed 256MiB in size cannot be read in full.
  /// </summary>
  public sealed partial class Row : pb::IMessage<Row> {
    private static readonly pb::MessageParser<Row> _parser = new pb::MessageParser<Row>(() => new Row());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Row> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row(Row other) : this() {
      key_ = other.key_;
      families_ = other.families_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row Clone() {
      return new Row(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private pb::ByteString key_ = pb::ByteString.Empty;
    /// <summary>
    ///  The unique key which identifies this row within its table. This is the same
    ///  key that's used to identify the row in, for example, a MutateRowRequest.
    ///  May contain any non-empty byte string up to 4KiB in length.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "families" field.</summary>
    public const int FamiliesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Bigtable.V1.Family> _repeated_families_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Bigtable.V1.Family.Parser);
    private readonly pbc::RepeatedField<global::Google.Bigtable.V1.Family> families_ = new pbc::RepeatedField<global::Google.Bigtable.V1.Family>();
    /// <summary>
    ///  May be empty, but only if the entire row is empty.
    ///  The mutual ordering of column families is not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Bigtable.V1.Family> Families {
      get { return families_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Row);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Row other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if(!families_.Equals(other.families_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      hash ^= families_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Key);
      }
      families_.WriteTo(output, _repeated_families_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
      }
      size += families_.CalculateSize(_repeated_families_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Row other) {
      if (other == null) {
        return;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      families_.Add(other.families_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Key = input.ReadBytes();
            break;
          }
          case 18: {
            families_.AddEntriesFrom(input, _repeated_families_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies (some of) the contents of a single row/column family of a table.
  /// </summary>
  public sealed partial class Family : pb::IMessage<Family> {
    private static readonly pb::MessageParser<Family> _parser = new pb::MessageParser<Family>(() => new Family());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Family> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Family() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Family(Family other) : this() {
      name_ = other.name_;
      columns_ = other.columns_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Family Clone() {
      return new Family(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///  The unique key which identifies this family within its row. This is the
    ///  same key that's used to identify the family in, for example, a RowFilter
    ///  which sets its "family_name_regex_filter" field.
    ///  Must match [-_.a-zA-Z0-9]+, except that AggregatingRowProcessors may
    ///  produce cells in a sentinel family with an empty name.
    ///  Must be no greater than 64 characters in length.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "columns" field.</summary>
    public const int ColumnsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Bigtable.V1.Column> _repeated_columns_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Bigtable.V1.Column.Parser);
    private readonly pbc::RepeatedField<global::Google.Bigtable.V1.Column> columns_ = new pbc::RepeatedField<global::Google.Bigtable.V1.Column>();
    /// <summary>
    ///  Must not be empty. Sorted in order of increasing "qualifier".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Bigtable.V1.Column> Columns {
      get { return columns_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Family);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Family other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!columns_.Equals(other.columns_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= columns_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      columns_.WriteTo(output, _repeated_columns_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += columns_.CalculateSize(_repeated_columns_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Family other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      columns_.Add(other.columns_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            columns_.AddEntriesFrom(input, _repeated_columns_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies (some of) the contents of a single row/column of a table.
  /// </summary>
  public sealed partial class Column : pb::IMessage<Column> {
    private static readonly pb::MessageParser<Column> _parser = new pb::MessageParser<Column>(() => new Column());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Column> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Column() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Column(Column other) : this() {
      qualifier_ = other.qualifier_;
      cells_ = other.cells_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Column Clone() {
      return new Column(this);
    }

    /// <summary>Field number for the "qualifier" field.</summary>
    public const int QualifierFieldNumber = 1;
    private pb::ByteString qualifier_ = pb::ByteString.Empty;
    /// <summary>
    ///  The unique key which identifies this column within its family. This is the
    ///  same key that's used to identify the column in, for example, a RowFilter
    ///  which sets its "column_qualifier_regex_filter" field.
    ///  May contain any byte string, including the empty string, up to 16kiB in
    ///  length.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Qualifier {
      get { return qualifier_; }
      set {
        qualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cells" field.</summary>
    public const int CellsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Bigtable.V1.Cell> _repeated_cells_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Bigtable.V1.Cell.Parser);
    private readonly pbc::RepeatedField<global::Google.Bigtable.V1.Cell> cells_ = new pbc::RepeatedField<global::Google.Bigtable.V1.Cell>();
    /// <summary>
    ///  Must not be empty. Sorted in order of decreasing "timestamp_micros".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Bigtable.V1.Cell> Cells {
      get { return cells_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Column);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Column other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Qualifier != other.Qualifier) return false;
      if(!cells_.Equals(other.cells_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Qualifier.Length != 0) hash ^= Qualifier.GetHashCode();
      hash ^= cells_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Qualifier.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Qualifier);
      }
      cells_.WriteTo(output, _repeated_cells_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Qualifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Qualifier);
      }
      size += cells_.CalculateSize(_repeated_cells_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Column other) {
      if (other == null) {
        return;
      }
      if (other.Qualifier.Length != 0) {
        Qualifier = other.Qualifier;
      }
      cells_.Add(other.cells_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Qualifier = input.ReadBytes();
            break;
          }
          case 18: {
            cells_.AddEntriesFrom(input, _repeated_cells_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies (some of) the contents of a single row/column/timestamp of a table.
  /// </summary>
  public sealed partial class Cell : pb::IMessage<Cell> {
    private static readonly pb::MessageParser<Cell> _parser = new pb::MessageParser<Cell>(() => new Cell());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Cell> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cell() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cell(Cell other) : this() {
      timestampMicros_ = other.timestampMicros_;
      value_ = other.value_;
      labels_ = other.labels_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cell Clone() {
      return new Cell(this);
    }

    /// <summary>Field number for the "timestamp_micros" field.</summary>
    public const int TimestampMicrosFieldNumber = 1;
    private long timestampMicros_;
    /// <summary>
    ///  The cell's stored timestamp, which also uniquely identifies it within
    ///  its column.
    ///  Values are always expressed in microseconds, but individual tables may set
    ///  a coarser "granularity" to further restrict the allowed values. For
    ///  example, a table which specifies millisecond granularity will only allow
    ///  values of "timestamp_micros" which are multiples of 1000.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TimestampMicros {
      get { return timestampMicros_; }
      set {
        timestampMicros_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private pb::ByteString value_ = pb::ByteString.Empty;
    /// <summary>
    ///  The value stored in the cell.
    ///  May contain any byte string, including the empty string, up to 100MiB in
    ///  length.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_labels_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> labels_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  Labels applied to the cell by a [RowFilter][google.bigtable.v1.RowFilter].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Cell);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Cell other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TimestampMicros != other.TimestampMicros) return false;
      if (Value != other.Value) return false;
      if(!labels_.Equals(other.labels_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (TimestampMicros != 0L) hash ^= TimestampMicros.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      hash ^= labels_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (TimestampMicros != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(TimestampMicros);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Value);
      }
      labels_.WriteTo(output, _repeated_labels_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (TimestampMicros != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TimestampMicros);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Value);
      }
      size += labels_.CalculateSize(_repeated_labels_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Cell other) {
      if (other == null) {
        return;
      }
      if (other.TimestampMicros != 0L) {
        TimestampMicros = other.TimestampMicros;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      labels_.Add(other.labels_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            TimestampMicros = input.ReadInt64();
            break;
          }
          case 18: {
            Value = input.ReadBytes();
            break;
          }
          case 26: {
            labels_.AddEntriesFrom(input, _repeated_labels_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies a contiguous range of rows.
  /// </summary>
  public sealed partial class RowRange : pb::IMessage<RowRange> {
    private static readonly pb::MessageParser<RowRange> _parser = new pb::MessageParser<RowRange>(() => new RowRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RowRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowRange(RowRange other) : this() {
      startKey_ = other.startKey_;
      endKey_ = other.endKey_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowRange Clone() {
      return new RowRange(this);
    }

    /// <summary>Field number for the "start_key" field.</summary>
    public const int StartKeyFieldNumber = 2;
    private pb::ByteString startKey_ = pb::ByteString.Empty;
    /// <summary>
    ///  Inclusive lower bound. If left empty, interpreted as the empty string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString StartKey {
      get { return startKey_; }
      set {
        startKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "end_key" field.</summary>
    public const int EndKeyFieldNumber = 3;
    private pb::ByteString endKey_ = pb::ByteString.Empty;
    /// <summary>
    ///  Exclusive upper bound. If left empty, interpreted as infinity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EndKey {
      get { return endKey_; }
      set {
        endKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RowRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RowRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartKey != other.StartKey) return false;
      if (EndKey != other.EndKey) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StartKey.Length != 0) hash ^= StartKey.GetHashCode();
      if (EndKey.Length != 0) hash ^= EndKey.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StartKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(StartKey);
      }
      if (EndKey.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(EndKey);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StartKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StartKey);
      }
      if (EndKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EndKey);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RowRange other) {
      if (other == null) {
        return;
      }
      if (other.StartKey.Length != 0) {
        StartKey = other.StartKey;
      }
      if (other.EndKey.Length != 0) {
        EndKey = other.EndKey;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 18: {
            StartKey = input.ReadBytes();
            break;
          }
          case 26: {
            EndKey = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies a non-contiguous set of rows.
  /// </summary>
  public sealed partial class RowSet : pb::IMessage<RowSet> {
    private static readonly pb::MessageParser<RowSet> _parser = new pb::MessageParser<RowSet>(() => new RowSet());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RowSet> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowSet() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowSet(RowSet other) : this() {
      rowKeys_ = other.rowKeys_.Clone();
      rowRanges_ = other.rowRanges_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowSet Clone() {
      return new RowSet(this);
    }

    /// <summary>Field number for the "row_keys" field.</summary>
    public const int RowKeysFieldNumber = 1;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_rowKeys_codec
        = pb::FieldCodec.ForBytes(10);
    private readonly pbc::RepeatedField<pb::ByteString> rowKeys_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    ///  Single rows included in the set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> RowKeys {
      get { return rowKeys_; }
    }

    /// <summary>Field number for the "row_ranges" field.</summary>
    public const int RowRangesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Bigtable.V1.RowRange> _repeated_rowRanges_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Bigtable.V1.RowRange.Parser);
    private readonly pbc::RepeatedField<global::Google.Bigtable.V1.RowRange> rowRanges_ = new pbc::RepeatedField<global::Google.Bigtable.V1.RowRange>();
    /// <summary>
    ///  Contiguous row ranges included in the set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Bigtable.V1.RowRange> RowRanges {
      get { return rowRanges_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RowSet);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RowSet other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!rowKeys_.Equals(other.rowKeys_)) return false;
      if(!rowRanges_.Equals(other.rowRanges_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= rowKeys_.GetHashCode();
      hash ^= rowRanges_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      rowKeys_.WriteTo(output, _repeated_rowKeys_codec);
      rowRanges_.WriteTo(output, _repeated_rowRanges_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += rowKeys_.CalculateSize(_repeated_rowKeys_codec);
      size += rowRanges_.CalculateSize(_repeated_rowRanges_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RowSet other) {
      if (other == null) {
        return;
      }
      rowKeys_.Add(other.rowKeys_);
      rowRanges_.Add(other.rowRanges_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            rowKeys_.AddEntriesFrom(input, _repeated_rowKeys_codec);
            break;
          }
          case 18: {
            rowRanges_.AddEntriesFrom(input, _repeated_rowRanges_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies a contiguous range of columns within a single column family.
  ///  The range spans from &lt;column_family>:&lt;start_qualifier> to
  ///  &lt;column_family>:&lt;end_qualifier>, where both bounds can be either inclusive or
  ///  exclusive.
  /// </summary>
  public sealed partial class ColumnRange : pb::IMessage<ColumnRange> {
    private static readonly pb::MessageParser<ColumnRange> _parser = new pb::MessageParser<ColumnRange>(() => new ColumnRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ColumnRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnRange(ColumnRange other) : this() {
      familyName_ = other.familyName_;
      switch (other.StartQualifierCase) {
        case StartQualifierOneofCase.StartQualifierInclusive:
          StartQualifierInclusive = other.StartQualifierInclusive;
          break;
        case StartQualifierOneofCase.StartQualifierExclusive:
          StartQualifierExclusive = other.StartQualifierExclusive;
          break;
      }

      switch (other.EndQualifierCase) {
        case EndQualifierOneofCase.EndQualifierInclusive:
          EndQualifierInclusive = other.EndQualifierInclusive;
          break;
        case EndQualifierOneofCase.EndQualifierExclusive:
          EndQualifierExclusive = other.EndQualifierExclusive;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnRange Clone() {
      return new ColumnRange(this);
    }

    /// <summary>Field number for the "family_name" field.</summary>
    public const int FamilyNameFieldNumber = 1;
    private string familyName_ = "";
    /// <summary>
    ///  The name of the column family within which this range falls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FamilyName {
      get { return familyName_; }
      set {
        familyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "start_qualifier_inclusive" field.</summary>
    public const int StartQualifierInclusiveFieldNumber = 2;
    /// <summary>
    ///  Used when giving an inclusive lower bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString StartQualifierInclusive {
      get { return startQualifierCase_ == StartQualifierOneofCase.StartQualifierInclusive ? (pb::ByteString) startQualifier_ : pb::ByteString.Empty; }
      set {
        startQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        startQualifierCase_ = StartQualifierOneofCase.StartQualifierInclusive;
      }
    }

    /// <summary>Field number for the "start_qualifier_exclusive" field.</summary>
    public const int StartQualifierExclusiveFieldNumber = 3;
    /// <summary>
    ///  Used when giving an exclusive lower bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString StartQualifierExclusive {
      get { return startQualifierCase_ == StartQualifierOneofCase.StartQualifierExclusive ? (pb::ByteString) startQualifier_ : pb::ByteString.Empty; }
      set {
        startQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        startQualifierCase_ = StartQualifierOneofCase.StartQualifierExclusive;
      }
    }

    /// <summary>Field number for the "end_qualifier_inclusive" field.</summary>
    public const int EndQualifierInclusiveFieldNumber = 4;
    /// <summary>
    ///  Used when giving an inclusive upper bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EndQualifierInclusive {
      get { return endQualifierCase_ == EndQualifierOneofCase.EndQualifierInclusive ? (pb::ByteString) endQualifier_ : pb::ByteString.Empty; }
      set {
        endQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        endQualifierCase_ = EndQualifierOneofCase.EndQualifierInclusive;
      }
    }

    /// <summary>Field number for the "end_qualifier_exclusive" field.</summary>
    public const int EndQualifierExclusiveFieldNumber = 5;
    /// <summary>
    ///  Used when giving an exclusive upper bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EndQualifierExclusive {
      get { return endQualifierCase_ == EndQualifierOneofCase.EndQualifierExclusive ? (pb::ByteString) endQualifier_ : pb::ByteString.Empty; }
      set {
        endQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        endQualifierCase_ = EndQualifierOneofCase.EndQualifierExclusive;
      }
    }

    private object startQualifier_;
    /// <summary>Enum of possible cases for the "start_qualifier" oneof.</summary>
    public enum StartQualifierOneofCase {
      None = 0,
      StartQualifierInclusive = 2,
      StartQualifierExclusive = 3,
    }
    private StartQualifierOneofCase startQualifierCase_ = StartQualifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StartQualifierOneofCase StartQualifierCase {
      get { return startQualifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStartQualifier() {
      startQualifierCase_ = StartQualifierOneofCase.None;
      startQualifier_ = null;
    }

    private object endQualifier_;
    /// <summary>Enum of possible cases for the "end_qualifier" oneof.</summary>
    public enum EndQualifierOneofCase {
      None = 0,
      EndQualifierInclusive = 4,
      EndQualifierExclusive = 5,
    }
    private EndQualifierOneofCase endQualifierCase_ = EndQualifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EndQualifierOneofCase EndQualifierCase {
      get { return endQualifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndQualifier() {
      endQualifierCase_ = EndQualifierOneofCase.None;
      endQualifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ColumnRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ColumnRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FamilyName != other.FamilyName) return false;
      if (StartQualifierInclusive != other.StartQualifierInclusive) return false;
      if (StartQualifierExclusive != other.StartQualifierExclusive) return false;
      if (EndQualifierInclusive != other.EndQualifierInclusive) return false;
      if (EndQualifierExclusive != other.EndQualifierExclusive) return false;
      if (StartQualifierCase != other.StartQualifierCase) return false;
      if (EndQualifierCase != other.EndQualifierCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FamilyName.Length != 0) hash ^= FamilyName.GetHashCode();
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierInclusive) hash ^= StartQualifierInclusive.GetHashCode();
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierExclusive) hash ^= StartQualifierExclusive.GetHashCode();
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierInclusive) hash ^= EndQualifierInclusive.GetHashCode();
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierExclusive) hash ^= EndQualifierExclusive.GetHashCode();
      hash ^= (int) startQualifierCase_;
      hash ^= (int) endQualifierCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (FamilyName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FamilyName);
      }
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierInclusive) {
        output.WriteRawTag(18);
        output.WriteBytes(StartQualifierInclusive);
      }
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierExclusive) {
        output.WriteRawTag(26);
        output.WriteBytes(StartQualifierExclusive);
      }
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierInclusive) {
        output.WriteRawTag(34);
        output.WriteBytes(EndQualifierInclusive);
      }
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierExclusive) {
        output.WriteRawTag(42);
        output.WriteBytes(EndQualifierExclusive);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FamilyName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyName);
      }
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierInclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StartQualifierInclusive);
      }
      if (startQualifierCase_ == StartQualifierOneofCase.StartQualifierExclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StartQualifierExclusive);
      }
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierInclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EndQualifierInclusive);
      }
      if (endQualifierCase_ == EndQualifierOneofCase.EndQualifierExclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EndQualifierExclusive);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ColumnRange other) {
      if (other == null) {
        return;
      }
      if (other.FamilyName.Length != 0) {
        FamilyName = other.FamilyName;
      }
      switch (other.StartQualifierCase) {
        case StartQualifierOneofCase.StartQualifierInclusive:
          StartQualifierInclusive = other.StartQualifierInclusive;
          break;
        case StartQualifierOneofCase.StartQualifierExclusive:
          StartQualifierExclusive = other.StartQualifierExclusive;
          break;
      }

      switch (other.EndQualifierCase) {
        case EndQualifierOneofCase.EndQualifierInclusive:
          EndQualifierInclusive = other.EndQualifierInclusive;
          break;
        case EndQualifierOneofCase.EndQualifierExclusive:
          EndQualifierExclusive = other.EndQualifierExclusive;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FamilyName = input.ReadString();
            break;
          }
          case 18: {
            StartQualifierInclusive = input.ReadBytes();
            break;
          }
          case 26: {
            StartQualifierExclusive = input.ReadBytes();
            break;
          }
          case 34: {
            EndQualifierInclusive = input.ReadBytes();
            break;
          }
          case 42: {
            EndQualifierExclusive = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specified a contiguous range of microsecond timestamps.
  /// </summary>
  public sealed partial class TimestampRange : pb::IMessage<TimestampRange> {
    private static readonly pb::MessageParser<TimestampRange> _parser = new pb::MessageParser<TimestampRange>(() => new TimestampRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimestampRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampRange(TimestampRange other) : this() {
      startTimestampMicros_ = other.startTimestampMicros_;
      endTimestampMicros_ = other.endTimestampMicros_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimestampRange Clone() {
      return new TimestampRange(this);
    }

    /// <summary>Field number for the "start_timestamp_micros" field.</summary>
    public const int StartTimestampMicrosFieldNumber = 1;
    private long startTimestampMicros_;
    /// <summary>
    ///  Inclusive lower bound. If left empty, interpreted as 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long StartTimestampMicros {
      get { return startTimestampMicros_; }
      set {
        startTimestampMicros_ = value;
      }
    }

    /// <summary>Field number for the "end_timestamp_micros" field.</summary>
    public const int EndTimestampMicrosFieldNumber = 2;
    private long endTimestampMicros_;
    /// <summary>
    ///  Exclusive upper bound. If left empty, interpreted as infinity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long EndTimestampMicros {
      get { return endTimestampMicros_; }
      set {
        endTimestampMicros_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimestampRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimestampRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartTimestampMicros != other.StartTimestampMicros) return false;
      if (EndTimestampMicros != other.EndTimestampMicros) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StartTimestampMicros != 0L) hash ^= StartTimestampMicros.GetHashCode();
      if (EndTimestampMicros != 0L) hash ^= EndTimestampMicros.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StartTimestampMicros != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(StartTimestampMicros);
      }
      if (EndTimestampMicros != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(EndTimestampMicros);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StartTimestampMicros != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StartTimestampMicros);
      }
      if (EndTimestampMicros != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(EndTimestampMicros);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimestampRange other) {
      if (other == null) {
        return;
      }
      if (other.StartTimestampMicros != 0L) {
        StartTimestampMicros = other.StartTimestampMicros;
      }
      if (other.EndTimestampMicros != 0L) {
        EndTimestampMicros = other.EndTimestampMicros;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            StartTimestampMicros = input.ReadInt64();
            break;
          }
          case 16: {
            EndTimestampMicros = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Specifies a contiguous range of raw byte values.
  /// </summary>
  public sealed partial class ValueRange : pb::IMessage<ValueRange> {
    private static readonly pb::MessageParser<ValueRange> _parser = new pb::MessageParser<ValueRange>(() => new ValueRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueRange(ValueRange other) : this() {
      switch (other.StartValueCase) {
        case StartValueOneofCase.StartValueInclusive:
          StartValueInclusive = other.StartValueInclusive;
          break;
        case StartValueOneofCase.StartValueExclusive:
          StartValueExclusive = other.StartValueExclusive;
          break;
      }

      switch (other.EndValueCase) {
        case EndValueOneofCase.EndValueInclusive:
          EndValueInclusive = other.EndValueInclusive;
          break;
        case EndValueOneofCase.EndValueExclusive:
          EndValueExclusive = other.EndValueExclusive;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueRange Clone() {
      return new ValueRange(this);
    }

    /// <summary>Field number for the "start_value_inclusive" field.</summary>
    public const int StartValueInclusiveFieldNumber = 1;
    /// <summary>
    ///  Used when giving an inclusive lower bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString StartValueInclusive {
      get { return startValueCase_ == StartValueOneofCase.StartValueInclusive ? (pb::ByteString) startValue_ : pb::ByteString.Empty; }
      set {
        startValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        startValueCase_ = StartValueOneofCase.StartValueInclusive;
      }
    }

    /// <summary>Field number for the "start_value_exclusive" field.</summary>
    public const int StartValueExclusiveFieldNumber = 2;
    /// <summary>
    ///  Used when giving an exclusive lower bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString StartValueExclusive {
      get { return startValueCase_ == StartValueOneofCase.StartValueExclusive ? (pb::ByteString) startValue_ : pb::ByteString.Empty; }
      set {
        startValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        startValueCase_ = StartValueOneofCase.StartValueExclusive;
      }
    }

    /// <summary>Field number for the "end_value_inclusive" field.</summary>
    public const int EndValueInclusiveFieldNumber = 3;
    /// <summary>
    ///  Used when giving an inclusive upper bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EndValueInclusive {
      get { return endValueCase_ == EndValueOneofCase.EndValueInclusive ? (pb::ByteString) endValue_ : pb::ByteString.Empty; }
      set {
        endValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        endValueCase_ = EndValueOneofCase.EndValueInclusive;
      }
    }

    /// <summary>Field number for the "end_value_exclusive" field.</summary>
    public const int EndValueExclusiveFieldNumber = 4;
    /// <summary>
    ///  Used when giving an exclusive upper bound for the range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EndValueExclusive {
      get { return endValueCase_ == EndValueOneofCase.EndValueExclusive ? (pb::ByteString) endValue_ : pb::ByteString.Empty; }
      set {
        endValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        endValueCase_ = EndValueOneofCase.EndValueExclusive;
      }
    }

    private object startValue_;
    /// <summary>Enum of possible cases for the "start_value" oneof.</summary>
    public enum StartValueOneofCase {
      None = 0,
      StartValueInclusive = 1,
      StartValueExclusive = 2,
    }
    private StartValueOneofCase startValueCase_ = StartValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StartValueOneofCase StartValueCase {
      get { return startValueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStartValue() {
      startValueCase_ = StartValueOneofCase.None;
      startValue_ = null;
    }

    private object endValue_;
    /// <summary>Enum of possible cases for the "end_value" oneof.</summary>
    public enum EndValueOneofCase {
      None = 0,
      EndValueInclusive = 3,
      EndValueExclusive = 4,
    }
    private EndValueOneofCase endValueCase_ = EndValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EndValueOneofCase EndValueCase {
      get { return endValueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndValue() {
      endValueCase_ = EndValueOneofCase.None;
      endValue_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartValueInclusive != other.StartValueInclusive) return false;
      if (StartValueExclusive != other.StartValueExclusive) return false;
      if (EndValueInclusive != other.EndValueInclusive) return false;
      if (EndValueExclusive != other.EndValueExclusive) return false;
      if (StartValueCase != other.StartValueCase) return false;
      if (EndValueCase != other.EndValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (startValueCase_ == StartValueOneofCase.StartValueInclusive) hash ^= StartValueInclusive.GetHashCode();
      if (startValueCase_ == StartValueOneofCase.StartValueExclusive) hash ^= StartValueExclusive.GetHashCode();
      if (endValueCase_ == EndValueOneofCase.EndValueInclusive) hash ^= EndValueInclusive.GetHashCode();
      if (endValueCase_ == EndValueOneofCase.EndValueExclusive) hash ^= EndValueExclusive.GetHashCode();
      hash ^= (int) startValueCase_;
      hash ^= (int) endValueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (startValueCase_ == StartValueOneofCase.StartValueInclusive) {
        output.WriteRawTag(10);
        output.WriteBytes(StartValueInclusive);
      }
      if (startValueCase_ == StartValueOneofCase.StartValueExclusive) {
        output.WriteRawTag(18);
        output.WriteBytes(StartValueExclusive);
      }
      if (endValueCase_ == EndValueOneofCase.EndValueInclusive) {
        output.WriteRawTag(26);
        output.WriteBytes(EndValueInclusive);
      }
      if (endValueCase_ == EndValueOneofCase.EndValueExclusive) {
        output.WriteRawTag(34);
        output.WriteBytes(EndValueExclusive);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (startValueCase_ == StartValueOneofCase.StartValueInclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StartValueInclusive);
      }
      if (startValueCase_ == StartValueOneofCase.StartValueExclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StartValueExclusive);
      }
      if (endValueCase_ == EndValueOneofCase.EndValueInclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EndValueInclusive);
      }
      if (endValueCase_ == EndValueOneofCase.EndValueExclusive) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EndValueExclusive);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueRange other) {
      if (other == null) {
        return;
      }
      switch (other.StartValueCase) {
        case StartValueOneofCase.StartValueInclusive:
          StartValueInclusive = other.StartValueInclusive;
          break;
        case StartValueOneofCase.StartValueExclusive:
          StartValueExclusive = other.StartValueExclusive;
          break;
      }

      switch (other.EndValueCase) {
        case EndValueOneofCase.EndValueInclusive:
          EndValueInclusive = other.EndValueInclusive;
          break;
        case EndValueOneofCase.EndValueExclusive:
          EndValueExclusive = other.EndValueExclusive;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            StartValueInclusive = input.ReadBytes();
            break;
          }
          case 18: {
            StartValueExclusive = input.ReadBytes();
            break;
          }
          case 26: {
            EndValueInclusive = input.ReadBytes();
            break;
          }
          case 34: {
            EndValueExclusive = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Takes a row as input and produces an alternate view of the row based on
  ///  specified rules. For example, a RowFilter might trim down a row to include
  ///  just the cells from columns matching a given regular expression, or might
  ///  return all the cells of a row but not their values. More complicated filters
  ///  can be composed out of these components to express requests such as, "within
  ///  every column of a particular family, give just the two most recent cells
  ///  which are older than timestamp X."
  ///
  ///  There are two broad categories of RowFilters (true filters and transformers),
  ///  as well as two ways to compose simple filters into more complex ones
  ///  (chains and interleaves). They work as follows:
  ///
  ///  * True filters alter the input row by excluding some of its cells wholesale
  ///  from the output row. An example of a true filter is the "value_regex_filter",
  ///  which excludes cells whose values don't match the specified pattern. All
  ///  regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
  ///  in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
  ///  important point to keep in mind is that RE2(.) is equivalent by default to
  ///  RE2([^\n]), meaning that it does not match newlines. When attempting to match
  ///  an arbitrary byte, you should therefore use the escape sequence '\C', which
  ///  may need to be further escaped as '\\C' in your client language.
  ///
  ///  * Transformers alter the input row by changing the values of some of its
  ///  cells in the output, without excluding them completely. Currently, the only
  ///  supported transformer is the "strip_value_transformer", which replaces every
  ///  cell's value with the empty string.
  ///
  ///  * Chains and interleaves are described in more detail in the
  ///  RowFilter.Chain and RowFilter.Interleave documentation.
  ///
  ///  The total serialized size of a RowFilter message must not
  ///  exceed 4096 bytes, and RowFilters may not be nested within each other
  ///  (in Chains or Interleaves) to a depth of more than 20.
  /// </summary>
  public sealed partial class RowFilter : pb::IMessage<RowFilter> {
    private static readonly pb::MessageParser<RowFilter> _parser = new pb::MessageParser<RowFilter>(() => new RowFilter());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RowFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowFilter(RowFilter other) : this() {
      switch (other.FilterCase) {
        case FilterOneofCase.Chain:
          Chain = other.Chain.Clone();
          break;
        case FilterOneofCase.Interleave:
          Interleave = other.Interleave.Clone();
          break;
        case FilterOneofCase.Condition:
          Condition = other.Condition.Clone();
          break;
        case FilterOneofCase.Sink:
          Sink = other.Sink;
          break;
        case FilterOneofCase.PassAllFilter:
          PassAllFilter = other.PassAllFilter;
          break;
        case FilterOneofCase.BlockAllFilter:
          BlockAllFilter = other.BlockAllFilter;
          break;
        case FilterOneofCase.RowKeyRegexFilter:
          RowKeyRegexFilter = other.RowKeyRegexFilter;
          break;
        case FilterOneofCase.RowSampleFilter:
          RowSampleFilter = other.RowSampleFilter;
          break;
        case FilterOneofCase.FamilyNameRegexFilter:
          FamilyNameRegexFilter = other.FamilyNameRegexFilter;
          break;
        case FilterOneofCase.ColumnQualifierRegexFilter:
          ColumnQualifierRegexFilter = other.ColumnQualifierRegexFilter;
          break;
        case FilterOneofCase.ColumnRangeFilter:
          ColumnRangeFilter = other.ColumnRangeFilter.Clone();
          break;
        case FilterOneofCase.TimestampRangeFilter:
          TimestampRangeFilter = other.TimestampRangeFilter.Clone();
          break;
        case FilterOneofCase.ValueRegexFilter:
          ValueRegexFilter = other.ValueRegexFilter;
          break;
        case FilterOneofCase.ValueRangeFilter:
          ValueRangeFilter = other.ValueRangeFilter.Clone();
          break;
        case FilterOneofCase.CellsPerRowOffsetFilter:
          CellsPerRowOffsetFilter = other.CellsPerRowOffsetFilter;
          break;
        case FilterOneofCase.CellsPerRowLimitFilter:
          CellsPerRowLimitFilter = other.CellsPerRowLimitFilter;
          break;
        case FilterOneofCase.CellsPerColumnLimitFilter:
          CellsPerColumnLimitFilter = other.CellsPerColumnLimitFilter;
          break;
        case FilterOneofCase.StripValueTransformer:
          StripValueTransformer = other.StripValueTransformer;
          break;
        case FilterOneofCase.ApplyLabelTransformer:
          ApplyLabelTransformer = other.ApplyLabelTransformer;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RowFilter Clone() {
      return new RowFilter(this);
    }

    /// <summary>Field number for the "chain" field.</summary>
    public const int ChainFieldNumber = 1;
    /// <summary>
    ///  Applies several RowFilters to the data in sequence, progressively
    ///  narrowing the results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.RowFilter.Types.Chain Chain {
      get { return filterCase_ == FilterOneofCase.Chain ? (global::Google.Bigtable.V1.RowFilter.Types.Chain) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.Chain;
      }
    }

    /// <summary>Field number for the "interleave" field.</summary>
    public const int InterleaveFieldNumber = 2;
    /// <summary>
    ///  Applies several RowFilters to the data in parallel and combines the
    ///  results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.RowFilter.Types.Interleave Interleave {
      get { return filterCase_ == FilterOneofCase.Interleave ? (global::Google.Bigtable.V1.RowFilter.Types.Interleave) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.Interleave;
      }
    }

    /// <summary>Field number for the "condition" field.</summary>
    public const int ConditionFieldNumber = 3;
    /// <summary>
    ///  Applies one of two possible RowFilters to the data based on the output of
    ///  a predicate RowFilter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.RowFilter.Types.Condition Condition {
      get { return filterCase_ == FilterOneofCase.Condition ? (global::Google.Bigtable.V1.RowFilter.Types.Condition) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.Condition;
      }
    }

    /// <summary>Field number for the "sink" field.</summary>
    public const int SinkFieldNumber = 16;
    /// <summary>
    ///  ADVANCED USE ONLY.
    ///  Hook for introspection into the RowFilter. Outputs all cells directly to
    ///  the output of the read rather than to any parent filter. Consider the
    ///  following example:
    ///
    ///  Chain(
    ///    FamilyRegex("A"),
    ///    Interleave(
    ///      All(),
    ///      Chain(Label("foo"), Sink())
    ///    ),
    ///    QualifierRegex("B")
    ///  )
    ///
    ///                          A,A,1,w
    ///                          A,B,2,x
    ///                          B,B,4,z
    ///                             |
    ///                      FamilyRegex("A")
    ///                             |
    ///                          A,A,1,w
    ///                          A,B,2,x
    ///                             |
    ///                +------------+-------------+
    ///                |                          |
    ///              All()                    Label(foo)
    ///                |                          |
    ///             A,A,1,w              A,A,1,w,labels:[foo]
    ///             A,B,2,x              A,B,2,x,labels:[foo]
    ///                |                          |
    ///                |                        Sink() --------------+
    ///                |                          |                  |
    ///                +------------+      x------+          A,A,1,w,labels:[foo]
    ///                             |                        A,B,2,x,labels:[foo]
    ///                          A,A,1,w                             |
    ///                          A,B,2,x                             |
    ///                             |                                |
    ///                     QualifierRegex("B")                      |
    ///                             |                                |
    ///                          A,B,2,x                             |
    ///                             |                                |
    ///                             +--------------------------------+
    ///                             |
    ///                          A,A,1,w,labels:[foo]
    ///                          A,B,2,x,labels:[foo]  // could be switched
    ///                          A,B,2,x               // could be switched
    ///
    ///  Despite being excluded by the qualifier filter, a copy of every cell
    ///  that reaches the sink is present in the final result.
    ///
    ///  As with an [Interleave][google.bigtable.v1.RowFilter.Interleave],
    ///  duplicate cells are possible, and appear in an unspecified mutual order.
    ///  In this case we have a duplicate with column "A:B" and timestamp 2,
    ///  because one copy passed through the all filter while the other was
    ///  passed through the label and sink. Note that one copy has label "foo",
    ///  while the other does not.
    ///
    ///  Cannot be used within the `predicate_filter`, `true_filter`, or
    ///  `false_filter` of a [Condition][google.bigtable.v1.RowFilter.Condition].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Sink {
      get { return filterCase_ == FilterOneofCase.Sink ? (bool) filter_ : false; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.Sink;
      }
    }

    /// <summary>Field number for the "pass_all_filter" field.</summary>
    public const int PassAllFilterFieldNumber = 17;
    /// <summary>
    ///  Matches all cells, regardless of input. Functionally equivalent to
    ///  leaving `filter` unset, but included for completeness.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PassAllFilter {
      get { return filterCase_ == FilterOneofCase.PassAllFilter ? (bool) filter_ : false; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.PassAllFilter;
      }
    }

    /// <summary>Field number for the "block_all_filter" field.</summary>
    public const int BlockAllFilterFieldNumber = 18;
    /// <summary>
    ///  Does not match any cells, regardless of input. Useful for temporarily
    ///  disabling just part of a filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BlockAllFilter {
      get { return filterCase_ == FilterOneofCase.BlockAllFilter ? (bool) filter_ : false; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.BlockAllFilter;
      }
    }

    /// <summary>Field number for the "row_key_regex_filter" field.</summary>
    public const int RowKeyRegexFilterFieldNumber = 4;
    /// <summary>
    ///  Matches only cells from rows whose keys satisfy the given RE2 regex. In
    ///  other words, passes through the entire row when the key matches, and
    ///  otherwise produces an empty row.
    ///  Note that, since row keys can contain arbitrary bytes, the '\C' escape
    ///  sequence must be used if a true wildcard is desired. The '.' character
    ///  will not match the new line character '\n', which may be present in a
    ///  binary key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString RowKeyRegexFilter {
      get { return filterCase_ == FilterOneofCase.RowKeyRegexFilter ? (pb::ByteString) filter_ : pb::ByteString.Empty; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        filterCase_ = FilterOneofCase.RowKeyRegexFilter;
      }
    }

    /// <summary>Field number for the "row_sample_filter" field.</summary>
    public const int RowSampleFilterFieldNumber = 14;
    /// <summary>
    ///  Matches all cells from a row with probability p, and matches no cells
    ///  from the row with probability 1-p.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double RowSampleFilter {
      get { return filterCase_ == FilterOneofCase.RowSampleFilter ? (double) filter_ : 0D; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.RowSampleFilter;
      }
    }

    /// <summary>Field number for the "family_name_regex_filter" field.</summary>
    public const int FamilyNameRegexFilterFieldNumber = 5;
    /// <summary>
    ///  Matches only cells from columns whose families satisfy the given RE2
    ///  regex. For technical reasons, the regex must not contain the ':'
    ///  character, even if it is not being used as a literal.
    ///  Note that, since column families cannot contain the new line character
    ///  '\n', it is sufficient to use '.' as a full wildcard when matching
    ///  column family names.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FamilyNameRegexFilter {
      get { return filterCase_ == FilterOneofCase.FamilyNameRegexFilter ? (string) filter_ : ""; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        filterCase_ = FilterOneofCase.FamilyNameRegexFilter;
      }
    }

    /// <summary>Field number for the "column_qualifier_regex_filter" field.</summary>
    public const int ColumnQualifierRegexFilterFieldNumber = 6;
    /// <summary>
    ///  Matches only cells from columns whose qualifiers satisfy the given RE2
    ///  regex.
    ///  Note that, since column qualifiers can contain arbitrary bytes, the '\C'
    ///  escape sequence must be used if a true wildcard is desired. The '.'
    ///  character will not match the new line character '\n', which may be
    ///  present in a binary qualifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ColumnQualifierRegexFilter {
      get { return filterCase_ == FilterOneofCase.ColumnQualifierRegexFilter ? (pb::ByteString) filter_ : pb::ByteString.Empty; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        filterCase_ = FilterOneofCase.ColumnQualifierRegexFilter;
      }
    }

    /// <summary>Field number for the "column_range_filter" field.</summary>
    public const int ColumnRangeFilterFieldNumber = 7;
    /// <summary>
    ///  Matches only cells from columns within the given range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.ColumnRange ColumnRangeFilter {
      get { return filterCase_ == FilterOneofCase.ColumnRangeFilter ? (global::Google.Bigtable.V1.ColumnRange) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.ColumnRangeFilter;
      }
    }

    /// <summary>Field number for the "timestamp_range_filter" field.</summary>
    public const int TimestampRangeFilterFieldNumber = 8;
    /// <summary>
    ///  Matches only cells with timestamps within the given range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.TimestampRange TimestampRangeFilter {
      get { return filterCase_ == FilterOneofCase.TimestampRangeFilter ? (global::Google.Bigtable.V1.TimestampRange) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.TimestampRangeFilter;
      }
    }

    /// <summary>Field number for the "value_regex_filter" field.</summary>
    public const int ValueRegexFilterFieldNumber = 9;
    /// <summary>
    ///  Matches only cells with values that satisfy the given regular expression.
    ///  Note that, since cell values can contain arbitrary bytes, the '\C' escape
    ///  sequence must be used if a true wildcard is desired. The '.' character
    ///  will not match the new line character '\n', which may be present in a
    ///  binary value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ValueRegexFilter {
      get { return filterCase_ == FilterOneofCase.ValueRegexFilter ? (pb::ByteString) filter_ : pb::ByteString.Empty; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        filterCase_ = FilterOneofCase.ValueRegexFilter;
      }
    }

    /// <summary>Field number for the "value_range_filter" field.</summary>
    public const int ValueRangeFilterFieldNumber = 15;
    /// <summary>
    ///  Matches only cells with values that fall within the given range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.ValueRange ValueRangeFilter {
      get { return filterCase_ == FilterOneofCase.ValueRangeFilter ? (global::Google.Bigtable.V1.ValueRange) filter_ : null; }
      set {
        filter_ = value;
        filterCase_ = value == null ? FilterOneofCase.None : FilterOneofCase.ValueRangeFilter;
      }
    }

    /// <summary>Field number for the "cells_per_row_offset_filter" field.</summary>
    public const int CellsPerRowOffsetFilterFieldNumber = 10;
    /// <summary>
    ///  Skips the first N cells of each row, matching all subsequent cells.
    ///  If duplicate cells are present, as is possible when using an Interleave,
    ///  each copy of the cell is counted separately.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CellsPerRowOffsetFilter {
      get { return filterCase_ == FilterOneofCase.CellsPerRowOffsetFilter ? (int) filter_ : 0; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.CellsPerRowOffsetFilter;
      }
    }

    /// <summary>Field number for the "cells_per_row_limit_filter" field.</summary>
    public const int CellsPerRowLimitFilterFieldNumber = 11;
    /// <summary>
    ///  Matches only the first N cells of each row.
    ///  If duplicate cells are present, as is possible when using an Interleave,
    ///  each copy of the cell is counted separately.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CellsPerRowLimitFilter {
      get { return filterCase_ == FilterOneofCase.CellsPerRowLimitFilter ? (int) filter_ : 0; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.CellsPerRowLimitFilter;
      }
    }

    /// <summary>Field number for the "cells_per_column_limit_filter" field.</summary>
    public const int CellsPerColumnLimitFilterFieldNumber = 12;
    /// <summary>
    ///  Matches only the most recent N cells within each column. For example,
    ///  if N=2, this filter would match column "foo:bar" at timestamps 10 and 9,
    ///  skip all earlier cells in "foo:bar", and then begin matching again in
    ///  column "foo:bar2".
    ///  If duplicate cells are present, as is possible when using an Interleave,
    ///  each copy of the cell is counted separately.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CellsPerColumnLimitFilter {
      get { return filterCase_ == FilterOneofCase.CellsPerColumnLimitFilter ? (int) filter_ : 0; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.CellsPerColumnLimitFilter;
      }
    }

    /// <summary>Field number for the "strip_value_transformer" field.</summary>
    public const int StripValueTransformerFieldNumber = 13;
    /// <summary>
    ///  Replaces each cell's value with the empty string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StripValueTransformer {
      get { return filterCase_ == FilterOneofCase.StripValueTransformer ? (bool) filter_ : false; }
      set {
        filter_ = value;
        filterCase_ = FilterOneofCase.StripValueTransformer;
      }
    }

    /// <summary>Field number for the "apply_label_transformer" field.</summary>
    public const int ApplyLabelTransformerFieldNumber = 19;
    /// <summary>
    ///  Applies the given label to all cells in the output row. This allows
    ///  the client to determine which results were produced from which part of
    ///  the filter.
    ///
    ///  Values must be at most 15 characters in length, and match the RE2
    ///  pattern [a-z0-9\\-]+
    ///
    ///  Due to a technical limitation, it is not currently possible to apply
    ///  multiple labels to a cell. As a result, a Chain may have no more than
    ///  one sub-filter which contains a apply_label_transformer. It is okay for
    ///  an Interleave to contain multiple apply_label_transformers, as they will
    ///  be applied to separate copies of the input. This may be relaxed in the
    ///  future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ApplyLabelTransformer {
      get { return filterCase_ == FilterOneofCase.ApplyLabelTransformer ? (string) filter_ : ""; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        filterCase_ = FilterOneofCase.ApplyLabelTransformer;
      }
    }

    private object filter_;
    /// <summary>Enum of possible cases for the "filter" oneof.</summary>
    public enum FilterOneofCase {
      None = 0,
      Chain = 1,
      Interleave = 2,
      Condition = 3,
      Sink = 16,
      PassAllFilter = 17,
      BlockAllFilter = 18,
      RowKeyRegexFilter = 4,
      RowSampleFilter = 14,
      FamilyNameRegexFilter = 5,
      ColumnQualifierRegexFilter = 6,
      ColumnRangeFilter = 7,
      TimestampRangeFilter = 8,
      ValueRegexFilter = 9,
      ValueRangeFilter = 15,
      CellsPerRowOffsetFilter = 10,
      CellsPerRowLimitFilter = 11,
      CellsPerColumnLimitFilter = 12,
      StripValueTransformer = 13,
      ApplyLabelTransformer = 19,
    }
    private FilterOneofCase filterCase_ = FilterOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FilterOneofCase FilterCase {
      get { return filterCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFilter() {
      filterCase_ = FilterOneofCase.None;
      filter_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RowFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RowFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Chain, other.Chain)) return false;
      if (!object.Equals(Interleave, other.Interleave)) return false;
      if (!object.Equals(Condition, other.Condition)) return false;
      if (Sink != other.Sink) return false;
      if (PassAllFilter != other.PassAllFilter) return false;
      if (BlockAllFilter != other.BlockAllFilter) return false;
      if (RowKeyRegexFilter != other.RowKeyRegexFilter) return false;
      if (RowSampleFilter != other.RowSampleFilter) return false;
      if (FamilyNameRegexFilter != other.FamilyNameRegexFilter) return false;
      if (ColumnQualifierRegexFilter != other.ColumnQualifierRegexFilter) return false;
      if (!object.Equals(ColumnRangeFilter, other.ColumnRangeFilter)) return false;
      if (!object.Equals(TimestampRangeFilter, other.TimestampRangeFilter)) return false;
      if (ValueRegexFilter != other.ValueRegexFilter) return false;
      if (!object.Equals(ValueRangeFilter, other.ValueRangeFilter)) return false;
      if (CellsPerRowOffsetFilter != other.CellsPerRowOffsetFilter) return false;
      if (CellsPerRowLimitFilter != other.CellsPerRowLimitFilter) return false;
      if (CellsPerColumnLimitFilter != other.CellsPerColumnLimitFilter) return false;
      if (StripValueTransformer != other.StripValueTransformer) return false;
      if (ApplyLabelTransformer != other.ApplyLabelTransformer) return false;
      if (FilterCase != other.FilterCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (filterCase_ == FilterOneofCase.Chain) hash ^= Chain.GetHashCode();
      if (filterCase_ == FilterOneofCase.Interleave) hash ^= Interleave.GetHashCode();
      if (filterCase_ == FilterOneofCase.Condition) hash ^= Condition.GetHashCode();
      if (filterCase_ == FilterOneofCase.Sink) hash ^= Sink.GetHashCode();
      if (filterCase_ == FilterOneofCase.PassAllFilter) hash ^= PassAllFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.BlockAllFilter) hash ^= BlockAllFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.RowKeyRegexFilter) hash ^= RowKeyRegexFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.RowSampleFilter) hash ^= RowSampleFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.FamilyNameRegexFilter) hash ^= FamilyNameRegexFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.ColumnQualifierRegexFilter) hash ^= ColumnQualifierRegexFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.ColumnRangeFilter) hash ^= ColumnRangeFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.TimestampRangeFilter) hash ^= TimestampRangeFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.ValueRegexFilter) hash ^= ValueRegexFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.ValueRangeFilter) hash ^= ValueRangeFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.CellsPerRowOffsetFilter) hash ^= CellsPerRowOffsetFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.CellsPerRowLimitFilter) hash ^= CellsPerRowLimitFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.CellsPerColumnLimitFilter) hash ^= CellsPerColumnLimitFilter.GetHashCode();
      if (filterCase_ == FilterOneofCase.StripValueTransformer) hash ^= StripValueTransformer.GetHashCode();
      if (filterCase_ == FilterOneofCase.ApplyLabelTransformer) hash ^= ApplyLabelTransformer.GetHashCode();
      hash ^= (int) filterCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (filterCase_ == FilterOneofCase.Chain) {
        output.WriteRawTag(10);
        output.WriteMessage(Chain);
      }
      if (filterCase_ == FilterOneofCase.Interleave) {
        output.WriteRawTag(18);
        output.WriteMessage(Interleave);
      }
      if (filterCase_ == FilterOneofCase.Condition) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (filterCase_ == FilterOneofCase.RowKeyRegexFilter) {
        output.WriteRawTag(34);
        output.WriteBytes(RowKeyRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.FamilyNameRegexFilter) {
        output.WriteRawTag(42);
        output.WriteString(FamilyNameRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.ColumnQualifierRegexFilter) {
        output.WriteRawTag(50);
        output.WriteBytes(ColumnQualifierRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.ColumnRangeFilter) {
        output.WriteRawTag(58);
        output.WriteMessage(ColumnRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.TimestampRangeFilter) {
        output.WriteRawTag(66);
        output.WriteMessage(TimestampRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.ValueRegexFilter) {
        output.WriteRawTag(74);
        output.WriteBytes(ValueRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerRowOffsetFilter) {
        output.WriteRawTag(80);
        output.WriteInt32(CellsPerRowOffsetFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerRowLimitFilter) {
        output.WriteRawTag(88);
        output.WriteInt32(CellsPerRowLimitFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerColumnLimitFilter) {
        output.WriteRawTag(96);
        output.WriteInt32(CellsPerColumnLimitFilter);
      }
      if (filterCase_ == FilterOneofCase.StripValueTransformer) {
        output.WriteRawTag(104);
        output.WriteBool(StripValueTransformer);
      }
      if (filterCase_ == FilterOneofCase.RowSampleFilter) {
        output.WriteRawTag(113);
        output.WriteDouble(RowSampleFilter);
      }
      if (filterCase_ == FilterOneofCase.ValueRangeFilter) {
        output.WriteRawTag(122);
        output.WriteMessage(ValueRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.Sink) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Sink);
      }
      if (filterCase_ == FilterOneofCase.PassAllFilter) {
        output.WriteRawTag(136, 1);
        output.WriteBool(PassAllFilter);
      }
      if (filterCase_ == FilterOneofCase.BlockAllFilter) {
        output.WriteRawTag(144, 1);
        output.WriteBool(BlockAllFilter);
      }
      if (filterCase_ == FilterOneofCase.ApplyLabelTransformer) {
        output.WriteRawTag(154, 1);
        output.WriteString(ApplyLabelTransformer);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (filterCase_ == FilterOneofCase.Chain) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Chain);
      }
      if (filterCase_ == FilterOneofCase.Interleave) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Interleave);
      }
      if (filterCase_ == FilterOneofCase.Condition) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
      }
      if (filterCase_ == FilterOneofCase.Sink) {
        size += 2 + 1;
      }
      if (filterCase_ == FilterOneofCase.PassAllFilter) {
        size += 2 + 1;
      }
      if (filterCase_ == FilterOneofCase.BlockAllFilter) {
        size += 2 + 1;
      }
      if (filterCase_ == FilterOneofCase.RowKeyRegexFilter) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RowKeyRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.RowSampleFilter) {
        size += 1 + 8;
      }
      if (filterCase_ == FilterOneofCase.FamilyNameRegexFilter) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyNameRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.ColumnQualifierRegexFilter) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ColumnQualifierRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.ColumnRangeFilter) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColumnRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.TimestampRangeFilter) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimestampRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.ValueRegexFilter) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ValueRegexFilter);
      }
      if (filterCase_ == FilterOneofCase.ValueRangeFilter) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValueRangeFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerRowOffsetFilter) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CellsPerRowOffsetFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerRowLimitFilter) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CellsPerRowLimitFilter);
      }
      if (filterCase_ == FilterOneofCase.CellsPerColumnLimitFilter) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CellsPerColumnLimitFilter);
      }
      if (filterCase_ == FilterOneofCase.StripValueTransformer) {
        size += 1 + 1;
      }
      if (filterCase_ == FilterOneofCase.ApplyLabelTransformer) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ApplyLabelTransformer);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RowFilter other) {
      if (other == null) {
        return;
      }
      switch (other.FilterCase) {
        case FilterOneofCase.Chain:
          Chain = other.Chain;
          break;
        case FilterOneofCase.Interleave:
          Interleave = other.Interleave;
          break;
        case FilterOneofCase.Condition:
          Condition = other.Condition;
          break;
        case FilterOneofCase.Sink:
          Sink = other.Sink;
          break;
        case FilterOneofCase.PassAllFilter:
          PassAllFilter = other.PassAllFilter;
          break;
        case FilterOneofCase.BlockAllFilter:
          BlockAllFilter = other.BlockAllFilter;
          break;
        case FilterOneofCase.RowKeyRegexFilter:
          RowKeyRegexFilter = other.RowKeyRegexFilter;
          break;
        case FilterOneofCase.RowSampleFilter:
          RowSampleFilter = other.RowSampleFilter;
          break;
        case FilterOneofCase.FamilyNameRegexFilter:
          FamilyNameRegexFilter = other.FamilyNameRegexFilter;
          break;
        case FilterOneofCase.ColumnQualifierRegexFilter:
          ColumnQualifierRegexFilter = other.ColumnQualifierRegexFilter;
          break;
        case FilterOneofCase.ColumnRangeFilter:
          ColumnRangeFilter = other.ColumnRangeFilter;
          break;
        case FilterOneofCase.TimestampRangeFilter:
          TimestampRangeFilter = other.TimestampRangeFilter;
          break;
        case FilterOneofCase.ValueRegexFilter:
          ValueRegexFilter = other.ValueRegexFilter;
          break;
        case FilterOneofCase.ValueRangeFilter:
          ValueRangeFilter = other.ValueRangeFilter;
          break;
        case FilterOneofCase.CellsPerRowOffsetFilter:
          CellsPerRowOffsetFilter = other.CellsPerRowOffsetFilter;
          break;
        case FilterOneofCase.CellsPerRowLimitFilter:
          CellsPerRowLimitFilter = other.CellsPerRowLimitFilter;
          break;
        case FilterOneofCase.CellsPerColumnLimitFilter:
          CellsPerColumnLimitFilter = other.CellsPerColumnLimitFilter;
          break;
        case FilterOneofCase.StripValueTransformer:
          StripValueTransformer = other.StripValueTransformer;
          break;
        case FilterOneofCase.ApplyLabelTransformer:
          ApplyLabelTransformer = other.ApplyLabelTransformer;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::Google.Bigtable.V1.RowFilter.Types.Chain subBuilder = new global::Google.Bigtable.V1.RowFilter.Types.Chain();
            if (filterCase_ == FilterOneofCase.Chain) {
              subBuilder.MergeFrom(Chain);
            }
            input.ReadMessage(subBuilder);
            Chain = subBuilder;
            break;
          }
          case 18: {
            global::Google.Bigtable.V1.RowFilter.Types.Interleave subBuilder = new global::Google.Bigtable.V1.RowFilter.Types.Interleave();
            if (filterCase_ == FilterOneofCase.Interleave) {
              subBuilder.MergeFrom(Interleave);
            }
            input.ReadMessage(subBuilder);
            Interleave = subBuilder;
            break;
          }
          case 26: {
            global::Google.Bigtable.V1.RowFilter.Types.Condition subBuilder = new global::Google.Bigtable.V1.RowFilter.Types.Condition();
            if (filterCase_ == FilterOneofCase.Condition) {
              subBuilder.MergeFrom(Condition);
            }
            input.ReadMessage(subBuilder);
            Condition = subBuilder;
            break;
          }
          case 34: {
            RowKeyRegexFilter = input.ReadBytes();
            break;
          }
          case 42: {
            FamilyNameRegexFilter = input.ReadString();
            break;
          }
          case 50: {
            ColumnQualifierRegexFilter = input.ReadBytes();
            break;
          }
          case 58: {
            global::Google.Bigtable.V1.ColumnRange subBuilder = new global::Google.Bigtable.V1.ColumnRange();
            if (filterCase_ == FilterOneofCase.ColumnRangeFilter) {
              subBuilder.MergeFrom(ColumnRangeFilter);
            }
            input.ReadMessage(subBuilder);
            ColumnRangeFilter = subBuilder;
            break;
          }
          case 66: {
            global::Google.Bigtable.V1.TimestampRange subBuilder = new global::Google.Bigtable.V1.TimestampRange();
            if (filterCase_ == FilterOneofCase.TimestampRangeFilter) {
              subBuilder.MergeFrom(TimestampRangeFilter);
            }
            input.ReadMessage(subBuilder);
            TimestampRangeFilter = subBuilder;
            break;
          }
          case 74: {
            ValueRegexFilter = input.ReadBytes();
            break;
          }
          case 80: {
            CellsPerRowOffsetFilter = input.ReadInt32();
            break;
          }
          case 88: {
            CellsPerRowLimitFilter = input.ReadInt32();
            break;
          }
          case 96: {
            CellsPerColumnLimitFilter = input.ReadInt32();
            break;
          }
          case 104: {
            StripValueTransformer = input.ReadBool();
            break;
          }
          case 113: {
            RowSampleFilter = input.ReadDouble();
            break;
          }
          case 122: {
            global::Google.Bigtable.V1.ValueRange subBuilder = new global::Google.Bigtable.V1.ValueRange();
            if (filterCase_ == FilterOneofCase.ValueRangeFilter) {
              subBuilder.MergeFrom(ValueRangeFilter);
            }
            input.ReadMessage(subBuilder);
            ValueRangeFilter = subBuilder;
            break;
          }
          case 128: {
            Sink = input.ReadBool();
            break;
          }
          case 136: {
            PassAllFilter = input.ReadBool();
            break;
          }
          case 144: {
            BlockAllFilter = input.ReadBool();
            break;
          }
          case 154: {
            ApplyLabelTransformer = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RowFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  A RowFilter which sends rows through several RowFilters in sequence.
      /// </summary>
      public sealed partial class Chain : pb::IMessage<Chain> {
        private static readonly pb::MessageParser<Chain> _parser = new pb::MessageParser<Chain>(() => new Chain());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Chain> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.RowFilter.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Chain() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Chain(Chain other) : this() {
          filters_ = other.filters_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Chain Clone() {
          return new Chain(this);
        }

        /// <summary>Field number for the "filters" field.</summary>
        public const int FiltersFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Bigtable.V1.RowFilter> _repeated_filters_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Bigtable.V1.RowFilter.Parser);
        private readonly pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter> filters_ = new pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter>();
        /// <summary>
        ///  The elements of "filters" are chained together to process the input row:
        ///  in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
        ///  The full chain is executed atomically.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter> Filters {
          get { return filters_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Chain);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Chain other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!filters_.Equals(other.filters_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= filters_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          filters_.WriteTo(output, _repeated_filters_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += filters_.CalculateSize(_repeated_filters_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Chain other) {
          if (other == null) {
            return;
          }
          filters_.Add(other.filters_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                filters_.AddEntriesFrom(input, _repeated_filters_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  A RowFilter which sends each row to each of several component
      ///  RowFilters and interleaves the results.
      /// </summary>
      public sealed partial class Interleave : pb::IMessage<Interleave> {
        private static readonly pb::MessageParser<Interleave> _parser = new pb::MessageParser<Interleave>(() => new Interleave());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Interleave> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.RowFilter.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interleave() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interleave(Interleave other) : this() {
          filters_ = other.filters_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interleave Clone() {
          return new Interleave(this);
        }

        /// <summary>Field number for the "filters" field.</summary>
        public const int FiltersFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Bigtable.V1.RowFilter> _repeated_filters_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Bigtable.V1.RowFilter.Parser);
        private readonly pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter> filters_ = new pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter>();
        /// <summary>
        ///  The elements of "filters" all process a copy of the input row, and the
        ///  results are pooled, sorted, and combined into a single output row.
        ///  If multiple cells are produced with the same column and timestamp,
        ///  they will all appear in the output row in an unspecified mutual order.
        ///  Consider the following example, with three filters:
        ///
        ///                               input row
        ///                                   |
        ///         -----------------------------------------------------
        ///         |                         |                         |
        ///        f(0)                      f(1)                      f(2)
        ///         |                         |                         |
        ///  1: foo,bar,10,x             foo,bar,10,z              far,bar,7,a
        ///  2: foo,blah,11,z            far,blah,5,x              far,blah,5,x
        ///         |                         |                         |
        ///         -----------------------------------------------------
        ///                                   |
        ///  1:                        foo,bar,10,z     // could have switched with #2
        ///  2:                        foo,bar,10,x     // could have switched with #1
        ///  3:                        foo,blah,11,z
        ///  4:                        far,bar,7,a
        ///  5:                        far,blah,5,x     // identical to #6
        ///  6:                        far,blah,5,x     // identical to #5
        ///  All interleaved filters are executed atomically.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Bigtable.V1.RowFilter> Filters {
          get { return filters_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Interleave);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Interleave other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!filters_.Equals(other.filters_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= filters_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          filters_.WriteTo(output, _repeated_filters_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += filters_.CalculateSize(_repeated_filters_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Interleave other) {
          if (other == null) {
            return;
          }
          filters_.Add(other.filters_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                filters_.AddEntriesFrom(input, _repeated_filters_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  A RowFilter which evaluates one of two possible RowFilters, depending on
      ///  whether or not a predicate RowFilter outputs any cells from the input row.
      ///
      ///  IMPORTANT NOTE: The predicate filter does not execute atomically with the
      ///  true and false filters, which may lead to inconsistent or unexpected
      ///  results. Additionally, Condition filters have poor performance, especially
      ///  when filters are set for the false condition.
      /// </summary>
      public sealed partial class Condition : pb::IMessage<Condition> {
        private static readonly pb::MessageParser<Condition> _parser = new pb::MessageParser<Condition>(() => new Condition());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Condition> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.RowFilter.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition(Condition other) : this() {
          PredicateFilter = other.predicateFilter_ != null ? other.PredicateFilter.Clone() : null;
          TrueFilter = other.trueFilter_ != null ? other.TrueFilter.Clone() : null;
          FalseFilter = other.falseFilter_ != null ? other.FalseFilter.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition Clone() {
          return new Condition(this);
        }

        /// <summary>Field number for the "predicate_filter" field.</summary>
        public const int PredicateFilterFieldNumber = 1;
        private global::Google.Bigtable.V1.RowFilter predicateFilter_;
        /// <summary>
        ///  If "predicate_filter" outputs any cells, then "true_filter" will be
        ///  evaluated on the input row. Otherwise, "false_filter" will be evaluated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Bigtable.V1.RowFilter PredicateFilter {
          get { return predicateFilter_; }
          set {
            predicateFilter_ = value;
          }
        }

        /// <summary>Field number for the "true_filter" field.</summary>
        public const int TrueFilterFieldNumber = 2;
        private global::Google.Bigtable.V1.RowFilter trueFilter_;
        /// <summary>
        ///  The filter to apply to the input row if "predicate_filter" returns any
        ///  results. If not provided, no results will be returned in the true case.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Bigtable.V1.RowFilter TrueFilter {
          get { return trueFilter_; }
          set {
            trueFilter_ = value;
          }
        }

        /// <summary>Field number for the "false_filter" field.</summary>
        public const int FalseFilterFieldNumber = 3;
        private global::Google.Bigtable.V1.RowFilter falseFilter_;
        /// <summary>
        ///  The filter to apply to the input row if "predicate_filter" does not
        ///  return any results. If not provided, no results will be returned in the
        ///  false case.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Bigtable.V1.RowFilter FalseFilter {
          get { return falseFilter_; }
          set {
            falseFilter_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Condition);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Condition other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PredicateFilter, other.PredicateFilter)) return false;
          if (!object.Equals(TrueFilter, other.TrueFilter)) return false;
          if (!object.Equals(FalseFilter, other.FalseFilter)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (predicateFilter_ != null) hash ^= PredicateFilter.GetHashCode();
          if (trueFilter_ != null) hash ^= TrueFilter.GetHashCode();
          if (falseFilter_ != null) hash ^= FalseFilter.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (predicateFilter_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(PredicateFilter);
          }
          if (trueFilter_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TrueFilter);
          }
          if (falseFilter_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(FalseFilter);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (predicateFilter_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PredicateFilter);
          }
          if (trueFilter_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrueFilter);
          }
          if (falseFilter_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(FalseFilter);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Condition other) {
          if (other == null) {
            return;
          }
          if (other.predicateFilter_ != null) {
            if (predicateFilter_ == null) {
              predicateFilter_ = new global::Google.Bigtable.V1.RowFilter();
            }
            PredicateFilter.MergeFrom(other.PredicateFilter);
          }
          if (other.trueFilter_ != null) {
            if (trueFilter_ == null) {
              trueFilter_ = new global::Google.Bigtable.V1.RowFilter();
            }
            TrueFilter.MergeFrom(other.TrueFilter);
          }
          if (other.falseFilter_ != null) {
            if (falseFilter_ == null) {
              falseFilter_ = new global::Google.Bigtable.V1.RowFilter();
            }
            FalseFilter.MergeFrom(other.FalseFilter);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (predicateFilter_ == null) {
                  predicateFilter_ = new global::Google.Bigtable.V1.RowFilter();
                }
                input.ReadMessage(predicateFilter_);
                break;
              }
              case 18: {
                if (trueFilter_ == null) {
                  trueFilter_ = new global::Google.Bigtable.V1.RowFilter();
                }
                input.ReadMessage(trueFilter_);
                break;
              }
              case 26: {
                if (falseFilter_ == null) {
                  falseFilter_ = new global::Google.Bigtable.V1.RowFilter();
                }
                input.ReadMessage(falseFilter_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Specifies a particular change to be made to the contents of a row.
  /// </summary>
  public sealed partial class Mutation : pb::IMessage<Mutation> {
    private static readonly pb::MessageParser<Mutation> _parser = new pb::MessageParser<Mutation>(() => new Mutation());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Mutation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mutation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mutation(Mutation other) : this() {
      switch (other.MutationCase) {
        case MutationOneofCase.SetCell:
          SetCell = other.SetCell.Clone();
          break;
        case MutationOneofCase.DeleteFromColumn:
          DeleteFromColumn = other.DeleteFromColumn.Clone();
          break;
        case MutationOneofCase.DeleteFromFamily:
          DeleteFromFamily = other.DeleteFromFamily.Clone();
          break;
        case MutationOneofCase.DeleteFromRow:
          DeleteFromRow = other.DeleteFromRow.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mutation Clone() {
      return new Mutation(this);
    }

    /// <summary>Field number for the "set_cell" field.</summary>
    public const int SetCellFieldNumber = 1;
    /// <summary>
    ///  Set a cell's value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.Mutation.Types.SetCell SetCell {
      get { return mutationCase_ == MutationOneofCase.SetCell ? (global::Google.Bigtable.V1.Mutation.Types.SetCell) mutation_ : null; }
      set {
        mutation_ = value;
        mutationCase_ = value == null ? MutationOneofCase.None : MutationOneofCase.SetCell;
      }
    }

    /// <summary>Field number for the "delete_from_column" field.</summary>
    public const int DeleteFromColumnFieldNumber = 2;
    /// <summary>
    ///  Deletes cells from a column.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn DeleteFromColumn {
      get { return mutationCase_ == MutationOneofCase.DeleteFromColumn ? (global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn) mutation_ : null; }
      set {
        mutation_ = value;
        mutationCase_ = value == null ? MutationOneofCase.None : MutationOneofCase.DeleteFromColumn;
      }
    }

    /// <summary>Field number for the "delete_from_family" field.</summary>
    public const int DeleteFromFamilyFieldNumber = 3;
    /// <summary>
    ///  Deletes cells from a column family.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily DeleteFromFamily {
      get { return mutationCase_ == MutationOneofCase.DeleteFromFamily ? (global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily) mutation_ : null; }
      set {
        mutation_ = value;
        mutationCase_ = value == null ? MutationOneofCase.None : MutationOneofCase.DeleteFromFamily;
      }
    }

    /// <summary>Field number for the "delete_from_row" field.</summary>
    public const int DeleteFromRowFieldNumber = 4;
    /// <summary>
    ///  Deletes cells from the entire row.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow DeleteFromRow {
      get { return mutationCase_ == MutationOneofCase.DeleteFromRow ? (global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow) mutation_ : null; }
      set {
        mutation_ = value;
        mutationCase_ = value == null ? MutationOneofCase.None : MutationOneofCase.DeleteFromRow;
      }
    }

    private object mutation_;
    /// <summary>Enum of possible cases for the "mutation" oneof.</summary>
    public enum MutationOneofCase {
      None = 0,
      SetCell = 1,
      DeleteFromColumn = 2,
      DeleteFromFamily = 3,
      DeleteFromRow = 4,
    }
    private MutationOneofCase mutationCase_ = MutationOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MutationOneofCase MutationCase {
      get { return mutationCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMutation() {
      mutationCase_ = MutationOneofCase.None;
      mutation_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Mutation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Mutation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SetCell, other.SetCell)) return false;
      if (!object.Equals(DeleteFromColumn, other.DeleteFromColumn)) return false;
      if (!object.Equals(DeleteFromFamily, other.DeleteFromFamily)) return false;
      if (!object.Equals(DeleteFromRow, other.DeleteFromRow)) return false;
      if (MutationCase != other.MutationCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (mutationCase_ == MutationOneofCase.SetCell) hash ^= SetCell.GetHashCode();
      if (mutationCase_ == MutationOneofCase.DeleteFromColumn) hash ^= DeleteFromColumn.GetHashCode();
      if (mutationCase_ == MutationOneofCase.DeleteFromFamily) hash ^= DeleteFromFamily.GetHashCode();
      if (mutationCase_ == MutationOneofCase.DeleteFromRow) hash ^= DeleteFromRow.GetHashCode();
      hash ^= (int) mutationCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (mutationCase_ == MutationOneofCase.SetCell) {
        output.WriteRawTag(10);
        output.WriteMessage(SetCell);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromColumn) {
        output.WriteRawTag(18);
        output.WriteMessage(DeleteFromColumn);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromFamily) {
        output.WriteRawTag(26);
        output.WriteMessage(DeleteFromFamily);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromRow) {
        output.WriteRawTag(34);
        output.WriteMessage(DeleteFromRow);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (mutationCase_ == MutationOneofCase.SetCell) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SetCell);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromColumn) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeleteFromColumn);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromFamily) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeleteFromFamily);
      }
      if (mutationCase_ == MutationOneofCase.DeleteFromRow) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeleteFromRow);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Mutation other) {
      if (other == null) {
        return;
      }
      switch (other.MutationCase) {
        case MutationOneofCase.SetCell:
          SetCell = other.SetCell;
          break;
        case MutationOneofCase.DeleteFromColumn:
          DeleteFromColumn = other.DeleteFromColumn;
          break;
        case MutationOneofCase.DeleteFromFamily:
          DeleteFromFamily = other.DeleteFromFamily;
          break;
        case MutationOneofCase.DeleteFromRow:
          DeleteFromRow = other.DeleteFromRow;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::Google.Bigtable.V1.Mutation.Types.SetCell subBuilder = new global::Google.Bigtable.V1.Mutation.Types.SetCell();
            if (mutationCase_ == MutationOneofCase.SetCell) {
              subBuilder.MergeFrom(SetCell);
            }
            input.ReadMessage(subBuilder);
            SetCell = subBuilder;
            break;
          }
          case 18: {
            global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn subBuilder = new global::Google.Bigtable.V1.Mutation.Types.DeleteFromColumn();
            if (mutationCase_ == MutationOneofCase.DeleteFromColumn) {
              subBuilder.MergeFrom(DeleteFromColumn);
            }
            input.ReadMessage(subBuilder);
            DeleteFromColumn = subBuilder;
            break;
          }
          case 26: {
            global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily subBuilder = new global::Google.Bigtable.V1.Mutation.Types.DeleteFromFamily();
            if (mutationCase_ == MutationOneofCase.DeleteFromFamily) {
              subBuilder.MergeFrom(DeleteFromFamily);
            }
            input.ReadMessage(subBuilder);
            DeleteFromFamily = subBuilder;
            break;
          }
          case 34: {
            global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow subBuilder = new global::Google.Bigtable.V1.Mutation.Types.DeleteFromRow();
            if (mutationCase_ == MutationOneofCase.DeleteFromRow) {
              subBuilder.MergeFrom(DeleteFromRow);
            }
            input.ReadMessage(subBuilder);
            DeleteFromRow = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Mutation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///  A Mutation which sets the value of the specified cell.
      /// </summary>
      public sealed partial class SetCell : pb::IMessage<SetCell> {
        private static readonly pb::MessageParser<SetCell> _parser = new pb::MessageParser<SetCell>(() => new SetCell());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SetCell> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.Mutation.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCell() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCell(SetCell other) : this() {
          familyName_ = other.familyName_;
          columnQualifier_ = other.columnQualifier_;
          timestampMicros_ = other.timestampMicros_;
          value_ = other.value_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCell Clone() {
          return new SetCell(this);
        }

        /// <summary>Field number for the "family_name" field.</summary>
        public const int FamilyNameFieldNumber = 1;
        private string familyName_ = "";
        /// <summary>
        ///  The name of the family into which new data should be written.
        ///  Must match [-_.a-zA-Z0-9]+
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FamilyName {
          get { return familyName_; }
          set {
            familyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "column_qualifier" field.</summary>
        public const int ColumnQualifierFieldNumber = 2;
        private pb::ByteString columnQualifier_ = pb::ByteString.Empty;
        /// <summary>
        ///  The qualifier of the column into which new data should be written.
        ///  Can be any byte string, including the empty string.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString ColumnQualifier {
          get { return columnQualifier_; }
          set {
            columnQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "timestamp_micros" field.</summary>
        public const int TimestampMicrosFieldNumber = 3;
        private long timestampMicros_;
        /// <summary>
        ///  The timestamp of the cell into which new data should be written.
        ///  Use -1 for current Bigtable server time.
        ///  Otherwise, the client should set this value itself, noting that the
        ///  default value is a timestamp of zero if the field is left unspecified.
        ///  Values must match the "granularity" of the table (e.g. micros, millis).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long TimestampMicros {
          get { return timestampMicros_; }
          set {
            timestampMicros_ = value;
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 4;
        private pb::ByteString value_ = pb::ByteString.Empty;
        /// <summary>
        ///  The value to be written into the specified cell.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString Value {
          get { return value_; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SetCell);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SetCell other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FamilyName != other.FamilyName) return false;
          if (ColumnQualifier != other.ColumnQualifier) return false;
          if (TimestampMicros != other.TimestampMicros) return false;
          if (Value != other.Value) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FamilyName.Length != 0) hash ^= FamilyName.GetHashCode();
          if (ColumnQualifier.Length != 0) hash ^= ColumnQualifier.GetHashCode();
          if (TimestampMicros != 0L) hash ^= TimestampMicros.GetHashCode();
          if (Value.Length != 0) hash ^= Value.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FamilyName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FamilyName);
          }
          if (ColumnQualifier.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(ColumnQualifier);
          }
          if (TimestampMicros != 0L) {
            output.WriteRawTag(24);
            output.WriteInt64(TimestampMicros);
          }
          if (Value.Length != 0) {
            output.WriteRawTag(34);
            output.WriteBytes(Value);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FamilyName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyName);
          }
          if (ColumnQualifier.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(ColumnQualifier);
          }
          if (TimestampMicros != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(TimestampMicros);
          }
          if (Value.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Value);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SetCell other) {
          if (other == null) {
            return;
          }
          if (other.FamilyName.Length != 0) {
            FamilyName = other.FamilyName;
          }
          if (other.ColumnQualifier.Length != 0) {
            ColumnQualifier = other.ColumnQualifier;
          }
          if (other.TimestampMicros != 0L) {
            TimestampMicros = other.TimestampMicros;
          }
          if (other.Value.Length != 0) {
            Value = other.Value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                FamilyName = input.ReadString();
                break;
              }
              case 18: {
                ColumnQualifier = input.ReadBytes();
                break;
              }
              case 24: {
                TimestampMicros = input.ReadInt64();
                break;
              }
              case 34: {
                Value = input.ReadBytes();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  A Mutation which deletes cells from the specified column, optionally
      ///  restricting the deletions to a given timestamp range.
      /// </summary>
      public sealed partial class DeleteFromColumn : pb::IMessage<DeleteFromColumn> {
        private static readonly pb::MessageParser<DeleteFromColumn> _parser = new pb::MessageParser<DeleteFromColumn>(() => new DeleteFromColumn());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeleteFromColumn> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.Mutation.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromColumn() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromColumn(DeleteFromColumn other) : this() {
          familyName_ = other.familyName_;
          columnQualifier_ = other.columnQualifier_;
          TimeRange = other.timeRange_ != null ? other.TimeRange.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromColumn Clone() {
          return new DeleteFromColumn(this);
        }

        /// <summary>Field number for the "family_name" field.</summary>
        public const int FamilyNameFieldNumber = 1;
        private string familyName_ = "";
        /// <summary>
        ///  The name of the family from which cells should be deleted.
        ///  Must match [-_.a-zA-Z0-9]+
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FamilyName {
          get { return familyName_; }
          set {
            familyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "column_qualifier" field.</summary>
        public const int ColumnQualifierFieldNumber = 2;
        private pb::ByteString columnQualifier_ = pb::ByteString.Empty;
        /// <summary>
        ///  The qualifier of the column from which cells should be deleted.
        ///  Can be any byte string, including the empty string.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString ColumnQualifier {
          get { return columnQualifier_; }
          set {
            columnQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "time_range" field.</summary>
        public const int TimeRangeFieldNumber = 3;
        private global::Google.Bigtable.V1.TimestampRange timeRange_;
        /// <summary>
        ///  The range of timestamps within which cells should be deleted.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Bigtable.V1.TimestampRange TimeRange {
          get { return timeRange_; }
          set {
            timeRange_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeleteFromColumn);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeleteFromColumn other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FamilyName != other.FamilyName) return false;
          if (ColumnQualifier != other.ColumnQualifier) return false;
          if (!object.Equals(TimeRange, other.TimeRange)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FamilyName.Length != 0) hash ^= FamilyName.GetHashCode();
          if (ColumnQualifier.Length != 0) hash ^= ColumnQualifier.GetHashCode();
          if (timeRange_ != null) hash ^= TimeRange.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FamilyName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FamilyName);
          }
          if (ColumnQualifier.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(ColumnQualifier);
          }
          if (timeRange_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TimeRange);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FamilyName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyName);
          }
          if (ColumnQualifier.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(ColumnQualifier);
          }
          if (timeRange_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeRange);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeleteFromColumn other) {
          if (other == null) {
            return;
          }
          if (other.FamilyName.Length != 0) {
            FamilyName = other.FamilyName;
          }
          if (other.ColumnQualifier.Length != 0) {
            ColumnQualifier = other.ColumnQualifier;
          }
          if (other.timeRange_ != null) {
            if (timeRange_ == null) {
              timeRange_ = new global::Google.Bigtable.V1.TimestampRange();
            }
            TimeRange.MergeFrom(other.TimeRange);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                FamilyName = input.ReadString();
                break;
              }
              case 18: {
                ColumnQualifier = input.ReadBytes();
                break;
              }
              case 26: {
                if (timeRange_ == null) {
                  timeRange_ = new global::Google.Bigtable.V1.TimestampRange();
                }
                input.ReadMessage(timeRange_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  A Mutation which deletes all cells from the specified column family.
      /// </summary>
      public sealed partial class DeleteFromFamily : pb::IMessage<DeleteFromFamily> {
        private static readonly pb::MessageParser<DeleteFromFamily> _parser = new pb::MessageParser<DeleteFromFamily>(() => new DeleteFromFamily());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeleteFromFamily> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.Mutation.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromFamily() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromFamily(DeleteFromFamily other) : this() {
          familyName_ = other.familyName_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromFamily Clone() {
          return new DeleteFromFamily(this);
        }

        /// <summary>Field number for the "family_name" field.</summary>
        public const int FamilyNameFieldNumber = 1;
        private string familyName_ = "";
        /// <summary>
        ///  The name of the family from which cells should be deleted.
        ///  Must match [-_.a-zA-Z0-9]+
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FamilyName {
          get { return familyName_; }
          set {
            familyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeleteFromFamily);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeleteFromFamily other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FamilyName != other.FamilyName) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FamilyName.Length != 0) hash ^= FamilyName.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FamilyName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FamilyName);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FamilyName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyName);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeleteFromFamily other) {
          if (other == null) {
            return;
          }
          if (other.FamilyName.Length != 0) {
            FamilyName = other.FamilyName;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                FamilyName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      ///  A Mutation which deletes all cells from the containing row.
      /// </summary>
      public sealed partial class DeleteFromRow : pb::IMessage<DeleteFromRow> {
        private static readonly pb::MessageParser<DeleteFromRow> _parser = new pb::MessageParser<DeleteFromRow>(() => new DeleteFromRow());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeleteFromRow> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Bigtable.V1.Mutation.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromRow() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromRow(DeleteFromRow other) : this() {
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeleteFromRow Clone() {
          return new DeleteFromRow(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeleteFromRow);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeleteFromRow other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeleteFromRow other) {
          if (other == null) {
            return;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Specifies an atomic read/modify/write operation on the latest value of the
  ///  specified column.
  /// </summary>
  public sealed partial class ReadModifyWriteRule : pb::IMessage<ReadModifyWriteRule> {
    private static readonly pb::MessageParser<ReadModifyWriteRule> _parser = new pb::MessageParser<ReadModifyWriteRule>(() => new ReadModifyWriteRule());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReadModifyWriteRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Bigtable.V1.BigtableDataReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadModifyWriteRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadModifyWriteRule(ReadModifyWriteRule other) : this() {
      familyName_ = other.familyName_;
      columnQualifier_ = other.columnQualifier_;
      switch (other.RuleCase) {
        case RuleOneofCase.AppendValue:
          AppendValue = other.AppendValue;
          break;
        case RuleOneofCase.IncrementAmount:
          IncrementAmount = other.IncrementAmount;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadModifyWriteRule Clone() {
      return new ReadModifyWriteRule(this);
    }

    /// <summary>Field number for the "family_name" field.</summary>
    public const int FamilyNameFieldNumber = 1;
    private string familyName_ = "";
    /// <summary>
    ///  The name of the family to which the read/modify/write should be applied.
    ///  Must match [-_.a-zA-Z0-9]+
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FamilyName {
      get { return familyName_; }
      set {
        familyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "column_qualifier" field.</summary>
    public const int ColumnQualifierFieldNumber = 2;
    private pb::ByteString columnQualifier_ = pb::ByteString.Empty;
    /// <summary>
    ///  The qualifier of the column to which the read/modify/write should be
    ///  applied.
    ///  Can be any byte string, including the empty string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ColumnQualifier {
      get { return columnQualifier_; }
      set {
        columnQualifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "append_value" field.</summary>
    public const int AppendValueFieldNumber = 3;
    /// <summary>
    ///  Rule specifying that "append_value" be appended to the existing value.
    ///  If the targeted cell is unset, it will be treated as containing the
    ///  empty string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString AppendValue {
      get { return ruleCase_ == RuleOneofCase.AppendValue ? (pb::ByteString) rule_ : pb::ByteString.Empty; }
      set {
        rule_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        ruleCase_ = RuleOneofCase.AppendValue;
      }
    }

    /// <summary>Field number for the "increment_amount" field.</summary>
    public const int IncrementAmountFieldNumber = 4;
    /// <summary>
    ///  Rule specifying that "increment_amount" be added to the existing value.
    ///  If the targeted cell is unset, it will be treated as containing a zero.
    ///  Otherwise, the targeted cell must contain an 8-byte value (interpreted
    ///  as a 64-bit big-endian signed integer), or the entire request will fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IncrementAmount {
      get { return ruleCase_ == RuleOneofCase.IncrementAmount ? (long) rule_ : 0L; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.IncrementAmount;
      }
    }

    private object rule_;
    /// <summary>Enum of possible cases for the "rule" oneof.</summary>
    public enum RuleOneofCase {
      None = 0,
      AppendValue = 3,
      IncrementAmount = 4,
    }
    private RuleOneofCase ruleCase_ = RuleOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleOneofCase RuleCase {
      get { return ruleCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRule() {
      ruleCase_ = RuleOneofCase.None;
      rule_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReadModifyWriteRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReadModifyWriteRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FamilyName != other.FamilyName) return false;
      if (ColumnQualifier != other.ColumnQualifier) return false;
      if (AppendValue != other.AppendValue) return false;
      if (IncrementAmount != other.IncrementAmount) return false;
      if (RuleCase != other.RuleCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FamilyName.Length != 0) hash ^= FamilyName.GetHashCode();
      if (ColumnQualifier.Length != 0) hash ^= ColumnQualifier.GetHashCode();
      if (ruleCase_ == RuleOneofCase.AppendValue) hash ^= AppendValue.GetHashCode();
      if (ruleCase_ == RuleOneofCase.IncrementAmount) hash ^= IncrementAmount.GetHashCode();
      hash ^= (int) ruleCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (FamilyName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FamilyName);
      }
      if (ColumnQualifier.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(ColumnQualifier);
      }
      if (ruleCase_ == RuleOneofCase.AppendValue) {
        output.WriteRawTag(26);
        output.WriteBytes(AppendValue);
      }
      if (ruleCase_ == RuleOneofCase.IncrementAmount) {
        output.WriteRawTag(32);
        output.WriteInt64(IncrementAmount);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FamilyName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FamilyName);
      }
      if (ColumnQualifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ColumnQualifier);
      }
      if (ruleCase_ == RuleOneofCase.AppendValue) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(AppendValue);
      }
      if (ruleCase_ == RuleOneofCase.IncrementAmount) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IncrementAmount);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReadModifyWriteRule other) {
      if (other == null) {
        return;
      }
      if (other.FamilyName.Length != 0) {
        FamilyName = other.FamilyName;
      }
      if (other.ColumnQualifier.Length != 0) {
        ColumnQualifier = other.ColumnQualifier;
      }
      switch (other.RuleCase) {
        case RuleOneofCase.AppendValue:
          AppendValue = other.AppendValue;
          break;
        case RuleOneofCase.IncrementAmount:
          IncrementAmount = other.IncrementAmount;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FamilyName = input.ReadString();
            break;
          }
          case 18: {
            ColumnQualifier = input.ReadBytes();
            break;
          }
          case 26: {
            AppendValue = input.ReadBytes();
            break;
          }
          case 32: {
            IncrementAmount = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
